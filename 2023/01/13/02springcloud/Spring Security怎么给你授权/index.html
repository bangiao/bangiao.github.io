<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring Security怎么给你授权"><meta name="keywords" content="过滤器,springsecurity,源码分析,权限,权限管理,授权,鉴权"><meta name="author" content="Bangiao"><meta name="copyright" content="Bangiao"><title>Spring Security怎么给你授权 | Bangiao's Notebooks</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">授权是什么?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E6%98%AF%E6%80%8E%E4%B9%88%E9%85%8D%E5%90%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">认证和授权是怎么配合工作的?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%AF%E8%A7%92%E8%89%B2%E8%BF%98%E6%98%AF%E6%9D%83%E9%99%90"><span class="toc-number">4.</span> <span class="toc-text">是角色还是权限?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF"><span class="toc-number">4.0.1.</span> <span class="toc-text">角色继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#buildRolesReachableInOneStepMap"><span class="toc-number">4.0.1.1.1.</span> <span class="toc-text">buildRolesReachableInOneStepMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#buildRolesReachableInOneOrMoreStepsMap"><span class="toc-number">4.0.1.1.2.</span> <span class="toc-text">buildRolesReachableInOneOrMoreStepsMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#roleHierarchy-getReachableGrantedAuthorities"><span class="toc-number">4.0.1.1.3.</span> <span class="toc-text">roleHierarchy.getReachableGrantedAuthorities</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">授权的方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">授权过程源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF"><span class="toc-number">6.1.</span> <span class="toc-text">源码分析思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">6.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8EURL%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90"><span class="toc-number">6.2.1.</span> <span class="toc-text">从URL开始分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8EAOP-%E6%96%B9%E6%B3%95-%E6%96%B9%E5%BC%8F%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90"><span class="toc-number">6.2.2.</span> <span class="toc-text">从AOP(方法)方式开始分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://imgsa.baidu.com/forum/pic/item/c8179682d158ccbf63dc944d1bd8bc3eb03541a9.jpg"></div><div class="author-info__name text-center">Bangiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/bangiao">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">72</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">638</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的博客</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/4248168662314823">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30690165">CSDN</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/bangiao/">博客园</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/projects">Gitee笔记源码</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bangiao's Notebooks</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章列表</a><a class="site-page" href="/tags">文章标签</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/sources">笔记源码</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Spring Security怎么给你授权</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/springcloud/">springcloud</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Security核心功能, 认证和授权, 本章便是核心章节, 授权, 需要关注, 关注, 再关注</p>
<h1 id="授权是什么"><a href="#授权是什么" class="headerlink" title="授权是什么?"></a>授权是什么?</h1><p>首先到底什么是授权, 通俗易懂版:</p>
<blockquote>
<p>你有什么权限以支持你去做哪些事, 操作哪些资源</p>
</blockquote>
<h1 id="认证和授权是怎么配合工作的"><a href="#认证和授权是怎么配合工作的" class="headerlink" title="认证和授权是怎么配合工作的?"></a>认证和授权是怎么配合工作的?</h1><blockquote>
<p>小白: “前面我们知道, 认证成功之后会将数据存储在<code>SecurityContextHolder</code>上下文中, 那么这些用户信息怎么在授权阶段使用?”</p>
<p>小黑: “在 Spring Security 中认证和授权是完全分开的关系, 不管你认证使用的是Basic Http认证还是Disgest Http认证方式还是基于表单的认证方式, 都不影响我后续的授权, 这一点你需要记住”</p>
<p>小白: “那你还是没有说到关键点”</p>
<p>小黑: “嗯, 请看这里”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">   Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小黑: “Spring Security围绕上面的<code>getAuthorities</code>函数完成授权, 就这么简单, 你当然登录的用户有什么权限, 就看上面这个函数返回的集合有什么权限了”</p>
<p>小白: “不对啊, 我角色呢? 现在大家不都是基于角色访问控制(<code>Role-Based Access Control</code>)么?”</p>
<p>小黑: “是啊, 这个问题需要具体讨论”</p>
</blockquote>
<h1 id="是角色还是权限"><a href="#是角色还是权限" class="headerlink" title="是角色还是权限?"></a>是角色还是权限?</h1><p>在Spring Security的代码层面看, 角色和权限没有很大的区别, 只能说权限和角色在Spring Security层面都只不过是字符串而已, 角色前面多了个<code>ROLE_</code>来区分是不是角色, 但这两都是字符串</p>
<blockquote>
<p>小白: “等等, 问个问题, 角色和权限有什么区别?”</p>
<p>小黑: “角色你可以看做是权限的集合, 当然他两的关系是多对多关系, 区别还是权限和角色的颗粒度不同, 权限你可以看做是原子, 而角色你可以看做是分子”</p>
<p>小白: “那么从<code>Authentication.getAuthorities</code>函数拿出来的集合是角色还是权限?”</p>
<p>小黑: “<code>getAuthorities</code>函数为什么不能同时返回角色和权限呢? 两个一起返回”</p>
<p>小白: “啊? 那不乱么?”</p>
<p>小黑: “前面不是说了吗，在spring security中权限和角色，是同一个东西都是字符串啊, 只不过会给角色前面加上前缀以示区分而已, 给你看张图”</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132117595.png" alt="image-20230112135812104"></p>
<blockquote>
<p>小黑: “这是一张Spring Secuirty默认生成的表结构, 看看里面的内容, 包括角色和权限”</p>
<p>小黑: “该方法的返回值一般是这样的，比如说你要查询叫<code>zhazha</code>这个用户的权限或者角色，那么它会返回这样一个集合<code>&#39;ROLE_ADMIN, readHello, writeHello&#39;</code>, 这个函数就是这样用的。”</p>
</blockquote>
<blockquote>
<p>小白: “等等, 有些用户有多个角色，那你应该拿到哪一个角色的权限集合呢？还是两个角色的权限集合全部拿到呢？”</p>
<p>小黑: “这个需要根据你系统的设计而决定，正常情况下呢，如果你在登录完成之后，有一个切换角色的按钮，那么在这样的一个系统中，你应该拿到单个角色的权限集合。如果你的系统没有切换角色这个按钮，那么应该返回所有角色的所有权限集合。”</p>
<p>小黑: “为了更好理解我，把两种模式的<code>user</code>对象代码列出来。”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Users</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, UserDetails, CredentialsContainer &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">enabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略一堆属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小黑: “如果他是<strong>用户 &lt;&#x3D;&#x3D;&gt; 权限 &lt;&#x3D;&#x3D;&gt; 资源</strong>这种情况。”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; authorities;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthorityUtils.createAuthorityList(authorities.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小黑: “直接从数据库中查出所有的权限，然后在这个方法中直接返回就行了，就这么简单。”</p>
<p>小黑: “如果他是<strong>用户 &lt;&#x3D;&#x3D;&gt; 角色 &lt;&#x3D;&#x3D;&gt; 权限 &lt;&#x3D;&#x3D;&gt; 资源</strong>这种情况”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只代表当前角色, 角色可以有多种, 但是在我给的事例代码中需要用户手动切换角色</span></span><br><span class="line"><span class="comment">// private Role role;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种表示拿出用户的所有角色</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollUtil.isEmpty(roles)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加角色名到 authorities 中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">List</span> <span class="variable">authorities</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(AuthorityUtils.createAuthorityList(roles.stream().map(Role::getAuthority).collect(Collectors.joining())));</span><br><span class="line">    roles.forEach(role -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isNotEmpty(role.getOperations())) &#123;</span><br><span class="line">           <span class="comment">// 添加权限到 authorities 中</span></span><br><span class="line">            authorities.addAll(AuthorityUtils.createAuthorityList(role.getOperations().stream().map(Operation::getAuthority).collect(Collectors.joining())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> authorities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小白: “这样不是每次授权都要访问一次数据库么? “</p>
<p>小黑: “你忘了么? 这里是<code>User</code>对象下面的<code>getAuthorities</code>函数, 而不是<code>Authentication.getAuthorities</code>函数, 而<code>Authentication</code>是缓存在<code>session</code>中的(当然有些情况缓存在<code>redis</code>中)”</p>
<p>小黑: “<code>User</code>对象的<code>getAuthorities</code>函数只会在下面代码执行一次, 之后就被缓存在<code>session</code>中了, 而授权并非使用的User对象, 而是 <code>Authentication</code>对象下面的<code>getAuthorities</code>函数”</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118059.png" alt="image-20230111190329778"></p>
<h3 id="角色继承"><a href="#角色继承" class="headerlink" title="角色继承"></a>角色继承</h3><p>Spring Security提供了用户角色权限继承功能, 比如你是班主任也是老师, 那么班主任可以继承老师角色的权限, 并提供属于班主任的权限</p>
<blockquote>
<p>这里只是举个例子, 不要杠精哦</p>
</blockquote>
<blockquote>
<p>小白: “等等, 你不是说 Spring Security没有角色么?”</p>
<p>小黑: “你中文肯定不合格, 我说的是Spring Security代码层面角色和权限没区别, 都是字符串而已, 而非没有角色”</p>
</blockquote>
<p>Spring Security中通过<code>RoleHierarchy</code>接口实现角色继承功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoleHierarchy</span> &#123;</span><br><span class="line">   Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getReachableGrantedAuthorities(</span><br><span class="line">         Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118805.png" alt="image-20230111191233244"></p>
<p><code>RoleHierarchy</code>中只有一个<code>getReachableGrantedAuthorities</code>方法，该方法返回用户真正“可触达”的权限。</p>
<p>举个简单例子，假设用户定义了<code>ROLE_ADMIN</code>继承自 <code>ROLE_USER</code>，<code>ROLE_USER</code>继承自<code>ROLE_GUEST</code>，现在当前用户角色是<code>ROLE_ADMIN</code>，但是它实际可访问的资源也包含<code>ROLE_USER</code>和<code>ROLE_GUEST</code>能访问的资源.</p>
<p><code>getReachableGrantedAuthorities</code>方法就是根据当前用户所具有的角色，从角色层级映射中解析出用户真正“可触达”的权限。</p>
<p><code>RoleHierarchy</code>只有一个实现类<code>RoleHierarchyImpl</code>(还有一个没啥用的实现类)，开发者一般通过<code>RoleHierarchyImpl</code>类来定义角色的层级关系,如下面代码表示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">roleHierarchy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">    roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">    System.err.println(roleHierarchy.getReachableGrantedAuthorities(List.of(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_USER&quot;</span>)))); <span class="comment">// [ROLE_USER, ROLE_GUEST]</span></span><br><span class="line">    System.err.println(roleHierarchy.getReachableGrantedAuthorities(List.of(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_GUEST&quot;</span>)))); <span class="comment">// [ROLE_GUEST]</span></span><br><span class="line">    System.err.println(roleHierarchy.getReachableGrantedAuthorities(List.of(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_ADMIN&quot;</span>)))); <span class="comment">// [ROLE_USER, ROLE_GUEST, ROLE_ADMIN]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说白了, 就是一个分组对象</p>
<p>在项目中一般这么用?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleConfig</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RoleHierarchy <span class="title function_">roleHierarchy</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">      roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> roleHierarchy;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>我感觉也不是很方便的样子</p>
</blockquote>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>这段源码分析是必须的, 晚上一堆配置方法, 但对于角色继承方法来说, 是有新旧方法之分的, 所以我们需要事先声明, 我们的版本是基于 Spring Boot 2.7.5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RoleHierarchy <span class="title function_">roleHierarchy</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">   roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> roleHierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们基于这段代码分析源码</p>
<p>首先我们进入的函数是这个:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHierarchy</span><span class="params">(String roleHierarchyStringRepresentation)</span> &#123;</span><br><span class="line">   <span class="comment">// 保存 ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST</span></span><br><span class="line">   <span class="built_in">this</span>.roleHierarchyStringRepresentation = roleHierarchyStringRepresentation;</span><br><span class="line">   buildRolesReachableInOneStepMap();</span><br><span class="line">   buildRolesReachableInOneOrMoreStepsMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后分为这两个方法<code>buildRolesReachableInOneStepMap</code> <code>buildRolesReachableInOneOrMoreStepsMap</code></p>
<h5 id="buildRolesReachableInOneStepMap"><a href="#buildRolesReachableInOneStepMap" class="headerlink" title="buildRolesReachableInOneStepMap"></a><code>buildRolesReachableInOneStepMap</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildRolesReachableInOneStepMap</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.rolesReachableInOneStepMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 首先对字符串进行 \n 分组, 然后遍历, 我们的代码少了 \n ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST </span></span><br><span class="line">   <span class="keyword">for</span> (String line : <span class="built_in">this</span>.roleHierarchyStringRepresentation.split(<span class="string">&quot;\n&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 对 &#x27; &gt; &#x27;(大括号前面有空格, 至少一个空格) 进行分组</span></span><br><span class="line">      String[] roles = line.trim().split(<span class="string">&quot;\\s+&gt;\\s+&quot;</span>);</span><br><span class="line">      <span class="comment">// i = 1, 只对前面两个角色有处理</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; roles.length; i++) &#123;</span><br><span class="line">         <span class="comment">// 拿出第一个 ROLE_ADMIN 虽然 i = 1 但是拿的是第 0 个</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">higherRole</span> <span class="operator">=</span> roles[i - <span class="number">1</span>];</span><br><span class="line">         <span class="comment">// 拿到下一个角色, ROLE_USER </span></span><br><span class="line">         <span class="type">GrantedAuthority</span> <span class="variable">lowerRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(roles[i]);</span><br><span class="line">         Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet;</span><br><span class="line">         <span class="comment">// 不包含 ROLE_ADMIN</span></span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">this</span>.rolesReachableInOneStepMap.containsKey(higherRole)) &#123;</span><br><span class="line">            rolesReachableInOneStepSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 以 ROLE_ADMIN 为 key, new 出 value</span></span><br><span class="line">            <span class="built_in">this</span>.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            rolesReachableInOneStepSet = <span class="built_in">this</span>.rolesReachableInOneStepMap.get(higherRole);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 将 ROLE_USER 添加到 ROLE_ADMIN 分组底下</span></span><br><span class="line">         rolesReachableInOneStepSet.add(lowerRole);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的代码, 针对 <code>ROLE_ADMIN</code> 的分组, 添加了 <code>ROLE_USER</code></p>
<p>然后在内部的那个 <code>for</code> 循环中, 对 <code>ROLE_USER</code> 创建了一个分组, 然后在 分组中添加 <code>ROLE_GUEST</code></p>
<p>最终结果是</p>
<p><code>ROLE_ADMIN</code> 分组只有 <code>ROLE_USER</code> 的权限</p>
<p><code>ROLE_USER</code> 分组有 <code>ROLE_GUEST</code>权限</p>
<p>所以这么写, 最后的结果 原本 应该拥有 <code>ROLE_USER</code> 和 <code>ROLE_GUEST</code> 权限的 <code>ROLE_ADMIN</code> 只能有 <code>ROLE_USER</code> , 没有<code>ROLE_GUEST</code>的权限</p>
<blockquote>
<p>如果我们没看<code>roleHierarchy.getReachableGrantedAuthorities</code>方法的话, 这肯定是不对的</p>
</blockquote>
<blockquote>
<p>这里其实三种方法都行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">   <span class="type">StrJoiner</span> <span class="variable">joiner</span> <span class="operator">=</span> StrJoiner.of(<span class="string">&quot;\n&quot;</span>).append(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER&quot;</span>).append(<span class="string">&quot;ROLE_USER &gt; ROLE_GUEST&quot;</span>).append(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">   roleHierarchy.setHierarchy(joiner.toString());</span><br><span class="line">   Collection&lt;GrantedAuthority&gt; authorityCollection = roleHierarchy.getReachableGrantedAuthorities(List.of(() -&gt; <span class="string">&quot;ROLE_ADMIN&quot;</span>));</span><br><span class="line">   <span class="keyword">for</span> (GrantedAuthority grantedAuthority : authorityCollection) &#123;</span><br><span class="line">      System.out.print(grantedAuthority.getAuthority() + <span class="string">&quot;\t&quot;</span>); <span class="comment">// ROLE_USER ROLE_GUEST ROLE_ADMIN</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">   roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">   Collection&lt;GrantedAuthority&gt; authorityCollection = roleHierarchy.getReachableGrantedAuthorities(List.of(() -&gt; <span class="string">&quot;ROLE_ADMIN&quot;</span>));</span><br><span class="line">   <span class="keyword">for</span> (GrantedAuthority grantedAuthority : authorityCollection) &#123;</span><br><span class="line">      System.out.print(grantedAuthority.getAuthority() + <span class="string">&quot;\t&quot;</span>); <span class="comment">// ROLE_USER ROLE_GUEST ROLE_ADMIN</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">   <span class="type">StringJoiner</span> <span class="variable">stringJoiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   stringJoiner.add(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER&quot;</span>);</span><br><span class="line">   stringJoiner.add(<span class="string">&quot;ROLE_USER &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">   roleHierarchy.setHierarchy(stringJoiner.toString());</span><br><span class="line">   Collection&lt;GrantedAuthority&gt; authorityCollection = roleHierarchy.getReachableGrantedAuthorities(List.of(() -&gt; <span class="string">&quot;ROLE_ADMIN&quot;</span>));</span><br><span class="line">   <span class="keyword">for</span> (GrantedAuthority grantedAuthority : authorityCollection) &#123;</span><br><span class="line">      System.out.print(grantedAuthority.getAuthority() + <span class="string">&quot;\t&quot;</span>); <span class="comment">// ROLE_USER ROLE_GUEST ROLE_ADMIN</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="buildRolesReachableInOneOrMoreStepsMap"><a href="#buildRolesReachableInOneOrMoreStepsMap" class="headerlink" title="buildRolesReachableInOneOrMoreStepsMap"></a><code>buildRolesReachableInOneOrMoreStepsMap</code></h5><p>给可达的分组继续添加剩余的角色</p>
<blockquote>
<p>我们分析源码的过程完全按照<code>&quot;ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST&quot;</code>分析的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildRolesReachableInOneOrMoreStepsMap</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.rolesReachableInOneOrMoreStepsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 迭代分组</span></span><br><span class="line">   <span class="keyword">for</span> (String roleName : <span class="built_in">this</span>.rolesReachableInOneStepMap.keySet()) &#123;</span><br><span class="line">      <span class="comment">// 拿出第一个分组下的成员列表</span></span><br><span class="line">      Set&lt;GrantedAuthority&gt; rolesToVisitSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="built_in">this</span>.rolesReachableInOneStepMap.get(roleName));</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      Set&lt;GrantedAuthority&gt; visitedRolesSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> (!rolesToVisitSet.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">// 拿到成员的第一个角色名</span></span><br><span class="line">         <span class="type">GrantedAuthority</span> <span class="variable">lowerRole</span> <span class="operator">=</span> rolesToVisitSet.iterator().next();</span><br><span class="line">         <span class="comment">// 把拿到的分组删除掉</span></span><br><span class="line">         rolesToVisitSet.remove(lowerRole);</span><br><span class="line">         <span class="comment">// 将拿到的成员添加到 visitedRolesSet 集合中, 添加成功, 继续下一次循环</span></span><br><span class="line">         <span class="comment">// 核心代码在!this.rolesReachableInOneStepMap.containsKey(lowerRole.getAuthority())</span></span><br><span class="line">         <span class="comment">// 如果添加的 ROLE_ADMIN 组长的成员 ROLE_USER 在原先分组中也担任组长的话, 那意味着 ROLE_USER 组长底下的所有成员也是 ROLE_ADMIN 的成员</span></span><br><span class="line">         <span class="comment">// 因为 ROLE_ADMIN 也是 ROLE_USER 的成员</span></span><br><span class="line">         <span class="comment">// 所以下面的那个 !containsKey(不包含) 方法, 不执行</span></span><br><span class="line">         <span class="keyword">if</span> (!visitedRolesSet.add(lowerRole)</span><br><span class="line">               || !<span class="built_in">this</span>.rolesReachableInOneStepMap.containsKey(lowerRole.getAuthority())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// Already visited role or role with missing hierarchy</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (roleName.equals(lowerRole.getAuthority())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CycleInRoleHierarchyException</span>();</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 将搜索到的所有可达成员, 添加到新的集合的分组中, 换句话说就是new了个新的分组, 在分组 ROLE_USER 下, 添加可达成员 ROLE_GUEST</span></span><br><span class="line">         <span class="comment">// 如果是 ROLE_ADMIN 分组组长, 那么就添加 ROLE_USER 和 ROLE_GUEST</span></span><br><span class="line">         <span class="comment">// !containsKey 不包含代码不执行 continue 之后, 就会将 ROLE_USER 底下的所有成员都给 ROLE_ADMIN</span></span><br><span class="line">         <span class="comment">// 往这个集合 rolesToVisitSet 添加另一个集合后, 上面的 !rolesToVisitSet.isEmpty() 条件也满足了, 继续添加 ROLE_USER 的成员</span></span><br><span class="line">         rolesToVisitSet.addAll(<span class="built_in">this</span>.rolesReachableInOneStepMap.get(lowerRole.getAuthority()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将上面的结果visitedRolesSet 添加到 roleName 的分组中</span></span><br><span class="line">      <span class="built_in">this</span>.rolesReachableInOneOrMoreStepsMap.put(roleName, visitedRolesSet);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终添加的结果是这样:</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118586.png" alt="image-20221202162341432"></p>
<p>至此分组彻底完成</p>
<h5 id="roleHierarchy-getReachableGrantedAuthorities"><a href="#roleHierarchy-getReachableGrantedAuthorities" class="headerlink" title="roleHierarchy.getReachableGrantedAuthorities"></a><code>roleHierarchy.getReachableGrantedAuthorities</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;GrantedAuthority&gt; <span class="title function_">getReachableGrantedAuthorities</span><span class="params">(</span></span><br><span class="line"><span class="params">      Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (authorities == <span class="literal">null</span> || authorities.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> AuthorityUtils.NO_AUTHORITIES;</span><br><span class="line">   &#125;</span><br><span class="line">   Set&lt;GrantedAuthority&gt; reachableRoles = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 从参数拿到的角色名被存入到下面的函数 ROLE_ADMIN</span></span><br><span class="line">   Set&lt;String&gt; processedNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">      <span class="comment">// Do not process authorities without string representation</span></span><br><span class="line">      <span class="keyword">if</span> (authority.getAuthority() == <span class="literal">null</span>) &#123;</span><br><span class="line">         reachableRoles.add(authority);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// processedNames.add(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line">      <span class="keyword">if</span> (!processedNames.add(authority.getAuthority())) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Add original authority</span></span><br><span class="line">      reachableRoles.add(authority);</span><br><span class="line">      <span class="comment">// 从这里拿到可达集合, 根据数组 ROLE_ADMIN 拿到组长的成员 ROLE_USER 和 ROLE_GUEST</span></span><br><span class="line">      Set&lt;GrantedAuthority&gt; lowerRoles = <span class="built_in">this</span>.rolesReachableInOneOrMoreStepsMap.get(authority.getAuthority());</span><br><span class="line">      <span class="keyword">if</span> (lowerRoles == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">continue</span>; <span class="comment">// No hierarchy for the role</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (GrantedAuthority role : lowerRoles) &#123;</span><br><span class="line">         <span class="comment">// 添加已经添加了 (ROLE_ADMIN) , 现在准备添加 ROLE_USER 和 ROLE_GUEST</span></span><br><span class="line">         <span class="keyword">if</span> (processedNames.add(role.getAuthority())) &#123;</span><br><span class="line">            <span class="comment">// 将对象也添加到可达列表中(ROLE_ADMIN, ROLE_USER 和 ROLE_GUEST)</span></span><br><span class="line">            reachableRoles.add(role);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(reachableRoles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后结果: </p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118614.png" alt="image-20221202163159109"></p>
<p>结果返回到这样了:</p>
<p><img src="https://jsd.cdn.zzko.cn/gh/bangiao/blog_images@main/blog/202212021632571.png" alt="image-20221202163239489"></p>
<p>至此源码分析完成</p>
<p>总结下:</p>
<p>整个过程, 像是借助我们的表达式, 解析出我们写入的字符串的表达式, 存放在 <code>Map&lt;String, Set&lt;GrantedAuthority&gt;&gt; rolesReachableInOneStepMap</code>对象</p>
<p>但该集合中的内容是不完整的, <code>rolesReachableInOneStepMap</code>集合只能存放一级角色关系, 比如你是 <code>admin</code> , 那么该集合只能存放到 <code>user</code> 这个级别, 不能存放 <code>guest</code> 这个级别</p>
<p>接着就是搜索可达角色, 存放在这个集合中<code>Map&lt;String, Set&lt;GrantedAuthority&gt;&gt; rolesReachableInOneOrMoreStepsMap</code></p>
<p>可达搜索的关键在于 <code>!this.rolesReachableInOneStepMap.containsKey(lowerRole.getAuthority())</code>判断. 如果该返回为 <code>true</code>, 则直接 <code>continue</code>, 返回 <code>false</code> 的话直接到<code>this.rolesReachableInOneOrMoreStepsMap.put(roleName, visitedRolesSet);</code></p>
<blockquote>
<p>上面的整个过程也非常简单, 如果 <code>ROLE_ADMIN</code> 的成员有一个 <code>ROLE_USER</code>, 然后在<code>rolesReachableInOneStepMap</code>分组中判断下 <code>ROLE_USER</code> 是否为组长, 如果是组长, 则意味着 <code>ROLE_ADMIN</code> 是<code>ROLE_USER</code> 的组长, 所以 <code>ROLE_USER</code> 的成员都是 <code>ROLE_ADMIN</code> 的</p>
</blockquote>
<blockquote>
<p>小白: “有问题, 看角色继承的源码”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;GrantedAuthority&gt; <span class="title function_">getReachableGrantedAuthorities</span><span class="params">(</span></span><br><span class="line"><span class="params">      Collection&lt;? extends GrantedAuthority&gt; authorities)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小白: “看这个函数里面不是返回了角色和权限吗？但是这个函数其实他只要角色就行了，这样把权限传进去不会有问题吗？”</p>
<p>小黑: “没有任何的影响”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleHierarchyVoter</span> <span class="keyword">extends</span> <span class="title class_">RoleVoter</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">RoleHierarchy</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">RoleHierarchyVoter</span><span class="params">(RoleHierarchy roleHierarchy)</span> &#123;</span><br><span class="line">      Assert.notNull(roleHierarchy, <span class="string">&quot;RoleHierarchy must not be null&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.roleHierarchy = roleHierarchy;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; extractAuthorities(Authentication authentication) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.roleHierarchy.getReachableGrantedAuthorities(authentication.getAuthorities());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小黑: “看看上面的代码，然后我再写下面这个测试案例。”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">   roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   Collection&lt;GrantedAuthority&gt; authorities = roleHierarchy.getReachableGrantedAuthorities(AuthorityUtils.createAuthorityList(<span class="string">&quot;ROLE_ADMIN&quot;</span>, <span class="string">&quot;readHello&quot;</span>, <span class="string">&quot;writeHello&quot;</span>));</span><br><span class="line">   <span class="keyword">for</span> (GrantedAuthority grantedAuthority : authorities) &#123;</span><br><span class="line">      log.error(grantedAuthority.getAuthority() + <span class="string">&quot;\t&quot;</span>); <span class="comment">// ROLE_USER    ROLE_GUEST writeHello ROLE_ADMIN readHello</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小黑: “下面注释的地方就是本次测试案例的执行结果。所以不管传递角色还是权限，都不会影响到角色继承的结果呈现。”</p>
</blockquote>
<blockquote>
<p>记住, 在以sql配合的动态权限方案中, 角色的继承将会失效, 因为你只需要在数据库中修改对应角色的权限就可以修改权限了, 不过这也是后续的事情, 后面会详细介绍</p>
</blockquote>
<h1 id="授权的方式"><a href="#授权的方式" class="headerlink" title="授权的方式"></a>授权的方式</h1><p>授权的方式有两种</p>
<ol>
<li>基于过滤器(URL)<code>FilterSecurityInterceptor</code></li>
<li>基于AOP(方法)<code>MethodSecurityInterceptor</code></li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118292.png" alt="image-20230111192617929"></p>
<blockquote>
<p>小白: “只有这两种?”</p>
<p>小黑: “是的, 就这两种, 根据颗粒度不同处理不同的资源”</p>
</blockquote>
<h1 id="授权过程源码分析"><a href="#授权过程源码分析" class="headerlink" title="授权过程源码分析"></a>授权过程源码分析</h1><p>这里的源码分析我将会分为两种，也就是上面的两种不同的颗粒度: 根据URL和根据方法。</p>
<p>首先我们会根据URL进行源码分析，然后再根据方法分析。</p>
<p>首先我们需要确定授权过程的核心接口都有哪一些。</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118897.png" alt="image-20230112150906458"></p>
<p>在这里有一个核心的属性需要关注一下。</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118049.png" alt="image-20230112150940641"></p>
<p>这个属性就是一个集合，这跟前面认证是差不多的，认证过程中Manager也是一个集合, 而Provider是集合元素。</p>
<p>从这个属性我们可以看到一个接口，这个就是投票器接口。</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118025.png" alt="image-20230112151306608"></p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132118599.png" alt="image-20230112151523071">这里看这个也非常简单，是吧？</p>
<p>现在就是第3个核心接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigAttribute</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">   String <span class="title function_">getAttribute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里面存放的都是权限或者是权限所需要的表达式。</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119376.png" alt="image-20230112152130836"></p>
<h2 id="源码分析思路"><a href="#源码分析思路" class="headerlink" title="源码分析思路"></a>源码分析思路</h2><p>现在看这三个核心接口你大概也就知道他怎么玩了，说白了就是一个<code>manager集合</code>，然后遍历这个集合，里面集合的元素是投票器，每一个投票器都有一个投票方法和匹配方法，匹配方法通过匹配<code>ConfigAttribute</code>, 来判断使用哪一个投票器</p>
<p>接着投票器调用投票方法，在投票方法中遍历<strong>当前用户的权限</strong>和<strong>目标资源的权限</strong>看看当前用户的权限是否满足访问资源的权限。根据遍历的结果，是否匹配返回三种不同的结果，</p>
<ul>
<li>第1种是允许访问</li>
<li>第2种是缺省</li>
<li>第3种是拒绝</li>
</ul>
<p>对应着接口的三个常量</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119920.png" alt="image-20230112152045460"></p>
<p>紧接着我们就可以根据我们所分析出来的思路进行源码跟踪。</p>
<blockquote>
<p>分析源码一定要带着目的去, 否则分析不出什么东西的</p>
</blockquote>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><p>第1步从根源开始。就是匹配到底是URL还是方法？</p>
<p><code>AbstractSecurityInterceptor</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119721.png" alt="image-20230112152346304"></p>
<blockquote>
<p>此次源码分析大致涉及这几个类</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119664.png" alt="image-20230112162236651"></p>
</blockquote>
<h3 id="从URL开始分析"><a href="#从URL开始分析" class="headerlink" title="从URL开始分析"></a>从URL开始分析</h3><p><code>FilterSecurityInterceptor</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119553.png" alt="image-20230112152441880"></p>
<p>这个类其实很眼熟。</p>
<p>在spring security的过滤器列表中的倒二还是倒三就有一个，上面这个类。</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119855.png" alt="202211130451077"></p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119120.png" alt="202211130452065"></p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119344.png" alt="image-20230112165714261"></p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119960.png" alt="image-20230112170318921"></p>
<p>可以发现这里有三个核心方法, 根据这三个方法可以看到整个源码分析的过程</p>
<p><code>AbstractSecurityInterceptor#beforeInvocation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InterceptorStatusToken <span class="title function_">beforeInvocation</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">   Assert.notNull(object, <span class="string">&quot;Object was null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Security invocation attempted for object &quot;</span> + object.getClass().getName()</span><br><span class="line">            + <span class="string">&quot; but AbstractSecurityInterceptor only configured to support secure objects of type: &quot;</span></span><br><span class="line">            + getSecureObjectClass());</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 获取资源(也就是object)所需的权限(和角色)</span></span><br><span class="line">   Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.obtainSecurityMetadataSource().getAttributes(object);</span><br><span class="line">    <span class="comment">// 资源没有对应的权限, 直接返回 null</span></span><br><span class="line">   <span class="keyword">if</span> (CollectionUtils.isEmpty(attributes)) &#123;</span><br><span class="line">      publishEvent(<span class="keyword">new</span> <span class="title class_">PublicInvocationEvent</span>(object));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// no further work post-invocation</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 没有认证信息, 直接抛出异常</span></span><br><span class="line">   <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">      credentialsNotFound(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractSecurityInterceptor.authenticationNotFound&quot;</span>,</span><br><span class="line">            <span class="string">&quot;An Authentication object was not found in the SecurityContext&quot;</span>), object, attributes);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 从SecurityContextHolder中拿到Authentication</span></span><br><span class="line">   <span class="type">Authentication</span> <span class="variable">authenticated</span> <span class="operator">=</span> authenticateIfRequired();</span><br><span class="line">   <span class="comment">// 准备调用决策器, 后面方法不用分析了</span></span><br><span class="line">   attemptAuthorization(object, attributes, authenticated);</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.logger.debug(LogMessage.format(<span class="string">&quot;Authorized %s with attributes %s&quot;</span>, object, attributes));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.publishAuthorizationSuccess) &#123;</span><br><span class="line">      publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizedEvent</span>(object, attributes, authenticated));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Attempt to run as a different user</span></span><br><span class="line">   <span class="type">Authentication</span> <span class="variable">runAs</span> <span class="operator">=</span> <span class="built_in">this</span>.runAsManager.buildRunAs(authenticated, object, attributes);</span><br><span class="line">   <span class="keyword">if</span> (runAs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">origCtx</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">      <span class="type">SecurityContext</span> <span class="variable">newCtx</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">      newCtx.setAuthentication(runAs);</span><br><span class="line">      SecurityContextHolder.setContext(newCtx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.logger.debug(LogMessage.format(<span class="string">&quot;Switched to RunAs authentication %s&quot;</span>, runAs));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(origCtx, <span class="literal">true</span>, attributes, object);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Did not switch RunAs authentication since RunAsManager returned null&quot;</span>);</span><br><span class="line">   <span class="comment">// 返回成果, 但由于是基于过滤器的方式, 不需要处理后续的两个函数</span></span><br><span class="line">    <span class="comment">// 所以这里返回之后的函数就不需要分析了, 主要分析上面的attemptAuthorization函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(SecurityContextHolder.getContext(), <span class="literal">false</span>, attributes, object);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attemptAuthorization</span><span class="params">(Object object, Collection&lt;ConfigAttribute&gt; attributes,</span></span><br><span class="line"><span class="params">      Authentication authenticated)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 省略一堆代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AffirmativeBased</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span></span><br><span class="line">      <span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 集合遍历投票器</span></span><br><span class="line">   <span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line">       <span class="comment">// 投票, 产生结果</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);</span><br><span class="line">      <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">      <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">         deny++;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 如果没事还好基本上投票通过了, 否则会抛出AccessDeniedException异常</span></span><br><span class="line">   <span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(</span><br><span class="line">            <span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// To get this far, every AccessDecisionVoter abstained</span></span><br><span class="line">   checkAllowIfAllAbstainDecisions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来就是给猪都能编写的代码了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoleVoter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">vote</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (authentication == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ACCESS_DENIED;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ACCESS_ABSTAIN;</span><br><span class="line">   Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = extractAuthorities(authentication);</span><br><span class="line">   <span class="keyword">for</span> (ConfigAttribute attribute : attributes) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.supports(attribute)) &#123;</span><br><span class="line">         result = ACCESS_DENIED;</span><br><span class="line">         <span class="keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">            <span class="keyword">if</span> (attribute.getAttribute().equals(authority.getAuthority())) &#123;</span><br><span class="line">               <span class="keyword">return</span> ACCESS_GRANTED;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>像不像在集合 <code>[1, 2, 3]</code> 和 <code>[3]</code> 中遍历是否有相同的元素代码? </p>
<p>只不过前者是资源所需权限数组, 后者是当前用户所有的权限数组</p>
<p>来, 给个绝杀流程图</p>
<blockquote>
<p>流程图可能有错, 但大体上没什么问题</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119436.png" alt="Spring Security授权源码分析"></p>
<blockquote>
<p>至此基于URL过滤器方式的源码分析基本完毕</p>
</blockquote>
<blockquote>
<p>对了, 源码分析过程在这个项目中进行的</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/springcloud_study_parent/tree/spring_security/dynamic-permission-demo">dynamic-permission-demo</a></p>
<p>数据库表结构也在那里面</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132119779.png" alt="image-20230113023329908"></p>
</blockquote>
<h3 id="从AOP-方法-方式开始分析"><a href="#从AOP-方法-方式开始分析" class="headerlink" title="从AOP(方法)方式开始分析"></a>从AOP(方法)方式开始分析</h3><p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132120776.png" alt="image-20230113025326322"></p>
<p>可以看出是基于Spring AOP实现的拦截功能</p>
<p>拦截后直接断在这里</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132120216.png" alt="image-20230113025434158"></p>
<p>还是熟悉的三个函数</p>
<p>这里我就直接给出流程图吧, 源码给出的太多, 看我写的注释也很累, 直接看流程图快些</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132120125.png" alt="Spring Security授权基于AOP"></p>
<p>基本分析源代码和URL差不多, 只不过在处理权限时存在不同之处, 还有那三个函数的最后一个函数<code>afterInvocation</code>在 AOP 方式中还是有用途的</p>
<p>主要目的就是处理后置注解, 比如 <code>@PostAuthorize</code> <code>@PostFilter</code></p>
<p>方式也非常简单, 根据一个条件, 判断是否是后置处理注解, 然后看 <code>AfterInvocationManager</code> 和 <code>AfterInvocationProvider</code> 这两接口</p>
<p><code>Manager</code>是集合, <code>Provider</code>是集合的元素, 核心方法还是 <code>decide</code> , 只不过 <code>Provider</code> 多了个 <code>findPostInvocationAttribute</code> 函数</p>
<p>该函数的功能也非常简单, 判断前置还是后置注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PostInvocationAttribute <span class="title function_">findPostInvocationAttribute</span><span class="params">(Collection&lt;ConfigAttribute&gt; config)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (ConfigAttribute attribute : config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attribute <span class="keyword">instanceof</span> PostInvocationAttribute) &#123;</span><br><span class="line">         <span class="keyword">return</span> (PostInvocationAttribute) attribute;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对应着还有一个检测是否是前置注解的函数, 不过不在 Provider 中了</p>
<p>在 <code>PreInvocationAuthorizationAdviceVoter</code> 类中, 看类名可以判断出来是处理前置注解的</p>
<blockquote>
<p>不管是不是后置注解, 都会执行一次  <code>PreInvocationAuthorizationAdviceVoter</code>, 只不过在该类的<code>findPostInvocationAttribute</code>函数中判断出来不是前置注解才停下来的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PreInvocationAttribute <span class="title function_">findPreInvocationAttribute</span><span class="params">(Collection&lt;ConfigAttribute&gt; config)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (ConfigAttribute attribute : config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (attribute <span class="keyword">instanceof</span> PreInvocationAttribute) &#123;</span><br><span class="line">         <span class="keyword">return</span> (PreInvocationAttribute) attribute;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132120011.png" alt="image-20230113040614824"></p>
<p>这两接口都继承至<code>ConfigAttribute</code></p>
<p>我前面说的 <code>findPreInvocationAttribute</code> 判断是的前置注解还是后置注解是不对的, 这里判断的其实是权限类型, 到底是前置还是后置</p>
<blockquote>
<p>更多的源码看流程图吧, 打字好累</p>
</blockquote>
<p>对了最后再给出投票器的类族介绍吧</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132120062.png" alt="image-20221130203443286"></p>
<ul>
<li><code>RoleVoter</code>: <code>RoleVoter</code>是根据登录主体的角色进行投票，即判断当前用户是否具备受保护对象所需要的角色。需要注意的是，默认情况下角色需以“<code>ROLE_</code>”开始，否则 <code>supports</code>方法直接返回<code>false</code>，不进行后续的投票操作。</li>
<li><code>RoleHierarchyVoter</code>: <code>RoleHierarchyVoter</code>继承自<code>RoleVoter</code>，投票逻辑和<code>RoleVoter</code>一致，不同的是<code>RoleHierarchyVoter</code>支持角色的继承，它通过<code>RoleHierarchylmpl</code>对象对用户所具有的角色进行解析，获取用户真正“可触达”的角色;而 <code>RoleVoter</code>则直接调用<code>authentication.getAuthorities()</code>方法获取用户的角色。</li>
<li><code>WebExpressionVoter</code>:基于URL地址进行权限控制时的投票器（支持<code>SpEL</code>)。</li>
<li><code>Jsr250Voter</code>:处理<code>JSR-250</code>权限注解的投票器，如<code>@PermitAll</code>、<code>@DenyAll</code>等。</li>
<li><code>AuthenticatedVoter</code>: <code>AuthenticatedVoter</code>用于判断当前用户的认证形式，它有三种取值:<code>IS_AUTHENTICATED_FULLY</code> 、<code>IS_AUTHENTICATED_REMEMBERED</code>以及<code>IS_AUTHENTICATED_ANONYMOUSLY</code>。其中:<code>IS_AUTHENTICATED_FULLY</code> 要求当前用户既不是匿名用户也不是通过<code>RememberMe</code>进行认证 ;<code>IS_AUTHENTICATED_REMEMBERED</code>则在前者的基础上,允许用户通过<code>RememberMe</code>进行认证;<code>IS_AUTHENTICATED_ANONYMOUSLY</code>则允许当前用户通过<code>RememberMe</code>认证，也允许当前用户是匿名用户。</li>
<li><code>AbstractAclVoter</code>:基于<code>ACL</code>进行权限控制时的投票器。这是一个抽象类，没有绑定到具体的<code>ACL</code>系统(关于<code>ACL</code>，后面会做详细介绍)）。</li>
<li><code>AclEntryVoter</code>: <code>AcIEntryVoter</code>继承自<code>AbstractAclVoter</code>，基于<code>Spring Security</code>提供的<code>ACL</code>权限系统的投票器。</li>
<li><code>PreInvocationAuthorizationAdviceVoter</code>: 处理<code>@PreFilter</code>和<code>@PreAuthorize</code>注解的投票器。</li>
</ul>
<blockquote>
<p>投票结果并非最终结果(通过或拒绝),最终结果还要看决策器(<code>AccessDecisionManager</code>)。</p>
</blockquote>
<p>分析完源码我们可以发现有个扩展点, 该扩展点是 <code>SecurityMetadataSource</code> 类</p>
<p><img src="https://gcore.jsdelivr.net/gh/bangiao/blog_images@main/blog/202301132120536.png" alt="image-20230113041039116"></p>
<p>我们知道, 目标资源的权限除了在 Spring Security上配置外, 还可以通过动态权限方式在数据库中配置, 所以上面这个方法明显需要修改, 修改成从数据库获取权限列表</p>
<p>否则将无法从数据库中抓取目标资源的权限集合</p>
<p>不过本篇字数已经 6000了, 太多字各位读者看着也累, 我手也写的好酸, 放在下一篇吧</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对了最后再强调一遍, 角色继承和动态权限有冲突, 如果我们的权限 角色 用户 都从数据库读取的话, 那么角色继承将会失效, 这点需要注意, 都能从数据库中修改了, 何必还搞什么角色继承</p>
<p>紧接着就是 授权的方式, 一个是 基于过滤器, 另一个是基于 AOP 实现, 说白了, 一个是 URL 粗颗粒度, 另一个是方法, 细颗粒度</p>
<p>在 Spring Security中 角色和权限只不过是字符串, 一部分朋友给出的建议是 Authentiation.getAuthorities函数(换句话说就是我们自定义的 User类的 getAuthorities 函数)返回权限, 而我给出的建议是返回角色和权限</p>
<blockquote>
<p>小白: “对了, 还有个问题, 那就是如果你的系统有角色, 那么你要怎么设计表结构呢? 让Spring Secuiry多出关于角色表的操作?”</p>
<p>小黑: “其实只需要在 <code>mybatis</code> 和 自定义的<code>User</code>类 中操作就好, 至于你说的角色表, 就更简单了, 可以直接看我的sql模板, 至于角色对象, 看下面代码”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> <span class="keyword">implements</span> <span class="title class_">GrantedAuthority</span> &#123;</span><br><span class="line">   <span class="comment">// 这是角色名</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 这是权限, 多个权限</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; allowedOperations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获得角色名</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getAuthority</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>授权过程也非常简单, 主要核心就是拿到当前用户所持有的权限和目标资源的权限 做遍历匹配完事, 还记得那个一头猪都能写出的两个 for 循环么? 底层就是这么的直接, 然后根据是否匹配而产生三种状态, 根据这三种状态在决策器中执行只要保证不抛出异常就表示成功, 意味着当前用户有权限访问该资源, 如果抛出异常, 表示当前用户没有权限访问该资源</p>
<blockquote>
<p>待续</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bangiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bangiao.github.io/2023/01/13/02springcloud/Spring Security怎么给你授权/">https://bangiao.github.io/2023/01/13/02springcloud/Spring Security怎么给你授权/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/">过滤器</a><a class="post-meta__tags" href="/tags/springsecurity/">springsecurity</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><a class="post-meta__tags" href="/tags/%E6%9D%83%E9%99%90/">权限</a><a class="post-meta__tags" href="/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/">权限管理</a><a class="post-meta__tags" href="/tags/%E6%8E%88%E6%9D%83/">授权</a><a class="post-meta__tags" href="/tags/%E9%89%B4%E6%9D%83/">鉴权</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/01/13/02springcloud/Spring%20Security%E6%80%8E%E4%B9%88%E7%BB%99%E4%BD%A0%E6%8E%88%E6%9D%83%E7%9A%84(%E4%BA%8C)/"><i class="fa fa-chevron-left">  </i><span>Spring Security怎么给你授权的(二)</span></a></div><div class="next-post pull-right"><a href="/2023/01/10/02springcloud/Spring%20Security%E6%80%8E%E4%B9%88%E8%AE%B0%E4%BD%8F%E6%88%91%E4%BB%AC%E7%9A%84%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/"><span>Spring Security怎么记住我们的登录信息</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2023 By Bangiao</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这是博客github仓库地址：<a target="_blank" rel="noopener" href="https://github.com/bangiao/bangiao.github.io">bangiao.github.io</a>，欢迎访问!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>