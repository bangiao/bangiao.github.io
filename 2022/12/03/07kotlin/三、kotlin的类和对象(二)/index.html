<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="三、kotlin的类和对象(二)"><meta name="keywords" content="componentN,委托,接口,继承,多继承,覆盖方法,覆盖属性,之类初始化顺序,super,this,嵌套类,内部类,数据类,data class,copy函数,解构,元组,抽象类,可见修饰符,internal,局部变量,模块,密封类,seal,委托类,object,关键字,伴生对象,伴生类,扩展,单例,匿名内部类,对象表达式"><meta name="author" content="Bangiao"><meta name="copyright" content="Bangiao"><title>三、kotlin的类和对象(二) | Bangiao's Notebooks</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E2%98%85"><span class="toc-number">1.</span> <span class="toc-text">继承★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95-%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">覆盖方法(重写方法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">覆盖属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E2%96%B2"><span class="toc-number">1.3.</span> <span class="toc-text">子类初始化顺序▲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E4%B8%9C%E8%A5%BF%E2%98%85"><span class="toc-number">1.4.</span> <span class="toc-text">调用父类的东西★</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super-this%E5%92%8C%E6%A0%87%E7%AD%BE%E9%85%8D%E5%90%88%E9%80%89%E6%8B%A9%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">super&#x2F;this和标签配合选择调用父类函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99"><span class="toc-number">1.5.</span> <span class="toc-text">覆盖规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">多继承问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%A1%E5%AD%90%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%9B%B0%E6%83%91"><span class="toc-number">2.1.</span> <span class="toc-text">骡子的多继承困惑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.1.</span> <span class="toc-text">接口实现多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">内部类解决多继承问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB-vs-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">嵌套类 vs 内部类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E8%A7%A3%E5%86%B3%E9%AA%A1%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.3.</span> <span class="toc-text">使用内部类解决骡子问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98%E4%BB%A3%E6%9B%BF%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.4.</span> <span class="toc-text">使用委托代替多继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E2%98%85"><span class="toc-number">3.</span> <span class="toc-text">数据类★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#copy%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">copy函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentN%E4%B8%8E%E8%A7%A3%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">componentN与解构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2-%E8%A7%A3%E6%9E%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">这有什么用呢? 解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">自定义解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">3.2.3.</span> <span class="toc-text">元组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E7%9A%84%E7%BA%A6%E5%AE%9A%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">数据类的约定与使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E2%98%85"><span class="toc-number">4.</span> <span class="toc-text">抽象类★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">可见性修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-internal-%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8C%85%E5%86%85%E8%AE%BF%E9%97%AE-default"><span class="toc-number">5.0.1.</span> <span class="toc-text">为什么要有 internal 而不是包内访问 default?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%E6%B2%A1%E6%9C%89%E6%96%87%E4%BB%B6%E5%86%85%E7%A7%81%E6%9C%89%E7%B1%BB-kotlin%E6%9C%89"><span class="toc-number">5.0.2.</span> <span class="toc-text">java中没有文件内私有类, kotlin有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kotlin%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A6%82%E5%BF%B5"><span class="toc-number">5.0.3.</span> <span class="toc-text">kotlin中没有包作用域概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.0.4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.0.5.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">5.0.6.</span> <span class="toc-text">模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB%E2%98%86"><span class="toc-number">6.</span> <span class="toc-text">密封类☆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98-%E2%98%85"><span class="toc-number">7.</span> <span class="toc-text">内部类和嵌套类的序列化问题 ★</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%A7%94%E6%89%98-%E2%98%85"><span class="toc-number">8.</span> <span class="toc-text">类委托 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.1.</span> <span class="toc-text">是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.2.</span> <span class="toc-text">有什么好处? (使用场景)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-%E5%85%B3%E9%94%AE%E5%AD%97-%E2%98%85"><span class="toc-number">9.</span> <span class="toc-text">object 关键字 ★</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.1.</span> <span class="toc-text">伴生对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.1.</span> <span class="toc-text">伴生对象还可以实现工厂方法模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E2%96%B2"><span class="toc-number">9.1.2.</span> <span class="toc-text">伴生对象实现接口▲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E2%96%B2"><span class="toc-number">9.1.3.</span> <span class="toc-text">伴生对象的扩展▲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B-%E2%96%B2"><span class="toc-number">9.2.</span> <span class="toc-text">单例 ▲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%E6%94%B9%E5%8F%98%E5%86%99%E6%B3%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E2%98%85"><span class="toc-number">9.2.1.</span> <span class="toc-text">对象表达式：改变写法的匿名内部类★</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://imgsa.baidu.com/forum/pic/item/c8179682d158ccbf63dc944d1bd8bc3eb03541a9.jpg"></div><div class="author-info__name text-center">Bangiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/bangiao">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">68</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">634</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的博客</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/4248168662314823">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30690165">CSDN</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/bangiao/">博客园</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/projects">Gitee笔记源码</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bangiao's Notebooks</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章列表</a><a class="site-page" href="/tags">文章标签</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/sources">笔记源码</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">三、kotlin的类和对象(二)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="继承★"><a href="#继承★" class="headerlink" title="继承★"></a>继承★</h2><p><code>kotlin</code> 沿用了 <code>java</code> 的单继承系统, 不允许 <code>c++</code> 的多继承出现, 但允许 <code>kotlin</code> 接口的多实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span>(<span class="keyword">val</span> p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure>

<p>(1) 子类需要继承父类, 子类有责任负责父类字段的初始化</p>
<p><code>class Derived(p: Int) : Base(p)</code></p>
<p>(2) 子类最终都需要调用到父类的构造函数以初始化父类的字段, 子类构造函数如果要调用父类构造函数需要使用上 <code>super</code></p>
<p>(3) 子类构造函数如果要调用到子类的其他构造函数则需要使用到 <code>this</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span>(<span class="keyword">val</span> p: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// name 可以不在这里直接初始化成 &quot;&quot;, 可以选择在 init 代码块中, 前面可知, init 中的代码. 最后会合并到主构造函数中</span></span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">constructor</span>(p: <span class="built_in">Int</span>, name: String): <span class="keyword">this</span>(p) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="type">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 如果子类没有显示的写出主构造函数, 那么次构造函数需要使用 super 主动调用父类的构造函数(主, 次皆可)</span></span><br><span class="line">    <span class="keyword">constructor</span>(p: <span class="built_in">Int</span>) : <span class="keyword">super</span>(p) &#123;&#125;</span><br><span class="line">    <span class="keyword">constructor</span>(p: <span class="built_in">Int</span>, name: String) : <span class="keyword">super</span>(p, name) &#123;&#125;</span><br><span class="line">    <span class="keyword">constructor</span>(a: <span class="built_in">Int</span>, p: <span class="built_in">Int</span>, name: String) : <span class="keyword">this</span>(p, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类如果需要被继承, 这需要显示的写出 <code>open class 类名</code>, 否则默认是 <code>public final 类名</code></p>
</blockquote>
<h3 id="覆盖方法-重写方法"><a href="#覆盖方法-重写方法" class="headerlink" title="覆盖方法(重写方法)"></a>覆盖方法(重写方法)</h3><p>kotlin 所有的类、函数和字段默认都添加上了 <code>final</code> </p>
<p>如果我们需要重写这些功能，可以使用 <code>open</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="type">Shape</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果class Circle是 final 类型(final open Circle), 则函数也是 final类型, 可以不用显示的写出来</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>open</code>只针对 <code>final</code>，添加 <code>open</code> 会删除掉 <code>final</code></p>
</blockquote>
<h3 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h3><blockquote>
<p>子类与父类有相同的属性名称</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> vertexCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="type">Shape</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> vertexCount: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在字段上: (字段可见性默认是 <code>private</code>)</p>
<p>① 使用 <code>val</code> 只生成 <code>public final get</code></p>
<p>② 使用 <code>var</code> 生成 <code>public final get/set</code> </p>
<p>如果字段加上 <code>open</code> , 影响的是 <code>get/set</code> 函数的 <code>final</code> , 会直接消失</p>
<p>(2) 在父子类间, 子类可以用 <code>var</code> 覆盖父类 <code>val</code> 的同名属性</p>
<ul>
<li>为什么?</li>
</ul>
<p>父类 <code>val</code> 属性只有 <code>getter</code> 方法, 子类使用 <code>var</code> 属性后, 将会生成 <code>getter/setter 方法</code>, 没有任何问题</p>
<p>如果 父类是 <code>var</code> 那么有 <code>getter/setter 方法</code>, 此时 子类使用上 <code>val</code> , 只能有 <code>getter</code> , 可是父类的 <code>setter</code> 子类仍然可以调用, 这不行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">constructor</span>(<span class="keyword">open</span> <span class="keyword">val</span> nickName: String) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(_nickName: String) : Person(_nickName) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> nickName: String = _nickName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类初始化顺序▲"><a href="#子类初始化顺序▲" class="headerlink" title="子类初始化顺序▲"></a>子类初始化顺序▲</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Base</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">   <span class="keyword">init</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;2. 父类 init 代码块&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">open</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> = <span class="keyword">this</span>.name.length.also &#123; println(<span class="string">&quot;3. 父类构造函数执行 size 对象初始化&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(name: String, <span class="keyword">val</span> lastName: String) :</span><br><span class="line">   Base(name.capitalize().also &#123; println(<span class="string">&quot;1. Derived的构造函数的初始化代码块 执行初始化&quot;</span>) &#125;) &#123;</span><br><span class="line">   <span class="keyword">init</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;4. Derived 的init代码块执行&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> =</span><br><span class="line">      (<span class="keyword">super</span>.size + lastName.length).also &#123; println(<span class="string">&quot;5. 初始化  Derived 的 size 字段&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> derived = Derived(<span class="string">&quot;zhazha&quot;</span>, <span class="string">&quot;xixi&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体顺序是: </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Derived的构造函数的初始化代码块 执行初始化</span><br><span class="line">2. 父类 init 代码块</span><br><span class="line">3. 父类构造函数执行 size 对象初始化</span><br><span class="line">4. Derived 的init代码块执行</span><br><span class="line">5. 初始化  Derived 的 size 字段</span><br></pre></td></tr></table></figure>

<h3 id="调用父类的东西★"><a href="#调用父类的东西★" class="headerlink" title="调用父类的东西★"></a>调用父类的东西★</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;Drawing a rectangle&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> borderColor: String <span class="keyword">get</span>() = <span class="string">&quot;black&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FillRectangle</span> : <span class="type">Rectangle</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="comment">// super 调用父类的函数</span></span><br><span class="line">        <span class="keyword">super</span>.draw()</span><br><span class="line">        println(<span class="string">&quot;Filling the rectangle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 调用父类的属性, 这里调用了 getBorderColor() 函数</span></span><br><span class="line">    <span class="keyword">val</span> fillColor: String <span class="keyword">get</span>() = <span class="keyword">this</span>.borderColor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="super-this和标签配合选择调用父类函数"><a href="#super-this和标签配合选择调用父类函数" class="headerlink" title="super/this和标签配合选择调用父类函数"></a><code>super/this</code>和标签配合选择调用父类函数</h4><p>调用父类的属性或者方法一般使用 <code>super</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">   <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;Drawing a rectangle&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">val</span> borderColor: String <span class="keyword">get</span>() = <span class="string">&quot;black&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FilledRectangle</span> : <span class="type">Rectangle</span>() &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// super 调用父类的函数</span></span><br><span class="line">      <span class="keyword">super</span>.draw()</span><br><span class="line">      println(<span class="string">&quot;Filling the rectangle&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 调用父类的属性, 这里调用了 getBorderColor() 函数</span></span><br><span class="line">   <span class="keyword">val</span> fillColor: String <span class="keyword">get</span>() = <span class="keyword">this</span>.borderColor</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Filler</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">()</span></span> &#123;</span><br><span class="line">         println(<span class="string">&quot;Filling &quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">         println(<span class="string">&quot;Filler draw...&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">drawFill</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="comment">// idea 智能提示对这个支持不太好, 需要用户手写完毕, 提示都没有</span></span><br><span class="line">         <span class="comment">// 只能支持内部类访问外部类的方法, 访问 FilledRectangle 类的父类方法 draw</span></span><br><span class="line">         <span class="symbol">super@</span>FilledRectangle.draw()</span><br><span class="line">         fill()</span><br><span class="line">         println(<span class="string">&quot;fillColor = <span class="variable">$fillColor</span>&quot;</span>)</span><br><span class="line">         <span class="comment">// 调用 Filler 的 draw</span></span><br><span class="line">         draw()</span><br><span class="line">         <span class="comment">// 调用 FilledRectangle 的  draw</span></span><br><span class="line">         <span class="keyword">this</span><span class="symbol">@FilledRectangle</span>.draw()</span><br><span class="line">         println(<span class="string">&quot;class rectangle color: <span class="subst">$&#123;super@FilledRectangle.borderColor&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> rectangle = FilledRectangle()</span><br><span class="line">   rectangle.draw()</span><br><span class="line">   rectangle.Filler().drawFill()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① <code>super@AAA类.BB方法()</code>,  表示调用 <code>AAA类的父类</code>的<code>BB方法</code></p>
<p>② <code>this@AAA类.BB方法()</code>, 表示调用 <code>AAA类</code>的<code>BB方法</code></p>
<h3 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">   <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;rectangle  draw...&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Polygon</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>() : Rectangle(), Polygon &#123;</span><br><span class="line">   <span class="comment">// 虽然两个父类都存在 draw 方法, 但是其中一个是接口, 一个已经存在函数体, 所以直接调用的实现了的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> square = Square()</span><br><span class="line">   square.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是两个类的话, 就需要直接重写一个自己想要的方法了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Rectangle draw...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Polygon</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Polygon draw...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="type">Rectangle</span>, <span class="type">Polygon</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Rectangle&gt;.draw()</span><br><span class="line">        <span class="keyword">super</span>&lt;Polygon&gt;.draw()</span><br><span class="line">        println(<span class="string">&quot;Square draw...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> square = Square()</span><br><span class="line">    square.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个接口的默认函数重名, 子类就需要手动重写该方法, 定义自己的 <code>draw 函数</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>&lt;Rectangle&gt;.draw()</span><br><span class="line"><span class="keyword">super</span>&lt;Polygon&gt;.draw()</span><br><span class="line">println(<span class="string">&quot;Square draw...&quot;</span>)</span><br></pre></td></tr></table></figure>





<h2 id="多继承问题"><a href="#多继承问题" class="headerlink" title="多继承问题"></a>多继承问题</h2><p>多继承会导致继承关系语义上的混乱, 比如下面的情况</p>
<h3 id="骡子的多继承困惑"><a href="#骡子的多继承困惑" class="headerlink" title="骡子的多继承困惑"></a>骡子的多继承困惑</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Horse</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Donkey</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span> : <span class="type">Horse</span>, <span class="type">Donkey</span> &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们在定义 <code>Mule 类</code>的时候需要纠结, 到底实现 <code>马 的 run</code> 还是 实现 <code>驴 的 run</code> 函数, 这两个函数存在区别</p>
<p>马一般跑的比较快, 驴 耐力特别好</p>
<p>到底选择 马 还是 驴 的能力呢?</p>
<p>这就是 <code>棱形继承问题</code> 也叫 <code>钻石问题</code> , 继承关系将在语义上产生歧义: <code>骡子到底继承了马的run功能还是驴的run功能呢?</code></p>
<h4 id="接口实现多继承"><a href="#接口实现多继承" class="headerlink" title="接口实现多继承"></a>接口实现多继承</h4><blockquote>
<p>在前面已经有过这个案例了</p>
</blockquote>
<p><code>kotlin</code>中的类可以实现多个接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyer</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">&quot;flying animals&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">val</span> name: String</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">&quot;flying animals&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="type">Flyer</span>, <span class="type">Animal</span> &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;I can fly&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> name: String</span><br><span class="line">      <span class="keyword">get</span>() = <span class="string">&quot;燕子&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;I can eat&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">      println(<span class="keyword">super</span>&lt;Animal&gt;.kind())</span><br><span class="line">      println(<span class="keyword">super</span>&lt;Flyer&gt;.kind())</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;my name is <span class="subst">$&#123;this.name&#125;</span>&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果存在多个同名的默认方法, 需要通过 <code>super&lt;T&gt;</code> 这种方式指定调用</p>
<p>实现接口的属性和方法都必须加上 <code>override</code> 关键字, 且不能省略(和 <code>java</code> 不同)</p>
<p>上面的源码还可以这么搞:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">override</span> <span class="keyword">val</span> name: String) : Flyer, Animal &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>将接口的属性放到子类的主构造函数中重写</p>
<p>其实接口中的属性只有 <code>setter/getter 函数</code>, 没有 <code>field 字段</code></p>
<p>在 <code>Bird</code> 中实现的 <code>name</code> 可以有 <code>field</code> 字段</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="title">implements</span> <span class="title">Flyer</span>, <span class="type">Animal</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当然我们还可以让 <code>name 字</code>段在 <code>Bird</code> 中不存在, 只保留 <code>getter/setter</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="type">Flyer</span>, <span class="type">Animal</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> name: String</span><br><span class="line">      <span class="keyword">get</span>() = <span class="string">&quot;xiaobai&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11d158dd2985439aaf46f32bec42104a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>同样的, 将上面的 <code>Fly</code> 和 <code>Animal</code> 代替成 <code>Horse</code> 和 <code>Donkey</code> 还是会存在 到底 实现哪个 <code>run</code> 的问题</p>
<h4 id="内部类解决多继承问题"><a href="#内部类解决多继承问题" class="headerlink" title="内部类解决多继承问题"></a>内部类解决多继承问题</h4><p>我们可以使用内部类模拟实现多继承的方案, 我们知道, 类内可以定义多个内部类, 每个内部类都可以继承自各个不同的父类, 且每个内部类都是独立存在的, 使用这种特性解决多继承问题</p>
<p>在 <code>java</code> 中只要在一个类内写上另一个类, 我们都可以认为另一个类是内部类</p>
<p>但是在 <code>kotlin</code> 中, 就不一样了</p>
<p>直接在 <code>kotlin</code> 类中写上另一个<code>类A</code>, 此时类 <code>A</code> 却是 外部类的 <code>嵌套类</code>, 而不是<code>内部类</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/254a13fcd1024641b4eae6eec04a04a5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <code>name</code> 无法被识别, 说明<code>ErrorInnerKotlin</code> 类不持有外部类的 <code>this</code>, 否则不会报错</p>
<blockquote>
<p>使用嵌套类方便序列化和反序列化, 不过这是后话</p>
</blockquote>
<p><code>kotlin</code>中的内部类是这样的:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b943e083122a4e4f82576347bb2a64fa~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>需要使用 <code>inner</code> 修饰内部类</p>
<h5 id="嵌套类-vs-内部类"><a href="#嵌套类-vs-内部类" class="headerlink" title="嵌套类 vs 内部类"></a>嵌套类 vs 内部类</h5><p>在 <code>java</code> 中如果需要实现一个<code>嵌套类</code>需要配合 <code>static</code> 关键字, 而 <code>kotlin</code> 则相反, 默认是<code>嵌套类</code>, 需要加上 <code>inner</code> 才能变成<code>内部类</code></p>
<p><code>嵌套类和内部类的区别</code>在于: 是否持有<code>外部类</code>的 <code>this</code> 引用, 就如前面的代码显示, 如果不持有 <code>外部类</code>的 <code>this</code>, <code>name</code>无法被访问, 而<code>嵌套类</code>就是这样的…</p>
<h4 id="使用内部类解决骡子问题"><a href="#使用内部类解决骡子问题" class="headerlink" title="使用内部类解决骡子问题"></a>使用内部类解决骡子问题</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Horse</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Donkey</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">		HorseC().run()</span><br><span class="line">		print(<span class="string">&quot; and &quot;</span>)</span><br><span class="line">		DonkeyC().run()</span><br><span class="line">		println()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">HorseC</span> : <span class="type">Horse</span> &#123;</span><br><span class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">			print(<span class="string">&quot;I can run fast&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">DonkeyC</span> : <span class="type">Donkey</span> &#123;</span><br><span class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">			print(<span class="string">&quot;I can run long time&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个案例改造后我们发现: </p>
<ol>
<li>可以在一个类内部定义多个内部类, 每个内部类实例都有自己独立的状态, 它们与外部对象的信息相互独立</li>
<li>通过内部类<code>HorseC</code> 和 <code>DonkeyC</code>分别继承<code>Horse</code>和<code>Donkey</code>这两个外部类, 我们就可以在<code>Mule</code>类中定义他们的实例对象, 从而获得他们两者不同的状态和行为(那为什么不直接定义两个属性到 <code>Mule</code> 中??? 因为是接口么?)</li>
<li>我们可以使用 <code>private</code> 修饰内部的 <code>HorseC</code> 和 <code>DonkeyC</code> 让外部类不至于直接访问到内部类. 提供了更好的封装性</li>
</ol>
<blockquote>
<p>因此在某些场景下, 内部类是解决多继承问题非常好的思路</p>
<p>这种方式我们可以在很多框架的源码中发现</p>
</blockquote>
<h4 id="使用委托代替多继承"><a href="#使用委托代替多继承" class="headerlink" title="使用委托代替多继承"></a>使用委托代替多继承</h4><p>委托在 <code>kotlin</code> 用的还是比较多的, 比如: 委托的观察者, 可以观察属性的修改和读取行为</p>
<p>现在来试试 委托如何代替多继承</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CanFly</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CanEat</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Flyer</span> : <span class="type">CanFly</span> &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;I can fly&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span> : <span class="type">CanEat</span> &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;I can eat&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(flyer: Flyer, animal: Animal) : CanFly <span class="keyword">by</span> flyer, CanEat <span class="keyword">by</span> animal &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> flyer = Flyer()</span><br><span class="line">   <span class="keyword">val</span> animal = Animal()</span><br><span class="line">   <span class="keyword">val</span> bird = Bird(flyer, animal)</span><br><span class="line">   bird.fly()</span><br><span class="line">   bird.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种方式和前面接口实现多继承的方式相似, 那有什么有点呢?</p>
<ol>
<li>接口是无状态的, 所以即使它提供了默认方法实现也是很简单的, 不能实现复杂的逻辑, 也不推荐在接口默认方法中实现复杂的逻辑, 我们可以使用委托的方式, 虽然他也是接口委托, 但是它用一个具体的类去实现方法逻辑, 可以拥有更强大的能力</li>
<li>在A类组合 委托BC对象的时候, 不是组合 <code>A</code> 和 <code>BC</code> 对象的方法, 而是 <code>A.method</code> 这种形式, 更加的只管, 虽然背后也是通过委托对象来执行具体的方法逻辑的</li>
</ol>
<h2 id="数据类★"><a href="#数据类★" class="headerlink" title="数据类★"></a>数据类★</h2><p>数据类就跟<code>java</code>在<code>Bean</code>相关类中加上 <code>lombok</code> 注解 <code>@Data</code> 的功能差不多</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String)</span><br></pre></td></tr></table></figure>

<p>反编译成 java : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.weight;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">double</span> var1)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.weight = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.age = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(<span class="meta">@NotNull</span> String var1)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.color = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">(<span class="type">double</span> weight, <span class="type">int</span> age, <span class="meta">@NotNull</span> String color)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="built_in">this</span>.weight = weight;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">      <span class="built_in">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">double</span> <span class="title function_">component1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.weight;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">component2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">component3</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Bird <span class="title function_">copy</span><span class="params">(<span class="type">double</span> weight, <span class="type">int</span> age, <span class="meta">@NotNull</span> String color)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(weight, age, color);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Bird copy$<span class="keyword">default</span>(Bird var0, <span class="type">double</span> var1, <span class="type">int</span> var3, String var4, <span class="type">int</span> var5, Object var6) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var1 = var0.weight;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var3 = var0.age;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">         var4 = var0.color;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var0.copy(var1, var3, var4);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Bird(weight=&quot;</span> + <span class="built_in">this</span>.weight + <span class="string">&quot;, age=&quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot;, color=&quot;</span> + <span class="built_in">this</span>.color + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">var10000</span> <span class="operator">=</span> (Double.hashCode(<span class="built_in">this</span>.weight) * <span class="number">31</span> + Integer.hashCode(<span class="built_in">this</span>.age)) * <span class="number">31</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.color;</span><br><span class="line">      <span class="keyword">return</span> var10000 + (var10001 != <span class="literal">null</span> ? var10001.hashCode() : <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> != var1) &#123;</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Bird) &#123;</span><br><span class="line">            <span class="type">Bird</span> <span class="variable">var2</span> <span class="operator">=</span> (Bird)var1;</span><br><span class="line">            <span class="keyword">if</span> (Double.compare(<span class="built_in">this</span>.weight, var2.weight) == <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.age == var2.age &amp;&amp; Intrinsics.areEqual(<span class="built_in">this</span>.color, var2.color)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这比 <code>javaBean</code> 舒服多了</p>
<blockquote>
<p>很多人会说, 还<code>javaBean</code>??? 为什么不用 <code>lombok</code> 呢? 深有同感, <code>kotlin</code> 的 <code>data class</code> 其实不太方便</p>
</blockquote>
<h3 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h3><p><code>copy</code> 方法的主要作用是: 从已有的数据类对象中拷贝一个新的数据类对象</p>
<blockquote>
<p>需要注意这是<code>浅拷贝</code>, 如果 <code>data class</code> 中有引用对象, 需要注意了</p>
</blockquote>
<blockquote>
<p>既然都 <code>copy</code> 了? 那我为什么不用 <code>MapStruct</code>???</p>
</blockquote>
<h3 id="componentN与解构"><a href="#componentN与解构" class="headerlink" title="componentN与解构"></a><code>componentN</code>与解构</h3><p>说到底, <code>component</code> 就是以 <code>data class</code> 声明的顺序定义的对象, 从 <code>1</code> 开始, 到最高的 <code>5</code></p>
<h4 id="这有什么用呢-解构"><a href="#这有什么用呢-解构" class="headerlink" title="这有什么用呢? 解构"></a>这有什么用呢? 解构</h4><p>如果在 <code>java</code> 我们可能会这样使用一个对象接收一个函数的返回值对象, 然后再分别赋值给各个变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> weight = b1.weight</span><br><span class="line"><span class="keyword">val</span> age = b1.age</span><br><span class="line"><span class="keyword">val</span> color = b1.color</span><br></pre></td></tr></table></figure>



<p>在 <code>kotlin</code> 中:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (weight, age, color) = b1</span><br></pre></td></tr></table></figure>



<p>解构的方式还可以用于下面这样:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> birdInfo = <span class="string">&quot;20.0,1,bule&quot;</span></span><br><span class="line"><span class="keyword">val</span> (weight, age, color) = birdInfo.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;weight = <span class="variable">$weight</span>, age = <span class="variable">$age</span>, color = <span class="variable">$color</span>&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>这种神器的方法就是别的语言常说的解构, 一种通过与编译器达成约定的功能</p>
<h4 id="自定义解构"><a href="#自定义解构" class="headerlink" title="自定义解构"></a>自定义解构</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String) &#123;</span><br><span class="line">   <span class="keyword">var</span> sex = <span class="number">1</span></span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component4</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">this</span>.sex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p><code>kotlin</code>还提供了 元组, 比如 <code>Pair</code>和<code>Triple</code> 其中 <code>Pair</code> 是二元组, <code>Triple</code> 是三元组</p>
<blockquote>
<p>其底层都是 <code>data class</code>, 而且每个元素可以是任意类型</p>
</blockquote>
<h3 id="数据类的约定与使用"><a href="#数据类的约定与使用" class="headerlink" title="数据类的约定与使用"></a>数据类的约定与使用</h3><p>使用数据类必须满足以下条件:</p>
<ol>
<li>数据类必须有一个构造方法, 该方法至少包含一个参数</li>
<li>数据类构造函数的方法的参数必须使用 var&#x2F;val</li>
<li>数据类前面不能有 abstract open sealed 或者 inner 进行修饰</li>
<li>数据类可以实现接口和继承类</li>
</ol>
<p>如果代码写成这样: (显示指定默认值)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span> = <span class="number">0.0</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">var</span> color: String = <span class="string">&quot;red&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>他就会提供一个无参数构造函数</p>
<blockquote>
<p>data class 只使用主构造函数中的字段作为模板生成各种代码, 比如 copy equals 等, <strong>如果属性不在主动构造函数中, 则不会被使用作为生成代码的元素</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 <code>age</code> 不会被用来生成代码</p>
<blockquote>
<p><code>data class</code> 目前还是不太好用, 比较局限, 对于很多框架还有兼容性问题, 我看很多人都没用上, 连我也是</p>
</blockquote>
<h2 id="抽象类★"><a href="#抽象类★" class="headerlink" title="抽象类★"></a>抽象类★</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Polygon</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="type">Polygon</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Rectangle draw...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以用抽象成员函数覆盖非抽象的<code>open</code>成员函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Polygon</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Polygon draw...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="type">Polygon</span>() &#123;</span><br><span class="line">    <span class="comment">// 子类将父类的open方法重写成 abstract</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><p><code>kotlin</code>和 <code>java</code> 的可见性修饰符差不多, 但也有区别:</p>
<ol>
<li><code>kotlin</code>和 <code>java</code> 的默认修饰符不同, <code>java</code> 默认是包(<code>default</code>), 而 <code>kotlin</code> 默认是 <code>public</code></li>
<li><code>kotlin</code>有独特的修饰符 <code>internal</code></li>
<li><code>kotlin</code>可以在一个文件内单独声明方法及产量, 同样支持可见性修饰符</li>
<li><code>Java</code>中除了内部类可以用<code>private</code>修饰以外, 其他类都不允许<code>private</code>修饰, 而 <code>kotlin</code>可以.</li>
<li><code>kotlin</code>和<code>java</code>中的 <code>protected</code> 的访问范围不同, <code>java</code>中是包, 类以及子类可访问, 而 <code>kotlin</code> 只允许类及子类</li>
</ol>
<p><code>kotlin</code> 省掉了 <code>java</code> 每次写个类都需要加上 <code>public</code> 的问题, 虽然每次它都会自动加上</p>
<p><code>java</code> 中 默认类都是 <code>default</code> 包访问范围, <code>kotlin</code>中也有 <code>internal</code> 跟其配对, 但还是有不同, <code>internal</code> 是<code>模块内可见</code></p>
<p>那么什么是模块内可见呢? </p>
<ol>
<li>一个 <code>maven</code> 项目</li>
<li>一个 <code>gradle</code> 项目</li>
<li>一个 <code>eclipse</code> 项目</li>
<li>一个 <code>idea</code> 项目</li>
<li>一组由 <code>Ant</code>任务执行编译的代码</li>
</ol>
<p>这些都被 <code>kotlin</code> 看作的 <code>模块</code></p>
<blockquote>
<p>一个文件可以看作一组编译的文件组成的集合</p>
</blockquote>
<h4 id="为什么要有-internal-而不是包内访问-default"><a href="#为什么要有-internal-而不是包内访问-default" class="headerlink" title="为什么要有 internal 而不是包内访问 default?"></a>为什么要有 <code>internal</code> 而不是包内访问 <code>default</code>?</h4><p><code>java</code> 默认包类存在的问题: </p>
<p>假如有一个包类 <code>String</code>, 包路径是 <code>java.lang</code>, 并被打包成库<code>src.jar</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.String;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* public */</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    内容略</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时我们要在库外部使用 <code>String</code> 类的功能<code>print</code> , 只有两种方式</p>
<ol>
<li>导入 <code>src.jar</code> 库, 然后 copy 库中的<code>String</code> 类的源码, 放在自己的包路径中</li>
<li>导入<code>src.jar</code>, 在我们的项目中创建 <code>java.lang</code>包, 此时我们可以在该包路径中定义类, 并直接使用 <code>String</code></li>
</ol>
<blockquote>
<p>上一次我这么用还是在探讨 <code>jvm</code> 的<code>双亲委派机制</code></p>
</blockquote>
<p>在 <code>kotlin</code> 中 没有选择 <code>java</code> 的包内机制, 而是<code>模块内机制</code>, 只和 <code>该类</code> 一起编译的其他 <code>kotlin</code> 文件可见</p>
<p>而开发工程和第三方类库不属于同一个模块, 此时还要使用该类的话, 只能拷贝源码了</p>
<h4 id="java中没有文件内私有类-kotlin有"><a href="#java中没有文件内私有类-kotlin有" class="headerlink" title="java中没有文件内私有类, kotlin有"></a><code>java</code>中没有文件内私有类, <code>kotlin</code>有</h4><p>Java 中没有文件内私有类(<code>private class</code>) 而 <code>kotlin</code>中有</p>
<p>主要的问题是 <code>java</code> 中一个文件只能有一个大类(<code>public类</code>), 可以有<code>private</code> 的子类</p>
<p>而 <code>kotlin</code> 中, 可以有一个大类, 而大类下面还可以写顶层函数或属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BMWCar</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> bMWEngine: BMWEngine = BMWEngine()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">BMWEngine</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">engineName</span><span class="params">()</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;BMWEngine&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="kotlin中没有包作用域概念"><a href="#kotlin中没有包作用域概念" class="headerlink" title="kotlin中没有包作用域概念"></a><code>kotlin</code>中没有包作用域概念</h4><p>在 <code>kotlin</code>中没有包作用域, 所以 <code>java</code> 的 <code>protected</code> 到了 <code>kotlin</code> 中没有访问包作用域的功能, 或者说没有 <code>internal</code> 的功能(<code>internal</code>是<code>模块作用域</code>)</p>
<p>所以<code>kotlin</code> 的 protected 标记的类在同一个包的其他文件中无法使用</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56755d912dc5443e841e93fe13a01550~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>要指定⼀个类的的主构造函数的可⻅性，使⽤以下语法（注意你需要添加⼀个显式 <code>constructor</code> 关键字）：</p>
<p><code>class C private constructor(a: Int) &#123; …… &#125;</code></p>
<p>这⾥的构造函数是私有的。默认情况下，所有构造函数都是 <code>public</code> ，这实际上等于类可⻅的地⽅它就可⻅</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量, 函数和类不支持可见性修饰符</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>可⻅性修饰符 <code>internal</code> 意味着该成员只在相同模块内可⻅, 而一个模块是编译在一起的一堆<code>kotlin</code>文件, 比如:</p>
<ul>
<li>一个 <code>idea</code> 模块</li>
<li>一个<code>maven</code> 项目</li>
<li>一个 <code>gradle</code> 源集(例外是 <code>test</code> 源集可以访问 <code>main</code> 的 <code>internal</code> 声明)</li>
<li>⼀次 <code>&lt;kotlinc&gt;</code> <code>Ant</code> 任务执⾏所编译的⼀套⽂件</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">Button</span> : <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yell</span><span class="params">()</span></span> = println(<span class="string">&quot;Hey!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">whisper</span><span class="params">()</span></span> = println(<span class="string">&quot;Let&#x27;s go!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Button.<span class="title">giveSpeech</span><span class="params">()</span></span> &#123; <span class="comment">// 错误, 企图把public 类 转成 internal 类</span></span><br><span class="line">    println(<span class="keyword">this</span>::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但 <code>internal</code> 比较尴尬, 翻译成 <code>Java</code> 字节码后被认为是 <code>public</code></p>
</blockquote>
<h2 id="密封类☆"><a href="#密封类☆" class="headerlink" title="密封类☆"></a>密封类☆</h2><p>密封类和枚举类对应, 密封类是尽量罗列出所有的有限子类(类型多), 而枚举类是尽量罗列出所有的对象(就是对象多), 而他比枚举类好的地方在于, 密封类子类的属性 在 数量 和 类型上可以不同</p>
<p>使用关键字 <code>sealed</code> 修饰符作为声明密封类的方法</p>
<blockquote>
<p>所有继承密封类的子类都必须放在同一个文件中</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Const</span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 应用场景</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">      <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">      <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">      NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>密封类可以看成是一个功能强大的枚举类</p>
</blockquote>
<h2 id="内部类和嵌套类的序列化问题-★"><a href="#内部类和嵌套类的序列化问题-★" class="headerlink" title="内部类和嵌套类的序列化问题 ★"></a>内部类和嵌套类的序列化问题 ★</h2><blockquote>
<p>前面说过的: <code>kotlin</code>默认是 <code>嵌套类</code>, 不持有外部类的 <code>this</code>引用, 类似于 <code>static</code>修饰的</p>
<p>内部类: 持有外部 <code>this</code>, 需要使用 <code>inner</code> 声明为内部类</p>
</blockquote>
<p>kotlin 类内部可以有类, 而内外类的关系有两种, 一种叫嵌套类(默认的), 另一种叫内部类(需要使用 inner 修饰符)</p>
<p>kotlin的嵌套类反编译成 java 后显示是 static , 这样的好处在于下面这个案例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span> : <span class="type">Serializable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候如果是 java 代码的话, 实现方式: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Button02</span> <span class="keyword">implements</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ButtonState</span>(<span class="number">20</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ButtonState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ButtonState</span><span class="params">(Integer age, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Button02</span> <span class="variable">button02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button02</span>();</span><br><span class="line">        System.out.println(button02.getCurrentState());</span><br><span class="line">        </span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D://test.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 他会在这里报错 NotSerializableException</span></span><br><span class="line">        outputStream.writeObject(button02.getCurrentState());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中单独的 <code>ButtonState</code> 是可以序列化的, 但此处的 <code>ButtonState</code> 是内部类, 内部类偷偷的藏了个 外部类的 <code>this</code> 对象, 该对象不支持 序列化 , 所以报错了</p>
<p>只要把 <code>ButtonState</code> 改成 <code>static</code> 后就不会报错了</p>
<p><code>static class ButtonState implements State</code></p>
<p>而在 kotlin 中就不会出现这种问题</p>
<p>kotlin写在类内部的类, 默认是 <strong>嵌套类</strong>, 同时也是 <code>static</code> 类, 这样内部不会存放 外部类的 <code>this</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Button01</span> : <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> buttonState: State</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State = ButtonState(<span class="number">12</span>, <span class="string">&quot;haha&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.buttonState = state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ButtonState</span>(_age: <span class="built_in">Int</span>, _name: String) : State &#123;</span><br><span class="line">        <span class="keyword">val</span> age: <span class="built_in">Int</span> = _age</span><br><span class="line">        <span class="keyword">val</span> name: String = _name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> button01 = Button01()</span><br><span class="line">    with(ObjectOutputStream(File(<span class="string">&quot;&quot;&quot;D:\test.txt&quot;&quot;&quot;</span>).outputStream())) &#123;</span><br><span class="line">        writeObject(button01.getCurrentState())</span><br><span class="line">        flush()</span><br><span class="line">        close()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    ObjectOutputStream(File(&quot;&quot;&quot;D:\test.txt&quot;&quot;&quot;).outputStream()).apply &#123;</span></span><br><span class="line"><span class="comment">//        writeObject(button01.getCurrentState())</span></span><br><span class="line"><span class="comment">//        flush()</span></span><br><span class="line"><span class="comment">//        close()</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 kotlin 使用 <code>inner</code> 修饰符定义内部类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">ButtonState02</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/532674b8f7c8405caf6918e1a79c2f8d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="类委托-★"><a href="#类委托-★" class="headerlink" title="类委托 ★"></a>类委托 ★</h2><blockquote>
<p>委托有很多, 这里只讲类委托, 后续再整个讲一遍</p>
</blockquote>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h3><p>一个类借助另一个类的<code>对象</code>实现接口的函数, 说白了就是<code>借鸡生蛋</code></p>
<p>下面是不委托的情况下: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelegateCollectionDemo01</span>&lt;<span class="type">T</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerList = arrayListOf&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = innerList.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = innerList.contains(element)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsAll</span><span class="params">(elements: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span>= innerList.containsAll(elements)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = innerList.isNotEmpty()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; = innerList.iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的委托的情况: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelegateCollectionDemo02</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> innerList: ArrayList&lt;T&gt; = arrayListOf()) : Collection&lt;T&gt;  <span class="keyword">by</span> innerList &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> collection01 = DelegateCollectionDemo01&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> collection02 = DelegateCollectionDemo02&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码: </p>
<p><code>class DelegateCollectionDemo02&lt;T&gt;(private val innerList: ArrayList&lt;T&gt; = arrayListOf()) : Collection&lt;T&gt;  by innerList</code></p>
<p>而它实现的函数都是 <code>Collection</code> 接口的函数, 而不是 <code>innerList</code> 的 <code>ArrayList</code>的函数</p>
<h3 id="有什么好处-使用场景"><a href="#有什么好处-使用场景" class="headerlink" title="有什么好处? (使用场景)"></a>有什么好处? (使用场景)</h3><ol>
<li>源码变少了</li>
<li>类的函数和 接口 <code>Collection</code> 的函数一致, 如果<code>Collection</code> 被更改或者新增了新的函数, <code>DelegateCollection</code> 也不用修改, 代码自动生成的</li>
<li>如果有些函数不想用 <code>innerList</code> 对象的函数, 那么可以 override 重写改函数, 添加自己的方法</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelegateCollectionDemo02</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> innerList: ArrayList&lt;T&gt; = arrayListOf()) : Collection&lt;T&gt;  <span class="keyword">by</span> innerList &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = innerList.isNotEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意: 委托类不能委托接口默认函数, 因为 <code>kotlin</code> 接口默认没有默认函数, 而是使用静态类实现类似效果</p>
</blockquote>
<h2 id="object-关键字-★"><a href="#object-关键字-★" class="headerlink" title="object 关键字 ★"></a><code>object</code> 关键字 ★</h2><blockquote>
<p><code>kotlin</code>中没有 <code>staitc关键字</code>, 它引入了新的方法 <code>object 关键字</code>, 它可以完美的代替 <code>static</code> 的所有场景, 并且添加了很多新的功能</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d262844d33f44710b82f6c988faa8698~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>上面的代码虽然没什么问题, 但是 <code>static</code> 和 普通 方法的代码混在在一起, 比较难以区分, 虽然它有 <code>static</code> 作为标记</p>
<p><code>static</code> 方法是 类 的方法, 而普通方法是对象的方法, 这两有着本质的区别</p>
<p>所以在 <code>kotlin</code>中做了区分</p>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>表示跟随着类对象而出现, 它是属于这个类的Class对象所拥有, 因此它是个单例对象, 伴生对象需要声明在类的内部, 在类被加载时初始化</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prize</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> type: <span class="built_in">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">   <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> TYPE_REDPACK = <span class="number">0</span></span><br><span class="line">      <span class="keyword">val</span> TYPE_COUPON = <span class="number">1</span></span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">isRedpack</span><span class="params">(prize: <span class="type">Prize</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> prize.type == TYPE_REDPACK</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> prize = Prize(<span class="string">&quot;红包&quot;</span>, <span class="number">10</span>, Prize.TYPE_REDPACK)</span><br><span class="line">   println(Prize.isRedpack(prize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到静态的属性和方法都被存储到 <code>companion object</code> 中了, 代码变得更加的清晰</p>
<p>并且我们在调用 <code>companion object</code> 内的 <code>isRedpack</code>方法也非常的方便<code>Prize.isRedpack(prize)</code>, 不需要<code>Prize.Companion.isRedpack(prize)</code></p>
<h4 id="伴生对象还可以实现工厂方法模式"><a href="#伴生对象还可以实现工厂方法模式" class="headerlink" title="伴生对象还可以实现工厂方法模式"></a>伴生对象还可以实现工厂方法模式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prize</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> count: <span class="built_in">Int</span>, <span class="keyword">val</span> type: <span class="built_in">Int</span>) &#123;</span><br><span class="line">   <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> TYPE_COMMON = <span class="number">1</span></span><br><span class="line">      <span class="keyword">val</span> TYPE_REDPACK = <span class="number">2</span></span><br><span class="line">      <span class="keyword">val</span> TYPE_COUPON = <span class="number">3</span></span><br><span class="line">      <span class="keyword">val</span> defaultCommonPrize = Prize(<span class="string">&quot;ptjp&quot;</span>, <span class="number">19</span>, Prize.TYPE_COMMON)</span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">newRedpackPrize</span><span class="params">(name: <span class="type">String</span>, count: <span class="type">Int</span>)</span></span> = Prize(name, count, Prize.TYPE_REDPACK)</span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">newCouponPrize</span><span class="params">(name: <span class="type">String</span>, count: <span class="type">Int</span>)</span></span> = Prize(name, count, Prize.TYPE_COUPON)</span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">defaultCommonPrize</span><span class="params">()</span></span> = defaultCommonPrize</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> redpackPrize = Prize.newRedpackPrize(<span class="string">&quot;红包&quot;</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="keyword">val</span> couponPrize = Prize.newCouponPrize(<span class="string">&quot;十元代金券&quot;</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="keyword">val</span> commonPrize = Prize.defaultCommonPrize()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="伴生对象实现接口▲"><a href="#伴生对象实现接口▲" class="headerlink" title="伴生对象实现接口▲"></a>伴生对象实现接口▲</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanionObjectDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">writeObject</span><span class="params">(t: <span class="type">T</span>)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">loadObject</span><span class="params">(text: <span class="type">String</span> = ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>)</span></span>.path + <span class="string">&quot;person02.txt&quot;</span>): T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) : Serializable &#123;</span><br><span class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> : ObjectFactory&lt;Person&gt; &#123;</span><br><span class="line"><span class="comment">//            override fun loadObject(text: String): Person = File(text).let &#123; it -&gt;</span></span><br><span class="line"><span class="comment">//                if (!it.exists()) it.createNewFile()</span></span><br><span class="line"><span class="comment">//                ObjectInputStream(it.inputStream()).use &#123;</span></span><br><span class="line"><span class="comment">//                    it.readObject() as? Person ?: throw Exception(&quot;文件加载失败&quot;)</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadObject</span><span class="params">(text: <span class="type">String</span>)</span></span>: Person = File(text).run &#123;</span><br><span class="line">                myExists()</span><br><span class="line">                ObjectInputStream(inputStream()).use &#123;</span><br><span class="line">                    it.readObject() <span class="keyword">as</span>? Person ?: <span class="keyword">throw</span> Exception(<span class="string">&quot;文件加载失败&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> File.<span class="title">myExists</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!exists()) createNewFile()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeObject</span><span class="params">(t: <span class="type">Person</span>)</span></span> = with(File(ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>).path + <span class="string">&quot;person02.txt&quot;</span>)) &#123;</span><br><span class="line">                myExists()</span><br><span class="line">                ObjectOutputStream(outputStream()).use &#123;</span><br><span class="line">                    it.writeObject(t)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            override fun writeObject(t: Person) = File(ClassLoader.getSystemResource(&quot;&quot;).path + &quot;person02.txt&quot;).run &#123;</span></span><br><span class="line"><span class="comment">//                myExists()</span></span><br><span class="line"><span class="comment">//                ObjectOutputStream(outputStream()).use &#123;</span></span><br><span class="line"><span class="comment">//                    it.writeObject(t)</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CompanionObjectDemo02.Person.writeObject(CompanionObjectDemo02.Person(<span class="string">&quot;haha&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> person = CompanionObjectDemo02.Person.loadObject()</span><br><span class="line">    println(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@JvmStatic</code>, 但该注解不能添加到 <code>objects</code> 或者 <code>companion object</code> 之外的地方, ① 如果注解到字段上, 该字段的 <code>get/set</code> 函数变成静态函数; ② 如果修饰到函数上, 函数将变成静态的</p>
</blockquote>
<blockquote>
<p><code>@JvmField</code>, 添加了该注解, ①字段访问修饰符将从 <code>private</code> 变成 <code>public</code>; ② 该注解可以在伴生对象以外的地方使用</p>
</blockquote>
<h4 id="伴生对象的扩展▲"><a href="#伴生对象的扩展▲" class="headerlink" title="伴生对象的扩展▲"></a>伴生对象的扩展▲</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanionObjExtensionDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) : Serializable &#123;</span><br><span class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> File.<span class="title">myExists</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!exists()) createNewFile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> CompanionObjExtensionDemo01.Person.Companion.<span class="title">loadObject</span><span class="params">(path: <span class="type">String</span> = ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>)</span></span>.path + <span class="string">&quot;person03.txt&quot;</span>): CompanionObjExtensionDemo01.Person =</span><br><span class="line">    with(File(ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>).path + <span class="string">&quot;person03.txt&quot;</span>)) &#123;</span><br><span class="line">        myExists()</span><br><span class="line">        ObjectInputStream(inputStream()).use &#123;</span><br><span class="line">            it.readObject() <span class="keyword">as</span>? CompanionObjExtensionDemo01.Person ?: <span class="keyword">throw</span> Exception(<span class="string">&quot;文件加载失败&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> CompanionObjExtensionDemo01.Person.Companion.<span class="title">writeObject</span><span class="params">(t: <span class="type">CompanionObjExtensionDemo01</span>.<span class="type">Person</span>)</span></span> =</span><br><span class="line">    with(File(ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>).path + <span class="string">&quot;person03.txt&quot;</span>)) &#123;</span><br><span class="line">        myExists()</span><br><span class="line">        ObjectOutputStream(outputStream()).use &#123;</span><br><span class="line">            it.writeObject(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = CompanionObjExtensionDemo01.Person(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">    CompanionObjExtensionDemo01.Person.writeObject(person)</span><br><span class="line">    <span class="keyword">val</span> person1 = CompanionObjExtensionDemo01.Person.loadObject()</span><br><span class="line">    println(<span class="string">&quot;person = <span class="subst">$&#123;person.name&#125;</span>, person01 = <span class="subst">$&#123;person1.name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单例-▲"><a href="#单例-▲" class="headerlink" title="单例 ▲"></a>单例 ▲</h3><p>在 java 中实现单例的方法有很多:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而在 kotlin 中由于 <code>object</code>的存在, 我们可以直接用它来实现单例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种一种饿汉模式, 只要类被加载就会直接实例化单例</p>
<p>单例对象还可以继承别的接口或者类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CaseInsensitiveFileComparator : Comparator&lt;File&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(o1: <span class="type">File</span>, o2: <span class="type">File</span>)</span></span>: <span class="built_in">Int</span> = o1.path.compareTo(o2.path, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="对象表达式：改变写法的匿名内部类★"><a href="#对象表达式：改变写法的匿名内部类★" class="headerlink" title="对象表达式：改变写法的匿名内部类★"></a>对象表达式：改变写法的匿名内部类★</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">writeObject</span><span class="params">(t: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadObject</span><span class="params">(text: <span class="type">String</span> = ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>)</span></span>.path + <span class="string">&quot;person02.txt&quot;</span>): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Person02</span>(<span class="keyword">val</span> name: String) : Serializable</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> File.<span class="title">myExists</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!exists()) createNewFile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> obj: ObjectFactory&lt;Person02&gt; = <span class="keyword">object</span> : ObjectFactory&lt;Person02&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeObject</span><span class="params">(t: <span class="type">Person02</span>)</span></span> =</span><br><span class="line">            with(File(ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>).path + <span class="string">&quot;person04.txt&quot;</span>)) &#123;</span><br><span class="line">                myExists()</span><br><span class="line">                ObjectOutputStream(outputStream()).use &#123;</span><br><span class="line">                    it.writeObject(t)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadObject</span><span class="params">(text: <span class="type">String</span>)</span></span>: Person02 =</span><br><span class="line">            with(File(ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>).path + <span class="string">&quot;person04.txt&quot;</span>)) &#123;</span><br><span class="line">                myExists()</span><br><span class="line">                ObjectInputStream(inputStream()).use &#123;</span><br><span class="line">                    it.readObject() <span class="keyword">as</span>? Person02 ?: <span class="keyword">throw</span> Exception(<span class="string">&quot;文件加载失败&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> person02 = Person02(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">    obj.writeObject(person02)</span><br><span class="line">    <span class="keyword">val</span> person021 = obj.loadObject()</span><br><span class="line">    println(<span class="string">&quot;person02 = <span class="subst">$&#123;person02.name&#125;</span>, person021 = <span class="subst">$&#123;person021.name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: </p>
<ol>
<li>匿名内部类不是单例, 每次表达式完成都会产生一个新的对象</li>
<li>匿名内部类可以访问外部函数的变量, 并且访问并没有 <code>final</code> 限制, 可以直接在匿名内部类中修改其值</li>
</ol>
<blockquote>
<p>总结: <code>object</code> 关键字如果 借助 <code>:</code> 修饰表示给 <code>object</code> 加上该类型, 而整体来看就是 new 一个该接口类型的子类对象, 这样我们可以得出结论, <code>object</code> 如果确定了类型, 那功能是定义一个类, 并<code>new</code>出一个<code>对象</code>, 如果修饰类名则默认为定义了个类, 并 <code>new</code> 了个<code>单例</code></p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bangiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bangiao.github.io/2022/12/03/07kotlin/三、kotlin的类和对象(二)/">https://bangiao.github.io/2022/12/03/07kotlin/三、kotlin的类和对象(二)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/componentN/">componentN</a><a class="post-meta__tags" href="/tags/%E5%A7%94%E6%89%98/">委托</a><a class="post-meta__tags" href="/tags/%E6%8E%A5%E5%8F%A3/">接口</a><a class="post-meta__tags" href="/tags/%E7%BB%A7%E6%89%BF/">继承</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BB%A7%E6%89%BF/">多继承</a><a class="post-meta__tags" href="/tags/%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95/">覆盖方法</a><a class="post-meta__tags" href="/tags/%E8%A6%86%E7%9B%96%E5%B1%9E%E6%80%A7/">覆盖属性</a><a class="post-meta__tags" href="/tags/%E4%B9%8B%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/">之类初始化顺序</a><a class="post-meta__tags" href="/tags/super/">super</a><a class="post-meta__tags" href="/tags/this/">this</a><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%A5%97%E7%B1%BB/">嵌套类</a><a class="post-meta__tags" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/">内部类</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB/">数据类</a><a class="post-meta__tags" href="/tags/data-class/">data class</a><a class="post-meta__tags" href="/tags/copy%E5%87%BD%E6%95%B0/">copy函数</a><a class="post-meta__tags" href="/tags/%E8%A7%A3%E6%9E%84/">解构</a><a class="post-meta__tags" href="/tags/%E5%85%83%E7%BB%84/">元组</a><a class="post-meta__tags" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/">抽象类</a><a class="post-meta__tags" href="/tags/%E5%8F%AF%E8%A7%81%E4%BF%AE%E9%A5%B0%E7%AC%A6/">可见修饰符</a><a class="post-meta__tags" href="/tags/internal/">internal</a><a class="post-meta__tags" href="/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/">局部变量</a><a class="post-meta__tags" href="/tags/%E6%A8%A1%E5%9D%97/">模块</a><a class="post-meta__tags" href="/tags/%E5%AF%86%E5%B0%81%E7%B1%BB/">密封类</a><a class="post-meta__tags" href="/tags/seal/">seal</a><a class="post-meta__tags" href="/tags/%E5%A7%94%E6%89%98%E7%B1%BB/">委托类</a><a class="post-meta__tags" href="/tags/object/">object</a><a class="post-meta__tags" href="/tags/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a><a class="post-meta__tags" href="/tags/%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/">伴生对象</a><a class="post-meta__tags" href="/tags/%E4%BC%B4%E7%94%9F%E7%B1%BB/">伴生类</a><a class="post-meta__tags" href="/tags/%E6%89%A9%E5%B1%95/">扩展</a><a class="post-meta__tags" href="/tags/%E5%8D%95%E4%BE%8B/">单例</a><a class="post-meta__tags" href="/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/">匿名内部类</a><a class="post-meta__tags" href="/tags/%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F/">对象表达式</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/12/03/07kotlin/%E4%B8%89%E3%80%81kotlin%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%80)/"><i class="fa fa-chevron-left">  </i><span>三、kotlin的类和对象(一)</span></a></div><div class="next-post pull-right"><a href="/2022/12/03/07kotlin/%E4%BA%8C%E3%80%81kotlin%E7%9A%84%E5%87%BD%E6%95%B0/"><span>二、kotlin的函数</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2022 By Bangiao</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这是博客github仓库地址：<a target="_blank" rel="noopener" href="https://github.com/bangiao/bangiao.github.io">bangiao.github.io</a>，欢迎访问!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>