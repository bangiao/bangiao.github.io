<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="十一、kotlin的协程(二)——冷流flow"><meta name="keywords" content="异步,zip,reduce,协程,冷流,flow,flow取消,超时流取消,流取消检测,让繁忙的协程可以取消,flow创建,中间流操作符,变换运算符,限长操作符,末端流操作符,flow有序,flow上下文,collect,emit,flowOn,buffer缓冲,处理最新的值,组合多个流,combine,展平flow,flatMapConcat,flatMapMerge,flatMapLatest,流异常,捕获任何异常,流异常的透明性,声明式异常捕获,完成流,命令式,声明式,launchIn,让繁忙的流可取消"><meta name="author" content="Bangiao"><meta name="copyright" content="Bangiao"><title>十一、kotlin的协程(二)——冷流flow | Bangiao's Notebooks</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E6%AD%A5%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">协程的异步流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%BC%82%E6%AD%A5%E6%B5%81"><span class="toc-number">1.1.</span> <span class="toc-text">为什么要有异步流?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flow-%E6%98%AF%E5%86%B7%E6%B5%81%EF%BC%88%E9%9C%80%E8%A6%81%E5%90%AF%E5%8A%A8%E5%BC%80%E5%85%B3collect%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">flow 是冷流（需要启动开关collect函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flow-%E5%8F%96%E6%B6%88"><span class="toc-number">1.3.</span> <span class="toc-text">flow 取消</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E6%B5%81%E5%8F%96%E6%B6%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">超时流取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%8F%96%E6%B6%88%E6%A3%80%E6%B5%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">流取消检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E7%B9%81%E5%BF%99%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%8F%96%E6%B6%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">让繁忙的协程可以取消</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flow-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">flow 的创建方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">中间流操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%B1%BB%E4%BC%BCMap-Filter"><span class="toc-number">1.5.1.</span> <span class="toc-text">变换运算符(类似Map + Filter)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E2%BB%93%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text">限⻓操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AB%E7%AB%AF%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">末端流操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-number">1.6.1.</span> <span class="toc-text">reduce</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flow%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84"><span class="toc-number">1.7.</span> <span class="toc-text">Flow是有序的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flow%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.8.</span> <span class="toc-text">Flow上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flow-%E7%9A%84-collect-%E5%92%8C-emit-%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.9.</span> <span class="toc-text">flow 的 collect 和 emit 必须在同一个协程上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flowOn%E4%BF%9D%E8%AF%81%E5%8D%8F%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.9.1.</span> <span class="toc-text">flowOn保证协程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer%E7%BC%93%E5%86%B2"><span class="toc-number">1.9.2.</span> <span class="toc-text">buffer缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87%E4%B8%AD%E9%97%B4%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.3.</span> <span class="toc-text">跳过中间比较耗时的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%80%E6%96%B0%E7%9A%84%E5%80%BC"><span class="toc-number">1.10.</span> <span class="toc-text">处理最新的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E6%B5%81"><span class="toc-number">1.11.</span> <span class="toc-text">组合多个流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Zip"><span class="toc-number">1.11.1.</span> <span class="toc-text">Zip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combine"><span class="toc-number">1.11.2.</span> <span class="toc-text">Combine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E5%B9%B3Flow"><span class="toc-number">1.12.</span> <span class="toc-text">展平Flow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMapConcat"><span class="toc-number">1.12.1.</span> <span class="toc-text">flatMapConcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMapMerge-%E5%B9%B6%E5%8F%91%E7%BB%84%E5%90%88%E6%B5%81"><span class="toc-number">1.12.2.</span> <span class="toc-text">flatMapMerge 并发组合流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMapLatest"><span class="toc-number">1.12.3.</span> <span class="toc-text">flatMapLatest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%BC%82%E5%B8%B8"><span class="toc-number">1.13.</span> <span class="toc-text">流异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#collect-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8-try-%E5%92%8C-catch"><span class="toc-number">1.13.1.</span> <span class="toc-text">collect 函数使用 try 和 catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E4%BB%BB%E4%BD%95%E5%BC%82%E5%B8%B8"><span class="toc-number">1.13.2.</span> <span class="toc-text">捕获任何异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%BC%82%E5%B8%B8%E7%9A%84%E9%80%8F%E6%98%8E%E6%80%A7"><span class="toc-number">1.14.</span> <span class="toc-text">流异常的透明性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E6%8D%95%E8%8E%B7"><span class="toc-number">1.14.1.</span> <span class="toc-text">透明捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="toc-number">1.14.2.</span> <span class="toc-text">声明式的异常捕获</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E6%B5%81-%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="toc-number">1.15.</span> <span class="toc-text">完成流(命令式和声明式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8F"><span class="toc-number">1.15.1.</span> <span class="toc-text">命令式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="toc-number">1.15.2.</span> <span class="toc-text">声明式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9Aflow%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%B8%8A%E8%BF%90%E8%A1%8C-launchIn"><span class="toc-number">1.16.</span> <span class="toc-text">指定flow在给定的协程上运行: launchIn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%8F%96%E6%B6%88%E6%A3%80%E6%B5%8B-1"><span class="toc-number">1.17.</span> <span class="toc-text">流取消检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E7%B9%81%E5%BF%99%E7%9A%84%E6%B5%81%E5%8F%AF%E5%8F%96%E6%B6%88"><span class="toc-number">1.17.1.</span> <span class="toc-text">让繁忙的流可取消</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://imgsa.baidu.com/forum/pic/item/c8179682d158ccbf63dc944d1bd8bc3eb03541a9.jpg"></div><div class="author-info__name text-center">Bangiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/bangiao">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">606</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的博客</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/4248168662314823">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30690165">CSDN</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/bangiao/">博客园</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/projects">Gitee笔记源码</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bangiao's Notebooks</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章列表</a><a class="site-page" href="/tags">文章标签</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/sources">笔记源码</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">十一、kotlin的协程(二)——冷流flow</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="协程的异步流"><a href="#协程的异步流" class="headerlink" title="协程的异步流"></a>协程的异步流</h1><h2 id="为什么要有异步流"><a href="#为什么要有异步流" class="headerlink" title="为什么要有异步流?"></a>为什么要有异步流?</h2><p>挂起函数可以异步返回单个值, 但如果需要<strong>返回多个值</strong>怎么办? 此时便可以使用异步流</p>
<p>以前没有异步流的情况下, 我们使用传统方式将会是下面这样:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">val</span> list = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>)</span><br><span class="line">      list.add(i)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = simple().forEach&#123; value -&gt; println(value) &#125;</span><br></pre></td></tr></table></figure>

<p>随着我们不断学习, 发现还有一种比较好用的方式达到异步返回的功能: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>)</span><br><span class="line">      yield(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    simple().forEach &#123; i -&gt; log(<span class="string">&quot;<span class="variable">$i</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前面说过了, <code>Sequence</code> 的好处非常明显, 不会产生额外的临时集合, 也不会需要等待其他元素再执行下一步骤的函数</p>
</blockquote>
<p>对比下两种方式你会发现, <code>List</code>的方式是等半天一下子同时(几乎)打印, 而 <code>Sequence</code> 的方式是一个一个一个的打印出来</p>
<blockquote>
<p>这就涉及集合的两种操作方式了, 一种是一个集合的元素同时完成某个函数比如: <code>filter</code> 函数的过滤效果, 然后过滤后的元素当成一个整体再给新的函数 比如: <code>map</code> 函数操作, 这是一种集合类型的操作</p>
<p>第二种是每个集合的元素独立的, 元素不等待整个集合都执行完 <code>filter</code> 函数, 而是 自己 做完 <code>filter</code> 和 <code>map</code> 最后 <code>forEach</code> 打印出去, 不等待其它元素</p>
</blockquote>
<p>现在我们学习了 协程, 发现上面这段代码的 <code>TimeUnit.MILLISECONDS.sleep(200)</code> 其实是阻塞了主线程, 这是不对的, 如果运行 这段代码的线程是 <code>UI</code> 线程呢? 此时 <code>UI</code> 将会在执行 <code>sleep</code> 而阻塞, 用户将会看到<code>app</code>卡顿, 所以我们需要改造, 借助协程改造</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    simple().collect &#123; value -&gt; log(<span class="string">&quot;<span class="variable">$value</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的好处在于, 遇到类似于 <code>delay</code> 这种操作时, 主线程不会阻塞, 而是交给后台线程执行</p>
<p>源码: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(<span class="meta">@BuilderInference</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span>: Flow&lt;T&gt; = SafeFlow(block)</span><br></pre></td></tr></table></figure>

<p>会发现参数<code>suspend</code>, 所以我们可以不需要添加额外的<code>suspend</code></p>
<p>而 <code>flow</code> 使用 <code>emit</code> 添加值, 使用 <code>collect</code> 收集值</p>
<h2 id="flow-是冷流（需要启动开关collect函数）"><a href="#flow-是冷流（需要启动开关collect函数）" class="headerlink" title="flow 是冷流（需要启动开关collect函数）"></a>flow 是冷流（需要启动开关collect函数）</h2><p>它跟 <code>sequence</code> 一样, 只有在调用 <code>collect</code>(末端操作) 时才会执行</p>
<blockquote>
<p>这和 <code>JavaScript</code> 的 <code>generator</code> 一个德行，<code>yield</code>函数不会被执行，直到调用了 <code>next</code>函数才会执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let i = <span class="number">1</span></span><br><span class="line">function *generator() &#123;</span><br><span class="line">	<span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">		console.log(`zhazha $&#123;i&#125;`)</span><br><span class="line">		yield i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = generator();</span><br><span class="line"></span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(gen.next().value)</span><br></pre></td></tr></table></figure>

<p>控制台：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhazha 0</span><br><span class="line">0</span><br><span class="line">zhazha 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>而 <code>kotlin flow</code> 在“偷懒”方面的表现和 <code>JavaScript generator</code> 一模一样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generator</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">	repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">		println(<span class="string">&quot;repeat <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">		emit(it)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">	<span class="keyword">val</span> gen = generator()</span><br><span class="line">	<span class="keyword">val</span> take = gen.take(<span class="number">3</span>)</span><br><span class="line">	take.collect &#123;</span><br><span class="line">		println(it)</span><br><span class="line">	&#125;</span><br><span class="line">	take.collect &#123;</span><br><span class="line">		println(it)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">repeat 0</span><br><span class="line">0</span><br><span class="line">repeat 1</span><br><span class="line">1</span><br><span class="line">repeat 2</span><br><span class="line">2</span><br><span class="line">repeat 0</span><br><span class="line">0</span><br><span class="line">repeat 1</span><br><span class="line">1</span><br><span class="line">repeat 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<p>但是在便利方面不及 <code>JavaScript</code>，我还是比较喜欢 <code>next</code></p>
<h2 id="flow-取消"><a href="#flow-取消" class="headerlink" title="flow 取消"></a>flow 取消</h2><h3 id="超时流取消"><a href="#超时流取消" class="headerlink" title="超时流取消"></a>超时流取消</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      log(<span class="string">&quot;emit <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   withTimeout(<span class="number">2500</span>) &#123;</span><br><span class="line">      simple().collect &#123; value -&gt; log(<span class="string">&quot;<span class="variable">$value</span>&quot;</span>) &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流取消检测"><a href="#流取消检测" class="headerlink" title="流取消检测"></a>流取消检测</h3><p><code>flow</code> 对每个元素的 <code>emit</code> 都有 <code>ensureActive</code> 检测, 好做取消, 这意味着我们的 <code>flow</code> 中的循环是可以取消的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">      log(<span class="string">&quot;emit <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   foo().collect &#123; value -&gt;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="number">3</span>) &#123;</span><br><span class="line">         cancel()</span><br><span class="line">      &#125;</span><br><span class="line">      log(<span class="string">&quot;main <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[main] emit <span class="number">1</span></span><br><span class="line">[main] main <span class="number">1</span></span><br><span class="line">[main] emit <span class="number">2</span></span><br><span class="line">[main] main <span class="number">2</span></span><br><span class="line">[main] emit <span class="number">3</span></span><br><span class="line">[main] main <span class="number">3</span></span><br><span class="line">[main] emit <span class="number">4</span></span><br><span class="line">Exception <span class="keyword">in</span> thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine&#123;Cancelled&#125;@<span class="number">3712</span>b94</span><br></pre></td></tr></table></figure>

<p>我们在 <code>main</code> 函数中取消了 <code>flow</code> , 所以上面控制台打印最后到 <code>emit 4</code> 结束</p>
<p>但为了提高性能, 有些方式申请的 <code>flow</code> 并没有取消检测, 比如 <code>range.asFLow</code>,</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就下面这种方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple02</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.20</span>).asFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   simple02().collect &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">3</span> == it) &#123;</span><br><span class="line">         cancel()</span><br><span class="line">      &#125;</span><br><span class="line">      log(it)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[main] <span class="number">1</span></span><br><span class="line">[main] <span class="number">2</span></span><br><span class="line">[main] <span class="number">3</span></span><br><span class="line">[main] <span class="number">4</span></span><br><span class="line">[main] ... 省略</span><br><span class="line">[main] <span class="number">20</span></span><br><span class="line">Exception <span class="keyword">in</span> thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine&#123;Cancelled&#125;@<span class="number">5</span>d76b067</span><br></pre></td></tr></table></figure>

<h3 id="让繁忙的协程可以取消"><a href="#让繁忙的协程可以取消" class="headerlink" title="让繁忙的协程可以取消"></a>让繁忙的协程可以取消</h3><p>前面说了, 协程是可以取消的 ,需要使用 <code>ensureActive</code> 判断, 所以我们可以考虑主动给他加上取消检测功能</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple03</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.20</span>).asFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    simple03().onEach &#123; currentCoroutineContext().ensureActive() &#125;.collect &#123; value -&gt;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="number">3</span>) &#123;</span><br><span class="line">          cancel()</span><br><span class="line">       &#125;</span><br><span class="line">       log(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样<code>flow</code> 就可以取消了</p>
<p>同时 <code>kotlin</code> 还提供了 <code>cancellable</code> 这种方式添加取消检测:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple03</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.20</span>).asFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   simple03().cancellable().collect &#123; value -&gt;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="number">3</span>) &#123;</span><br><span class="line">         cancel()</span><br><span class="line">      &#125;</span><br><span class="line">      log(value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] <span class="number">1</span></span><br><span class="line">[main] <span class="number">2</span></span><br><span class="line">[main] <span class="number">3</span></span><br><span class="line">Exception <span class="keyword">in</span> thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine&#123;Cancelled&#125;@<span class="number">4</span>e7dc304</span><br></pre></td></tr></table></figure>

<p>上面那两种方式底层原理都一样的</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13416afdf59b460c853509188bfba389~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="flow-的创建方式"><a href="#flow-的创建方式" class="headerlink" title="flow 的创建方式"></a>flow 的创建方式</h2><ol>
<li><code>flow &#123;&#125;</code></li>
<li><code>flowOf</code></li>
<li><code>.asFlow </code></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).asFlow().collect &#123; value -&gt; log(<span class="string">&quot;<span class="variable">$value</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<h2 id="中间流操作符"><a href="#中间流操作符" class="headerlink" title="中间流操作符"></a>中间流操作符</h2><ol>
<li>transform</li>
<li>take</li>
</ol>
<blockquote>
<p>这些操作和 <code>sequence</code> 的方式一样, 有中间操作, 在中间操作时, 流元素不会被操作, 等到末端流操作时才会一起执行掉, 而且是一个元素一个元素单独执行(除特殊函数外)</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayOf(<span class="string">&quot;zhazha&quot;</span>, <span class="string">&quot;heihei&quot;</span>, <span class="string">&quot;xixi&quot;</span>).asFlow().filter &#123; s -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>) &#125;</span><br><span class="line">   .map &#123; value -&gt; value.first().toUpperCase() &#125;.collect &#123; value -&gt; log(<span class="string">&quot;<span class="variable">$value</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="变换运算符-类似Map-Filter"><a href="#变换运算符-类似Map-Filter" class="headerlink" title="变换运算符(类似Map + Filter)"></a>变换运算符(类似Map + Filter)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">	<span class="keyword">val</span> flow = (<span class="number">1.</span><span class="number">.3</span>).asFlow().transform &#123; value -&gt;</span><br><span class="line">		<span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			emit(value)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			emit((value + <span class="number">1</span>) * <span class="number">10</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	flow.collect &#123;</span><br><span class="line">		println(it)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行流操作之前, 包装下元素</p>
<h3 id="限⻓操作符"><a href="#限⻓操作符" class="headerlink" title="限⻓操作符"></a>限⻓操作符</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">number</span><span class="params">()</span></span> = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      emit(<span class="number">1</span>)</span><br><span class="line">      emit(<span class="number">2</span>)</span><br><span class="line">      log(<span class="string">&quot;zhazha&quot;</span>)</span><br><span class="line">      emit(<span class="number">3</span>)</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      log(<span class="string">&quot;finally xixi&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> sum = number().take(<span class="number">2</span>).reduce &#123; accumulator, value -&gt;</span><br><span class="line">      accumulator + value</span><br><span class="line">   &#125;</span><br><span class="line">   println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="末端流操作符"><a href="#末端流操作符" class="headerlink" title="末端流操作符"></a>末端流操作符</h2><ol>
<li><code>toList</code> <code>toSet</code></li>
<li><code>first</code>  <code>single</code></li>
<li><code>reduce</code> <code>fold</code></li>
</ol>
<blockquote>
<p>总体来说和 <code>List</code> 或者 <code>sequence</code> 差不多</p>
</blockquote>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>求和案例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sum = (<span class="number">1.</span><span class="number">.5</span>).asFlow()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .reduce &#123; a, b -&gt; a + b &#125;</span><br><span class="line">    println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>55</p>
<h2 id="Flow是有序的"><a href="#Flow是有序的" class="headerlink" title="Flow是有序的"></a>Flow是有序的</h2><p>除非使用了对多个flow进行操作的特殊运算符，否则flow的每个单独集合都是按顺序进行的。collection直接在协程中运行，该协程调用终端操作。此时在默认情况下，不会有新的协程被启动。所有的中间操作将以从上游到下游的顺序处理emit过的value，最后再交给末端操作符操作</p>
<p>请参见以下示例，该示例过滤偶数并将其映射到字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.5</span>).asFlow()</span><br><span class="line">        .filter &#123;</span><br><span class="line">            println(<span class="string">&quot;Filter <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            it % <span class="number">2</span> == <span class="number">0</span>              </span><br><span class="line">        &#125;</span><br><span class="line">        .map &#123;</span><br><span class="line">            println(<span class="string">&quot;Map <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            <span class="string">&quot;string <span class="variable">$it</span>&quot;</span></span><br><span class="line">        &#125;.collect &#123; </span><br><span class="line">            println(<span class="string">&quot;Collect <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Filter 1</span><br><span class="line">Filter 2</span><br><span class="line">Map 2</span><br><span class="line">Collect string 2</span><br><span class="line">Filter 3</span><br><span class="line">Filter 4</span><br><span class="line">Map 4</span><br><span class="line">Collect string 4</span><br><span class="line">Filter 5</span><br></pre></td></tr></table></figure>



<h2 id="Flow上下文"><a href="#Flow上下文" class="headerlink" title="Flow上下文"></a>Flow上下文</h2><p>Collection of a flow always happens in the context of the calling coroutine. For example, if there is a <code>simple</code> flow, then the following code runs in the context specified by the author of this code, regardless of the implementation details of the <code>simple</code> flow:</p>
<p>flow的collection过程总是发生在调用协程的上下文中。比如有一个simple flow，然后以下代码在开发者指定的上下文中运行，而不论 simple flow的实现细节如何</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">withContext(context) &#123;</span><br><span class="line">    simple().collect &#123; value -&gt;</span><br><span class="line">        println(value) <span class="comment">// run in the specified context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>simple</code> 流的信息将被 <code>context</code> 上下文保存</strong></p>
<p>因此，在 flow {…} 构建器中的代码运行在相应的 <code>flow collect</code> 提供的上下文中</p>
<p>例如：</p>
<p>考虑 simple 函数打印了调用该函数的 线程 然后 <code>emit</code> 了 三个数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">&quot;[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    log(<span class="string">&quot;Started simple flow&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt; log(<span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span>) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>[main @coroutine#1] Started simple flow</p>
<p>[main @coroutine#1] Collected 1</p>
<p>[main @coroutine#1] Collected 2</p>
<p>[main @coroutine#1] Collected 3</p>
<p>由于，从主线程调用 <code>simple.collect</code> 函数，也在主线程中调用 <code>simple flow</code> 的主体。这是快速运行或异步代码的理想默认形式，它不关心执行的上下文并且不会阻塞调用者。</p>
<h2 id="flow-的-collect-和-emit-必须在同一个协程上下文"><a href="#flow-的-collect-和-emit-必须在同一个协程上下文" class="headerlink" title="flow 的 collect 和 emit 必须在同一个协程上下文"></a>flow 的 collect 和 emit 必须在同一个协程上下文</h2><blockquote>
<p>flow 不是协程安全的，所以会报错<code>IllegalStateException</code></p>
</blockquote>
<p>前面说过的，<code>flow</code>借助上下文保存属性，但很多时候我们的 <code>UI-updaing</code> 代码需要执行在 <code>Dispatcher.Main</code>中，在执行 <strong>CPU 计算型</strong>代码的时候需要在 <code>Dispatcher.Default</code> 导致上下文变了，这会引起 <code>flow</code> 报错</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="comment">// 将 kotlin协程调整到 CPU 消费型（计算型） 上下文中</span></span><br><span class="line">    kotlinx.coroutines.withContext(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>) <span class="comment">// 假设我们在这里做了CPU计算操作</span></span><br><span class="line">            emit(i) <span class="comment">// 将计算结果 emit</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: Flow invariant <span class="keyword">is</span> violated:</span><br><span class="line">		Flow was collected <span class="keyword">in</span> [CoroutineId(<span class="number">1</span>), <span class="string">&quot;coroutine#1&quot;</span>:BlockingCoroutine&#123;Active&#125;@5511c7f8, <span class="symbol">BlockingEventLoop@</span>2eac3323],</span><br><span class="line">		but emission happened <span class="keyword">in</span> [CoroutineId(<span class="number">1</span>), <span class="string">&quot;coroutine#1&quot;</span>:DispatchedCoroutine&#123;Active&#125;@2dae0000, Dispatchers.Default].</span><br><span class="line">		Please refer to <span class="string">&#x27;flow&#x27;</span> documentation or use <span class="string">&#x27;flowOn&#x27;</span> instead</span><br><span class="line">	at ...</span><br></pre></td></tr></table></figure>



<p>异常已经给出解决方案了, 使用 <code>flowOn</code></p>
<h3 id="flowOn保证协程安全"><a href="#flowOn保证协程安全" class="headerlink" title="flowOn保证协程安全"></a><code>flowOn</code>保证协程安全</h3><p><code>flowOn</code>将执行此流的上下文更改为给定的上下文</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">        log(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 使用正确的方式改变协程的上下文</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt;</span><br><span class="line">        log(<span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>[DefaultDispatcher-worker-2 @coroutine#2] Emitting 1</p>
<p>[main @coroutine#1] Collected 1</p>
<p>[DefaultDispatcher-worker-2 @coroutine#2] Emitting 2</p>
<p>[main @coroutine#1] Collected 2</p>
<p>[DefaultDispatcher-worker-2 @coroutine#2] Emitting 3</p>
<p>[main @coroutine#1] Collected 3</p>
<p>仔细看 flowOn 函数的注释：</p>
<p>改变上下文到flow被执行所给定的上下文中。该函数是可组合的，并且只影响前面没有上下文的操作，该函数是上下文保存的：上下文不会影响到下游操作</p>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">withContext(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> singleValue = intFlow <span class="comment">// 如果上下文没有特别执行过，将会在IO上下文中执行</span></span><br><span class="line">        .map &#123; ... &#125; <span class="comment">// 将会在IO上下文中执行</span></span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .filter &#123; ... &#125; <span class="comment">// 将会在Default上下文中执行</span></span><br><span class="line">        .flowOn(Dispatchers.Default)</span><br><span class="line">        .single() <span class="comment">// 将会在Main上下文中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><code>flowOn</code> 是可以做组合的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">withContext(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> singleValue = intFlow <span class="comment">// will be executed on IO if context wasn&#x27;t specified before</span></span><br><span class="line">        .map &#123; ... &#125; <span class="comment">// Will be executed in IO</span></span><br><span class="line">        .flowOn(Dispatchers.IO)</span><br><span class="line">        .filter &#123; ... &#125; <span class="comment">// Will be executed in Default</span></span><br><span class="line">        .flowOn(Dispatchers.Default)</span><br><span class="line">        .single() <span class="comment">// Will be executed in the Main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得看下上面代码中的英文</p>
<h3 id="buffer缓冲"><a href="#buffer缓冲" class="headerlink" title="buffer缓冲"></a>buffer缓冲</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">      simple().collect &#123; value -&gt;</span><br><span class="line">         delay(<span class="number">300</span>)</span><br><span class="line">         println(value)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下, 我们执行完上面的代码需要 1200ms+ 但是我们可以考虑使用 buffer</p>
<blockquote>
<p>前面的 <code>flowOn</code> 就这利用这种方式实现的, 只不过前面的是隐式的, 这里是显示的 </p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">      simple().buffer().collect &#123; value -&gt;</span><br><span class="line">         delay(<span class="number">300</span>)</span><br><span class="line">         println(value)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>simple().buffer().collect</code> 这样之后执行时间将会是 <code>1000ms</code>左右</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">  delay(<span class="number">100</span>)</span><br><span class="line">  emit(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他类似于起三个协程, 同时等待 100 之后一起 <code>emit</code> 出去</p>
<p>这样的话, 我们的代码只要等待 3 次 <code>300ms</code> 外加上 一次 <code>100ms</code> 就完事了, 节省了 2 次 <code>100ms</code> 的等待</p>
<p>为了不阻塞主线程, 我们还可以, 让别的线程去等待 <code>delay</code> 函数, 就像下面这样: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">      launch &#123;</span><br><span class="line">         simple().buffer().collect &#123; value -&gt;</span><br><span class="line">            delay(<span class="number">300</span>)</span><br><span class="line">            log(value) </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="跳过中间比较耗时的操作"><a href="#跳过中间比较耗时的操作" class="headerlink" title="跳过中间比较耗时的操作"></a>跳过中间比较耗时的操作</h3><p>有些情况下我们并不需要知道所有的流操作是否，我们只要知道中间的流操作的部分结果或者部分操作状态的更新，此时我们可以使用 <code>conflate</code> 跳过中间的部分操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple02</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">	<span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">		delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></span><br><span class="line">		emit(i) <span class="comment">// emit next value</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">		simple02()</span><br><span class="line">			.conflate() <span class="comment">// conflate emissions, don&#x27;t process each one</span></span><br><span class="line">			.collect &#123; value -&gt;</span><br><span class="line">				delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">				println(value)</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">main: 1</span></span><br><span class="line"><span class="function"><span class="title">main</span>: 3</span></span><br><span class="line"><span class="function"><span class="title">main</span>: 6</span></span><br><span class="line"><span class="function"><span class="title">main</span>: 9</span></span><br><span class="line"><span class="function"><span class="title">main</span>: 10</span></span><br><span class="line"><span class="function"><span class="title">main</span>: <span class="title">Collected</span> <span class="title">in</span> 1778 <span class="title">ms</span></span></span><br></pre></td></tr></table></figure>



<h2 id="处理最新的值"><a href="#处理最新的值" class="headerlink" title="处理最新的值"></a>处理最新的值</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .collectLatest &#123; value -&gt; <span class="comment">// 取消并重新发射最后一个值</span></span><br><span class="line">                println(<span class="string">&quot;Collecting <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(<span class="string">&quot;Done <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collecting 1</span><br><span class="line">Collecting 2</span><br><span class="line">Collecting 3</span><br><span class="line">Done 3</span><br><span class="line">Collected in 777 ms</span><br></pre></td></tr></table></figure>

<h2 id="组合多个流"><a href="#组合多个流" class="headerlink" title="组合多个流"></a>组合多个流</h2><h3 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h3><p>就像在 <code>kotlin</code> 标准库中的 <code>Sequence.zip</code> 扩展函数一样，flows 也有一个 <code>zip</code> 操作，该操作 组合两个 <code>flows</code> 相应的值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">      .zip(flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>)) &#123; a, b -&gt;</span><br><span class="line">         <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span></span><br><span class="line">      &#125;.collect(::println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1 -&gt; one<br>2 -&gt; two<br>3 -&gt; three</p>
<h3 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h3><p>当流代表一个变量或者操作的最新值时，他可能被需要执行一个取决于相对应流最新值的计算，并且每当上游flows发出一个值时，重新计算它。相应的运算符族称为组合。</p>
<h2 id="展平Flow"><a href="#展平Flow" class="headerlink" title="展平Flow"></a>展平Flow</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span>: Flow&lt;String&gt; = flow &#123;</span><br><span class="line">   emit(<span class="string">&quot;<span class="variable">$i</span>: First&quot;</span>)</span><br><span class="line">   delay(<span class="number">500</span>) <span class="comment">// wait 500 ms</span></span><br><span class="line">   emit(<span class="string">&quot;<span class="variable">$i</span>: Second&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> flow: Flow&lt;Flow&lt;String&gt;&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow().map &#123; requestFlow(it) &#125;</span><br><span class="line">   flow.collect(::println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意： <code>Flow&lt;Flow&lt;String&gt;&gt;</code> 没有被展平成一个 Flow</p>
<p>很多情况，我们需要将多个 Flow 合并成一个 Flow，那么有什么方法呢？</p>
<h3 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a><code>flatMapConcat</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(FlowPreview::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">	(<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;</span><br><span class="line">		.flatMapConcat &#123; requestFlow(it) &#125;</span><br><span class="line">		.collect &#123; value -&gt;</span><br><span class="line">			println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span>&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26af81bbb8ae490087db1c8c45750912~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p>
<p>可以看到，多个 <code>Flow</code> 被整合成一个 <code>Flow&lt;String&gt;</code></p>
<p>1: First at 198 ms from start<br>1: Second at 747 ms from start<br>2: First at 858 ms from start<br>2: Second at 1370 ms from start<br>3: First at 1480 ms from start<br>3: Second at 1986 ms from start</p>
<h3 id="flatMapMerge-并发组合流"><a href="#flatMapMerge-并发组合流" class="headerlink" title="flatMapMerge 并发组合流"></a><code>flatMapMerge</code> 并发组合流</h3><p>还有一种展平的方式<code>flatMapMerge</code>, 它利用了并发的方式, 将多个流组合成一个流, 但有限制, 合并的流不能超过 <code>DEFAULT_CONCURRENCY</code> , 默认是16个, 我们可以在 <code>jvm</code> 上用 <code>DEFAULT_CONCURRENCY_PROPERTY_NAME</code> 属性进行修改</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(measureTimeMillis &#123;</span><br><span class="line">   (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;.flatMapMerge(<span class="number">3</span>) &#123; requestFlow(it) &#125;.collect &#123; value -&gt; log(value) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你会发现时间明显变少 前面两种方式分别是 <code>19xxms 18xxms</code> , 而我们这里通常在 <code>9xxms</code>, 少了一半的时间</p>
<p>1: First at 210 ms from start<br>2: First at 286 ms from start<br>3: First at 397 ms from start<br>1: Second at 728 ms from start<br>2: Second at 789 ms from start<br>3: Second at 919 ms from start</p>
<p>注意，这里的打印就和上面的<code>flatMapConcat</code>不相同了</p>
<h3 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a><code>flatMapLatest</code></h3><p>与 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> 操作符类似（在<a target="_blank" rel="noopener" href="https://book.kotlincn.net/text/flow.html#%E5%A4%84%E7%90%86%E6%9C%80%E6%96%B0%E5%80%BC">“处理最新值”</a> 小节中已经讨论过），也有相对应的“最新”展平模式，在发出新流后立即取消先前流的收集。 这由 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> 操作符来实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(ExperimentalCoroutinesApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">   (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;</span><br><span class="line">      .flatMapLatest &#123; requestFlow(it) &#125;</span><br><span class="line">      .collect &#123;</span><br><span class="line">         println(<span class="string">&quot;<span class="variable">$it</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1: First at 265 ms from start<br>2: First at 381 ms from start<br>3: First at 485 ms from start<br>3: Second at 996 ms from start</p>
<blockquote>
<p>注意，<a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> 在一个新值到来时取消了块中的所有代码 (本示例中的 <code>&#123; requestFlow(it) &#125;</code>）。 这在该特定示例中不会有什么区别，由于调用 <code>requestFlow</code> 自身的速度是很快的，不会发生挂起， 所以不会被取消。然而，如果我们要在块中调用诸如 <code>delay</code> 之类的挂起函数，这将会被表现出来。</p>
</blockquote>
<h2 id="流异常"><a href="#流异常" class="headerlink" title="流异常"></a>流异常</h2><p><code>Flow</code>出现异常的处理方法</p>
<h3 id="collect-函数使用-try-和-catch"><a href="#collect-函数使用-try-和-catch" class="headerlink" title="collect 函数使用 try 和 catch"></a>collect 函数使用 try 和 catch</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      simple().collect &#123;</span><br><span class="line">         println(it)</span><br><span class="line">         check(it &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected <span class="variable">$it</span>&quot;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">      e.printStackTrace()</span><br><span class="line">      println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在收集器内部出现了异常，被 <code>try catch</code> 捕获</p>
<h3 id="捕获任何异常"><a href="#捕获任何异常" class="headerlink" title="捕获任何异常"></a>捕获任何异常</h3><p>在非末端函数中的异常也会被捕获</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;.map &#123; value -&gt;</span><br><span class="line">   check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crashed on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">   <span class="string">&quot;string <span class="variable">$value</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      simple().collect &#123;</span><br><span class="line">         println(it)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">      println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="流异常的透明性"><a href="#流异常的透明性" class="headerlink" title="流异常的透明性"></a>流异常的透明性</h2><p>上面的代码存在一个问题。</p>
<p>从 try、catch 代码块中的 flow 构建器中emit的值是违反异常透明的</p>
<p>换句话说，流的异常不应给交给调用它的地调用方去处理，而是交给<code>flow</code>自己去解决</p>
<h3 id="透明捕获"><a href="#透明捕获" class="headerlink" title="透明捕获"></a>透明捕获</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;String&gt; = </span><br><span class="line">    flow &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123; value -&gt;</span><br><span class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Crashed on <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">        <span class="string">&quot;string <span class="variable">$value</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; e -&gt; emit(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>) &#125; <span class="comment">// 发射一个异常</span></span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用这种方式捕获异常只能捕获catch函数前面的异常，如果 <code>collect</code> 报错的话，无法被 <code>catch</code> 函数捕获</p>
<p>如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .<span class="keyword">catch</span> &#123; e -&gt; println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>) &#125; <span class="comment">// 不会捕获下游异常</span></span><br><span class="line">        .collect &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span> &#125;                 </span><br><span class="line">            println(value) </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="声明式的异常捕获"><a href="#声明式的异常捕获" class="headerlink" title="声明式的异常捕获"></a>声明式的异常捕获</h3><p>我们可以将 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> 操作符的声明性与处理所有异常的期望相结合，将 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 操作符的代码块移动到 <a target="_blank" rel="noopener" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> 中，并将其放到 <code>catch</code> 操作符之前。收集该流必须由调用无参的 <code>collect()</code> 来触发</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    simple().onEach &#123;</span><br><span class="line">       check(it &lt;= <span class="number">2</span>)</span><br><span class="line">       log(it)</span><br><span class="line">    &#125;.<span class="keyword">catch</span> &#123; cause -&gt; log(<span class="string">&quot;Cause <span class="variable">$cause</span>&quot;</span>) &#125;.collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>flow</code> 中 <code>on</code> 开头的函数, 类似于 <code>JavaScript</code> 中的 事件触发, 比如 <code>onClick</code> 就是鼠标点击, <code>OnEach</code> 就是在遍历的时候触发</p>
</blockquote>
<h2 id="完成流-命令式和声明式"><a href="#完成流-命令式和声明式" class="headerlink" title="完成流(命令式和声明式)"></a>完成流(命令式和声明式)</h2><h3 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      simple().collect &#123; value -&gt; log(value) &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      log(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   simple().onCompletion &#123; cause -&gt;</span><br><span class="line">      log(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">   &#125;.collect &#123; value -&gt; log(value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明式的好处, 在于还可以发现我们的流有没有异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> (<span class="number">1.</span><span class="number">.3</span>)) &#123;</span><br><span class="line">      delay(<span class="number">100</span>)</span><br><span class="line">      check(i &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;错误&quot;</span> &#125;</span><br><span class="line">      emit(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    simple().onCompletion &#123; cause -&gt;</span><br><span class="line">       <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">          log(<span class="string">&quot;Flow completed with <span class="variable">$cause</span>&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;.<span class="keyword">catch</span> &#123; cause -&gt;</span><br><span class="line">       log(<span class="string">&quot;Caught exception <span class="variable">$cause</span>&quot;</span>)</span><br><span class="line">    &#125;.collect &#123; value -&gt; log(value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>onCompletion</code>不会处理流的异常，它可以被用于观察是否发生异常</p>
<p>所以不要企图使用 <code>onCompletion</code> 处理异常</p>
<h2 id="指定flow在给定的协程上运行-launchIn"><a href="#指定flow在给定的协程上运行-launchIn" class="headerlink" title="指定flow在给定的协程上运行: launchIn"></a>指定flow在给定的协程上运行: <code>launchIn</code></h2><p>前面的 <code>collect</code> 收集器有个缺点, <code>collect</code> 后面的代码会等待</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟事件流</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">events</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">   events()</span><br><span class="line">      .onEach &#123; event -&gt; println(<span class="string">&quot;Event: <span class="variable">$event</span>&quot;</span>) &#125;</span><br><span class="line">      .collect() <span class="comment">// &lt;--- 线程将在这里等待</span></span><br><span class="line">   println(<span class="string">&quot;Done&quot;</span>) <span class="comment">// &lt;--- 这里的代码不能第一时间执行到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>比如上面你的代码最终会打印出下面的情况：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] Event: <span class="number">1</span></span><br><span class="line">[main] Event: <span class="number">2</span></span><br><span class="line">[main] Event: <span class="number">3</span></span><br><span class="line">[main] Done</span><br></pre></td></tr></table></figure>



<p><code>println(&quot;Done&quot;)</code>被延迟了</p>
<p>明明不在流上的操作，却阻塞了 <code>Done</code></p>
<p>如果不想要 <code>collect</code> 等待的话, 则可以使用  <code>launchIn(coroutineScope)</code> </p>
<p>让任务在单独的协程中执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟事件流</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">events</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    events().onEach &#123; event-&gt; log(<span class="string">&quot;Event: <span class="variable">$event</span>&quot;</span>) &#125;</span><br><span class="line">       .launchIn(<span class="keyword">this</span>)</span><br><span class="line">   log(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] Done</span><br><span class="line">[main] Event: <span class="number">1</span></span><br><span class="line">[main] Event: <span class="number">2</span></span><br><span class="line">[main] Event: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><code>Done</code> 最先输出了</p>
<p>咱们还可以把流给其他协程执行, 让他在后台执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> job = events().onEach &#123; event -&gt; log(<span class="string">&quot;Event: <span class="variable">$event</span>&quot;</span>) &#125;</span><br><span class="line">      .launchIn(CoroutineScope(Dispatchers.Default))</span><br><span class="line">   log(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">   job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="流取消检测-1"><a href="#流取消检测-1" class="headerlink" title="流取消检测"></a>流取消检测</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; </span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>) </span><br><span class="line">        emit(i) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    foo().collect &#123; value -&gt; </span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">3</span>) cancel()  </span><br><span class="line">        println(value)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>正常情况下， Flow 都会检测取消情况</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28a89608252341f99208e7f95d1b4856~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p>
<p>在上图剪头的位置（也就是 <code>emit</code> 的时候会检测），会不断的随着循环检测<code>ensureActive</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Emitting 1</span><br><span class="line">1</span><br><span class="line">Emitting 2</span><br><span class="line">2</span><br><span class="line">Emitting 3</span><br><span class="line">3</span><br><span class="line">Emitting 4</span><br><span class="line">Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine&#123;Cancelled&#125;@cb0ed20</span><br></pre></td></tr></table></figure>



<p>但是出于性能考虑，大多数情况下， flow 默认会关闭 <code>ensureActive</code>检测</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.5</span>).asFlow().collect &#123; value -&gt; </span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">3</span>) cancel()  </span><br><span class="line">        println(value)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine&#123;Cancelled&#125;@9a7504c</span><br></pre></td></tr></table></figure>



<p>能看得出来，打印出了 4 5 最后才报的错</p>
<h3 id="让繁忙的流可取消"><a href="#让繁忙的流可取消" class="headerlink" title="让繁忙的流可取消"></a>让繁忙的流可取消</h3><p>有时候，出于某些目的，我们偏偏需要在该取消的时候取消掉我们的 flow，这时可以使用这种方式：</p>
<p><code>.onEach &#123; currentCoroutineContext().ensureActive() &#125;</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">   (<span class="number">1.</span><span class="number">.5</span>).asFlow()</span><br><span class="line">      .onEach &#123; currentCoroutineContext().ensureActive() &#125;</span><br><span class="line">      .collect &#123; value -&gt;</span><br><span class="line">         <span class="keyword">if</span> (value == <span class="number">3</span>) cancel()</span><br><span class="line">         println(value)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>不过我们还能看到这个方法：<code>.cancellable()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">   (<span class="number">1.</span><span class="number">.5</span>).asFlow()</span><br><span class="line">      .cancellable()</span><br><span class="line">      .collect &#123; value -&gt;</span><br><span class="line">         <span class="keyword">if</span> (value == <span class="number">3</span>) cancel()</span><br><span class="line">         println(value)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine&#123;Cancelled&#125;@59906517</span><br></pre></td></tr></table></figure>



</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bangiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bangiao.github.io/2022/12/03/07kotlin/十一、kotlin的协程(二)——冷流flow/">https://bangiao.github.io/2022/12/03/07kotlin/十一、kotlin的协程(二)——冷流flow/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5/">异步</a><a class="post-meta__tags" href="/tags/zip/">zip</a><a class="post-meta__tags" href="/tags/reduce/">reduce</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a><a class="post-meta__tags" href="/tags/%E5%86%B7%E6%B5%81/">冷流</a><a class="post-meta__tags" href="/tags/flow/">flow</a><a class="post-meta__tags" href="/tags/flow%E5%8F%96%E6%B6%88/">flow取消</a><a class="post-meta__tags" href="/tags/%E8%B6%85%E6%97%B6%E6%B5%81%E5%8F%96%E6%B6%88/">超时流取消</a><a class="post-meta__tags" href="/tags/%E6%B5%81%E5%8F%96%E6%B6%88%E6%A3%80%E6%B5%8B/">流取消检测</a><a class="post-meta__tags" href="/tags/%E8%AE%A9%E7%B9%81%E5%BF%99%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%8F%96%E6%B6%88/">让繁忙的协程可以取消</a><a class="post-meta__tags" href="/tags/flow%E5%88%9B%E5%BB%BA/">flow创建</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6/">中间流操作符</a><a class="post-meta__tags" href="/tags/%E5%8F%98%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/">变换运算符</a><a class="post-meta__tags" href="/tags/%E9%99%90%E9%95%BF%E6%93%8D%E4%BD%9C%E7%AC%A6/">限长操作符</a><a class="post-meta__tags" href="/tags/%E6%9C%AB%E7%AB%AF%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6/">末端流操作符</a><a class="post-meta__tags" href="/tags/flow%E6%9C%89%E5%BA%8F/">flow有序</a><a class="post-meta__tags" href="/tags/flow%E4%B8%8A%E4%B8%8B%E6%96%87/">flow上下文</a><a class="post-meta__tags" href="/tags/collect/">collect</a><a class="post-meta__tags" href="/tags/emit/">emit</a><a class="post-meta__tags" href="/tags/flowOn/">flowOn</a><a class="post-meta__tags" href="/tags/buffer%E7%BC%93%E5%86%B2/">buffer缓冲</a><a class="post-meta__tags" href="/tags/%E5%A4%84%E7%90%86%E6%9C%80%E6%96%B0%E7%9A%84%E5%80%BC/">处理最新的值</a><a class="post-meta__tags" href="/tags/%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E6%B5%81/">组合多个流</a><a class="post-meta__tags" href="/tags/combine/">combine</a><a class="post-meta__tags" href="/tags/%E5%B1%95%E5%B9%B3flow/">展平flow</a><a class="post-meta__tags" href="/tags/flatMapConcat/">flatMapConcat</a><a class="post-meta__tags" href="/tags/flatMapMerge/">flatMapMerge</a><a class="post-meta__tags" href="/tags/flatMapLatest/">flatMapLatest</a><a class="post-meta__tags" href="/tags/%E6%B5%81%E5%BC%82%E5%B8%B8/">流异常</a><a class="post-meta__tags" href="/tags/%E6%8D%95%E8%8E%B7%E4%BB%BB%E4%BD%95%E5%BC%82%E5%B8%B8/">捕获任何异常</a><a class="post-meta__tags" href="/tags/%E6%B5%81%E5%BC%82%E5%B8%B8%E7%9A%84%E9%80%8F%E6%98%8E%E6%80%A7/">流异常的透明性</a><a class="post-meta__tags" href="/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/">声明式异常捕获</a><a class="post-meta__tags" href="/tags/%E5%AE%8C%E6%88%90%E6%B5%81/">完成流</a><a class="post-meta__tags" href="/tags/%E5%91%BD%E4%BB%A4%E5%BC%8F/">命令式</a><a class="post-meta__tags" href="/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F/">声明式</a><a class="post-meta__tags" href="/tags/launchIn/">launchIn</a><a class="post-meta__tags" href="/tags/%E8%AE%A9%E7%B9%81%E5%BF%99%E7%9A%84%E6%B5%81%E5%8F%AF%E5%8F%96%E6%B6%88/">让繁忙的流可取消</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/12/03/07kotlin/%E5%8D%81%E4%B8%80%E3%80%81kotlin%E7%9A%84%E5%8D%8F%E7%A8%8B(%E4%B8%80)/"><i class="fa fa-chevron-left">  </i><span>十一、kotlin的协程(一)</span></a></div><div class="next-post pull-right"><a href="/2022/12/03/07kotlin/%E5%8D%81%E4%B8%80%E3%80%81kotlin%E7%9A%84%E5%8D%8F%E7%A8%8B(%E4%B8%89)%E2%80%94%E2%80%94%E7%83%AD%E6%B5%81channel/"><span>十一、kotlin的协程(三)——热流channel</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2022 By Bangiao</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这是博客github仓库地址：<a target="_blank" rel="noopener" href="https://github.com/bangiao/bangiao.github.io">bangiao.github.io</a>，欢迎访问!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>