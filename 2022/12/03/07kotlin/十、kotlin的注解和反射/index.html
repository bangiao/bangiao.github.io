<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="十、kotlin的注解和反射"><meta name="keywords" content="注解,反射,KClass,KCallable,KFuntion,KProperty,注解目标,setparam,delegate,receiver,动态代理类,坑"><meta name="author" content="Bangiao"><meta name="copyright" content="Bangiao"><title>十、kotlin的注解和反射 | Bangiao's Notebooks</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%92%8C-kotlin-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">java 和 kotlin 注解的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text">注解目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">定义注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.4.</span> <span class="toc-text">控制注解可以注解的目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%81%9A%E6%B3%A8%E8%A7%A3%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">使用类做注解参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%81%9A%E6%B3%A8%E8%A7%A3%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">使用泛型类做注解参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">2.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84-KClass%E3%80%81KCallable%E3%80%81KFuntion-%E5%92%8C-KProperty"><span class="toc-number">2.1.</span> <span class="toc-text">反射的 KClass、KCallable、KFuntion 和 KProperty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KClass"><span class="toc-number">2.1.1.</span> <span class="toc-text">KClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KFunction"><span class="toc-number">2.1.2.</span> <span class="toc-text">KFunction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KProperty"><span class="toc-number">2.1.3.</span> <span class="toc-text">KProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E5%80%9F%E5%8A%A9-%E5%8F%8D%E5%B0%84-%E8%8E%B7%E5%8F%96%E5%89%8D%E9%9D%A2%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.4.</span> <span class="toc-text">现在我们借助 反射 获取前面注解的目标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9B%AE%E6%A0%87setparam"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">注解目标setparam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9B%AE%E6%A0%87delegate"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">注解目标delegate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9B%AE%E6%A0%87-receiver"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">注解目标 receiver</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kotlin%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E5%9D%91"><span class="toc-number">2.2.</span> <span class="toc-text">kotlin使用动态代理类的坑</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://imgsa.baidu.com/forum/pic/item/c8179682d158ccbf63dc944d1bd8bc3eb03541a9.jpg"></div><div class="author-info__name text-center">Bangiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/bangiao">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">72</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">638</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的博客</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/4248168662314823">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30690165">CSDN</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/bangiao/">博客园</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/projects">Gitee笔记源码</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bangiao's Notebooks</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章列表</a><a class="site-page" href="/tags">文章标签</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/sources">笔记源码</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">十、kotlin的注解和反射</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>先说下, kotlin的反射只使用于 kotlin 特定功能, 如果是 java 方面的功能, 最好使用java版反射</p>
</blockquote>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="java-和-kotlin-注解的区别"><a href="#java-和-kotlin-注解的区别" class="headerlink" title="java 和 kotlin 注解的区别"></a>java 和 kotlin 注解的区别</h2><ol>
<li>将类传递进注解的方式 <code>@MyAnnotation(MyClass::class)</code></li>
<li>注解传递注解为参数的方式 去掉注解前面的 <code>@</code> 就可以了, <code>@Annotation(MyAnnotation(MyClass::class))</code></li>
<li>把数组传递到注解中, <code>@RequestMapping(path = arrayOf(&quot;/foo&quot;, &quot;bar&quot;))</code>, 如果是 java 的数组注解, 将会变成 <code>vararg</code> 可变参数</li>
<li>注解传递我们的属性(类的属性), 需要属性是<code>编译期常量</code>的, 也就是编译期间就确定的参数, 这里我们使用 <code>const</code> 修饰在顶层、<code>companion object</code>或者<code>object</code></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> TEST_TIMEOUT = <span class="number">100L</span></span><br><span class="line"><span class="meta">@Test(timeout = TEST_TIMEOUT)</span> <span class="function"><span class="keyword">fun</span> <span class="title">tesMethod</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解目标"><a href="#注解目标" class="headerlink" title="注解目标"></a>注解目标</h2><p>kotlin 一个属性包含了很多部分, 它主要由: <strong>字段 + get&#x2F;set 函数</strong>组成, 所以注解的标注需要指定具体标注的谁</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad158bcf58e421ca6d937722063935c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>kotlin注解可以对上面几个位置进行标注</p>
<ul>
<li><code>setparam</code>: 对 <code>set</code> 函数的参数进行注解</li>
<li><code>set</code>: 对属性的 <code>set</code> 函数注解</li>
<li><code>get</code>: 对属性的 <code>get</code> 函数注解</li>
<li><code>file</code>: 包含在文件中声明的顶层函数和顶层属性注解, 比如<code>@file:JvmName(&quot;ClassName&quot;)</code>对文件注解, 下面有说明</li>
<li><code>delegate</code>: 为委托属性存储委托实例的字段, 注解的是属性生成出来的委托属性</li>
<li><code>field</code>: 标注属性的字段, 不是幕后字段哦</li>
<li><code>param</code>: 构造方法的参数</li>
<li><code>property</code>: 具有此目标的注解对java不可见</li>
<li><code>receiver</code>: 扩展函数或者属性的接收者</li>
</ul>
<blockquote>
<p>很多时候我们不知道它注解的时候哪个部位其实有一个很简单的方式, 在 kotlin 中注解, 然后在 kotlin 反编译成 java 代码的插件中查看具体注解给了哪个部位</p>
</blockquote>
<ol>
<li><code>setparam</code>注解的是构造函数的参数(记住注解的不是 <strong>name</strong> 字段)</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo03SetParam</span>(<span class="meta">@setparam:Rule</span> <span class="keyword">var</span> name: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(<span class="meta">@Rule</span> <span class="meta">@NotNull</span> String var1)</span> &#123;</span><br><span class="line">    Intrinsics.checkNotNullParameter(var1, <span class="string">&quot;&lt;set-?&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.name = var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>delegate</code> 注解的是委托对象</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="built_in">Int</span> <span class="keyword">by</span> MyDelegate()</span><br></pre></td></tr></table></figure>

<p>委托的是一个叫 <code>a$delegate</code> 的委托对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MyDelegate a$delegate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a$delegate.getValue(<span class="built_in">this</span>, $$delegatedProperties[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.a$delegate.setValue(<span class="built_in">this</span>, $$delegatedProperties[<span class="number">0</span>], var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>receiver</code> 注解的是接收者</li>
</ol>
<p>对扩展函数: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> @receiver:Rule String.<span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">   println(<span class="string">&quot;extFunc <span class="variable">$this</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="meta">@Rule</span> String $<span class="built_in">this</span>$f)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="string">&quot;extFunc &quot;</span> + $<span class="built_in">this</span>$f;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   System.out.println(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对扩展操作符重载: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> @receiver:Rule Demo01.<span class="title">plusAssign</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="keyword">this</span>.name + s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final void plusAssign(@Rule Demo01 $this$plusAssign, String s) &#123;</span><br><span class="line">   Intrinsics.checkNotNullParameter($this$plusAssign, &quot;$this$plusAssign&quot;);</span><br><span class="line">   $this$plusAssign.setName($this$plusAssign.getName() + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是成员函数的操作符重载, 则不可以使用 <code>@receiver:Rule</code> , 侧面说明 成员函数没有 <code>receiver</code></p>
</blockquote>
<p>对扩展属性: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> <span class="meta">@receiver:Rule</span> StringBuilder.c: String</span><br><span class="line">   <span class="keyword">get</span>() = <span class="keyword">this</span>.toString()</span><br><span class="line">   <span class="keyword">set</span>(value) &#123;</span><br><span class="line">      <span class="keyword">this</span>.append(value)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>反编译: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title function_">getC</span><span class="params">(<span class="meta">@Rule</span> StringBuilder $<span class="built_in">this</span>$c)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">var10000</span> <span class="operator">=</span> $<span class="built_in">this</span>$c.toString();</span><br><span class="line">   Intrinsics.checkNotNullExpressionValue(var10000, <span class="string">&quot;this.toString()&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> var10000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setC</span><span class="params">(<span class="meta">@Rule</span> StringBuilder $<span class="built_in">this</span>$c, String value)</span> &#123;</span><br><span class="line">   $<span class="built_in">this</span>$c.append(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>file</code> 目标注解</li>
</ol>
<p>主要功能就是将注解标注目标指向文件, 这样的话可以对文件注解</p>
<p>前面学过的 <code>@file:JvmName(&quot;Content&quot;)</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bd9c742418e49ecbd47fce83320d43a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>改完直接指定了本 <code>Demo01</code> 文件名为 <code>Content</code>, 到时候在其他java文件中调用时类名字就从 <code>Demo01</code> 变成 <code>Content</code>了</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a306df4809164b9d930ca072dbef6be2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p>其他的注解就不一一做罗列了, 都比较好理解</p>
</blockquote>
<h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Rule</span></span><br></pre></td></tr></table></figure>

<p>它不能有类体, 如果要添加属性的话</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Rule</span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>

<p>把它当作主构造函数就行了</p>
<blockquote>
<p>kotlin的注解和java一样对 <code>value</code> 进行特殊处理</p>
</blockquote>
<h2 id="控制注解可以注解的目标"><a href="#控制注解可以注解的目标" class="headerlink" title="控制注解可以注解的目标"></a>控制注解可以注解的目标</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(</span></span><br><span class="line"><span class="meta">   AnnotationTarget.CLASS,</span></span><br><span class="line"><span class="meta">   AnnotationTarget.FIELD,</span></span><br><span class="line"><span class="meta">   AnnotationTarget.VALUE_PARAMETER,</span></span><br><span class="line"><span class="meta">   AnnotationTarget.PROPERTY_SETTER,</span></span><br><span class="line"><span class="meta">   AnnotationTarget.FILE</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Rule</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kotlin注解和 java注解不同, kotlin注解在运行时默认能够访问到, 所以不同显示的指定保留期</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br></pre></td></tr></table></figure>

<h2 id="使用类做注解参数"><a href="#使用类做注解参数" class="headerlink" title="使用类做注解参数"></a>使用类做注解参数</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Deserializeinterface</span>(<span class="keyword">val</span> targetClass: KClass&lt;<span class="keyword">out</span> Any&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deserializeinterface(A::class)</span></span><br></pre></td></tr></table></figure>

<h2 id="使用泛型类做注解参数"><a href="#使用泛型类做注解参数" class="headerlink" title="使用泛型类做注解参数"></a>使用泛型类做注解参数</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">CustomSerializer</span>(<span class="keyword">val</span> serializerClass: KClass&lt;<span class="keyword">out</span> ValueSerializer&lt;*&gt;)</span><br></pre></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射的-KClass、KCallable、KFuntion-和-KProperty"><a href="#反射的-KClass、KCallable、KFuntion-和-KProperty" class="headerlink" title="反射的 KClass、KCallable、KFuntion 和 KProperty"></a>反射的 <code>KClass</code>、<code>KCallable</code>、<code>KFuntion</code> 和 <code>KProperty</code></h2><table>
<thead>
<tr>
<th>Java</th>
<th>Kotlin</th>
</tr>
</thead>
<tbody><tr>
<td><code>Class</code></td>
<td><code>KClass</code></td>
</tr>
<tr>
<td><code>Field</code></td>
<td><code>KProperty0~KProperty2</code></td>
</tr>
<tr>
<td><code>Method</code></td>
<td><code>Function</code></td>
</tr>
<tr>
<td><code>obj.getClass()</code></td>
<td><code>obj::class</code> 返回 <code>KClass</code>或者使用 <code>obj::class.java</code>获取<code>Class</code></td>
</tr>
</tbody></table>
<h3 id="KClass"><a href="#KClass" class="headerlink" title="KClass"></a><code>KClass</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kClass: KClass&lt;Demo02&gt; = Demo02::<span class="keyword">class</span></span><br></pre></td></tr></table></figure>

<p>这个类可以获取很多信息, 比如 <code>properties</code>, 比如 <code>functions</code>, 比如 <code>annotation</code>, 比如 <code>super</code> 等等</p>
<p><code>::</code> 不能使用于局部变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> property = ::a <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p><strong>这种操作符只能用于 顶层函数&#x2F;属性, 扩展函数&#x2F;属性 和 类中的函数&#x2F;属性</strong></p>
<blockquote>
<p>我觉得 如果 java 的反射用的好, 那么 kotlin 的反射就可以不要用了, 当然除了属性或者可空类型这种 kotlin 独特的东西外, 都可以用 java 反射</p>
</blockquote>
<h3 id="KFunction"><a href="#KFunction" class="headerlink" title="KFunction"></a><code>KFunction</code></h3><p>在 kotlin 中 <code>KFunction</code>从 <code>0 ~ N</code>, 分别表示参数的数量</p>
<p><strong>0</strong> 表示函数没有参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// fun a() &#123;&#125;</span></span><br><span class="line">   <span class="keyword">val</span> kFunction0: KFunction0&lt;<span class="built_in">Unit</span>&gt; = ::a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1</strong> 表示参数只有一个</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">(n: <span class="type">Int</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// fun a() &#123;&#125;</span></span><br><span class="line">   <span class="keyword">val</span> kFunction1: KFunction1&lt;<span class="built_in">Int</span>, <span class="built_in">Unit</span>&gt; = ::a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2</strong> 表示参数有两个</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">(n: <span class="type">Int</span>, n2: <span class="type">Double</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// fun a() &#123;&#125;</span></span><br><span class="line">   <span class="keyword">val</span> kFunction2: KFunction2&lt;<span class="built_in">Int</span>, <span class="built_in">Double</span>, <span class="built_in">Unit</span>&gt; = ::a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2</strong> 然后 <code>KFunction3&lt;Int, Double, String&gt;</code> 表示第一个函数参数是 <code>Int</code>; 第二个函数参数是 <code>Double</code>; 最后一个是返回值 <code>String</code></p>
<p>根据这个可以判断是<br>(1) 是一个函数<br>(2) 参数分别是 <code>Int</code> 和 <code>Double</code><br>(3) 最后一个是返回值 <code>String</code></p>
<p>如果是成员函数的话</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e1fbc177fdb460481d33dd4f8e09ac8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>共有 <code>4</code> 个泛型参数, 但是 <code>KFunction3</code> 却显示的是 <code>3</code>, 所以类的最后一个数字不能做简单的判断, 需要因地制宜</p>
<blockquote>
<p><code>KFunction0 ~ N</code> 你会发现不能在 kotlin 的包中发现他们, 这是<strong>合成的编译器生成类型</strong>, 主要的目的是防止 <code>KFunction</code> 参数的数量被认为的限制</p>
</blockquote>
<p>对了在 <code>KFunction</code> 中你会发现 <code>call</code> 和 <code>invoke</code> 两个函数, 其中 <code>call</code> 是 <code>KCallable</code> 的函数 但是他们有区别的</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9c795ad1d344c798e9f131aad1ac758~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ce6eb8dbc63433ab14fbf21ac253322~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>所以需要调用, 那最好用 <code>invoke</code> 调用, <code>call</code> 不确定类型, 最好别用</p>
<p>但是你也会发现 </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa01b661bb144d58a2472770018d6c6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><code>invoke</code> 函数也不会被找到, 却可以调用</p>
<h3 id="KProperty"><a href="#KProperty" class="headerlink" title="KProperty"></a>KProperty</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * var b: Int = 0</span></span><br><span class="line"><span class="comment"> * val c: Int = 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> demo02 = Demo02()</span><br><span class="line"><span class="keyword">val</span> kMutableProperty1: KMutableProperty1&lt;Demo02, <span class="built_in">Int</span>&gt; = Demo02::b</span><br><span class="line">kMutableProperty1.setter.call(<span class="number">21</span>)</span><br><span class="line">println(kMutableProperty1.getter.invoke(demo02))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> kProperty0: KProperty0&lt;<span class="built_in">Int</span>&gt; = demo02::c</span><br><span class="line"><span class="comment">// 类似于 kProperty0.getter.invoke() 或者 kProperty0.getter.call() 或者 kProperty0.getter()</span></span><br><span class="line">println(kProperty0())</span><br></pre></td></tr></table></figure>

<p>注意到了么? <code>KMutableProperty1</code> 和 <code>KProperty0</code> 一个是 <code>var</code> 另一个是 <code>val</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/103b5c0289bb4d44872fadca3a4df0ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="现在我们借助-反射-获取前面注解的目标"><a href="#现在我们借助-反射-获取前面注解的目标" class="headerlink" title="现在我们借助 反射 获取前面注解的目标"></a>现在我们借助 反射 获取前面注解的目标</h3><ul>
<li>setparam: 对 set 函数的参数进行注解(主构造属性的 setter 参数无法注解???)</li>
<li>set: 对属性的 set 函数注解</li>
<li>get: 对属性的 get 函数注解</li>
<li>file: 包含在文件中声明的顶层函数和顶层属性注解, 比如<code>@file:JvmName(&quot;ClassName&quot;)</code>对文件注解, 下面有说明</li>
<li>delegate: 为委托属性存储委托实例的字段, 注解的是属性生成出来的委托属性</li>
<li>field: 标注属性的字段, 如果注解的是属性字段的话默认可以不写<code>field</code>, 不是幕后字段哦</li>
<li>param: 只能标注主构造方法的参数</li>
<li>property: 具有此目标的注解对java不可见</li>
<li>receiver: 扩展函数或者属性的接收者</li>
</ul>
<p>我们从难到易最后再读者自己写一个(反射比较重要)</p>
<blockquote>
<p>有个诀窍: 编写反射的话最好打开反编译后的代码, 这样看的更加清晰, 找类 找对象都比较准确</p>
</blockquote>
<h4 id="注解目标setparam"><a href="#注解目标setparam" class="headerlink" title="注解目标setparam"></a>注解目标<code>setparam</code></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="meta">@setparam:Rule</span> <span class="keyword">var</span> name: String, <span class="meta">@param:Rule</span> <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">22</span>) &#123;</span><br><span class="line">   <span class="comment">// 对 set param 注解</span></span><br><span class="line">   <span class="meta">@setparam:Rule</span></span><br><span class="line">   <span class="keyword">var</span> lastName: String = <span class="string">&quot;zhazha&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person(<span class="string">&quot;zzz&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> property0 = person::name</span><br><span class="line"><span class="comment">// 主构造参数无法获取setter参数的注解</span></span><br><span class="line">property0.setter.valueParameters.forEach &#123; println(it.annotations) &#125; <span class="comment">// []</span></span><br><span class="line">property0.setter.parameters.forEach &#123; println(it.annotations) &#125; <span class="comment">// []</span></span><br><span class="line">println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 非主构造函数可以使用 kotlin 获取 setter 参数注解</span></span><br><span class="line"><span class="keyword">val</span> property01 = person::lastName</span><br><span class="line">property01.setter.valueParameters.forEach &#123; println(it.annotations) &#125; <span class="comment">// [@reflection16.Rule()]</span></span><br><span class="line">property01.setter.parameters.forEach &#123; println(it.annotations) &#125; <span class="comment">// [@reflection16.Rule()]</span></span><br><span class="line"><span class="comment">// 使用 原生 java 反射获取 setter 参数的注解</span></span><br><span class="line"><span class="keyword">val</span> clazz = person::<span class="keyword">class</span>.java</span><br><span class="line"><span class="keyword">val</span> property1 = Person::name</span><br><span class="line"><span class="keyword">val</span> method = clazz.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, property1.javaField!!.type)</span><br><span class="line">method.parameters.find &#123; it.type == property1.javaField!!.type &#125;?.annotations?.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>

<p>这里发现 kotlin 反射的局限, 主构造函数参数的<code>setter</code>参数注解无法获取, 但是非主构造函数的<code>setter</code>参数却可以获取</p>
<p>如果在 次构造函数中使用 <code>@setparam</code> 则会报错</p>
<p><code>&#39;@setparam:&#39; annotations could be applied only to property declarations</code></p>
<p><code>&#39;@setparam:&#39; 注释只能应用于属性声明</code></p>
<h4 id="注解目标delegate"><a href="#注解目标delegate" class="headerlink" title="注解目标delegate"></a>注解目标<code>delegate</code></h4><p>该注解最终注解的是委托对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">   <span class="meta">@delegate:Rule</span></span><br><span class="line">   <span class="keyword">var</span> delegate: <span class="built_in">Int</span> <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译的话会看到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MyDelegate delegate$delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.delegate$delegate.getValue(<span class="built_in">this</span>, $$delegatedProperties[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDelegate</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.delegate$delegate.setValue(<span class="built_in">this</span>, $$delegatedProperties[<span class="number">0</span>], var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的 <code>get/set</code> 没有注解, 注解的是 <code>delegate$delegate</code> 对象, 而前面的 <code>var delegate</code> 属性变成了 <code>getDelegate</code> 和 <code>setDelegate</code> 的两个函数</p>
<p>反射获取注解源码: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// kotlin 获取委托对象的注解</span></span><br><span class="line"><span class="comment">// val person = Person(&quot;1&quot;)</span></span><br><span class="line"><span class="comment">// val property0 = person::delegate</span></span><br><span class="line"><span class="comment">// val javaField = property0.javaField!!</span></span><br><span class="line"><span class="comment">// javaField.annotations.forEach &#123; println(it) &#125;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// java获取委托对象注解</span></span><br><span class="line">   <span class="keyword">val</span> person1 = Person(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">   <span class="keyword">val</span> clazz = Person::<span class="keyword">class</span>.java</span><br><span class="line">   <span class="keyword">val</span> field = clazz.declaredFields.find &#123; it.type == MyDelegate::<span class="keyword">class</span>.java &#125;!!</span><br><span class="line">   field.annotations.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>记住了, 使用 kotlin 获取的 <code>KMutableProperty</code> 实际上控制的是 kotlin 的属性, 而 kotlin 的属性包括 字段+get&#x2F;set 一字段俩函数, 所以看到 <code>val javaField = property0.javaField!!</code> 这段代码的时候需要注意, 这是 字段+set&#x2F;get 的字段, 同时该字段也叫 java 字段罢了</p>
</blockquote>
<h4 id="注解目标-receiver"><a href="#注解目标-receiver" class="headerlink" title="注解目标 receiver"></a>注解目标 <code>receiver</code></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> <span class="meta">@receiver:Rule</span> Person.fullName: String</span><br><span class="line">   <span class="keyword">get</span>() = <span class="string">&quot;<span class="subst">$&#123;this.name&#125;</span><span class="subst">$&#123;this.lastName&#125;</span> age: <span class="subst">$&#123;this.age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 java 反射方式获取 扩展属性 fullName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">val</span> clazz = Class.forName(<span class="string">&quot;reflection16.Demo02Kt&quot;</span>)</span><br><span class="line"><span class="comment">// println(clazz) // class reflection16.Demo02Kt</span></span><br><span class="line">   <span class="keyword">val</span> method = clazz.getDeclaredMethod(<span class="string">&quot;getFullName&quot;</span>, Person::<span class="keyword">class</span>.java)</span><br><span class="line">   method.trySetAccessible()</span><br><span class="line"><span class="comment">// val person = Person(&quot;haha&quot;)</span></span><br><span class="line">   <span class="comment">// 这里的 method 其实是 fullName 扩展属性的 getFullName 函数</span></span><br><span class="line"><span class="comment">// val fullName = method.invoke(person, person) as String</span></span><br><span class="line"><span class="comment">// println(fullName)</span></span><br><span class="line">   <span class="comment">// 在这里已经获取了 Rule 注解了</span></span><br><span class="line">   method.parameters.find &#123; it.type == Person::<span class="keyword">class</span>.java &#125;!!.annotations.forEach &#123; println(it) &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用 kotlin 反射方式获取</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// val person = Person(&quot;zhazha&quot;, 23)</span></span><br><span class="line"><span class="comment">// val kProperty0 = person::fullName</span></span><br><span class="line"><span class="comment">// val javaGetter = kProperty0.javaGetter!!</span></span><br><span class="line"><span class="comment">// javaGetter.parameters[0].annotations.forEach &#123; println(it) &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>java那么复杂的反射怎么是怎么写的??? 看<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/825651d7187d4546ac952a0ce8945da7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>这不是有的抄么?</p>
</blockquote>
<h2 id="kotlin使用动态代理类的坑"><a href="#kotlin使用动态代理类的坑" class="headerlink" title="kotlin使用动态代理类的坑"></a>kotlin使用动态代理类的坑</h2><p>前置代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(</span><br><span class="line">   <span class="keyword">val</span> name: String</span><br><span class="line">) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">sell</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SunLibrary</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> book: Book</span><br><span class="line">) : Library &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sell</span><span class="params">()</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;卖书 <span class="subst">$&#123;book.name&#125;</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 java 中我们这么编写动态代理类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="title">implements</span> <span class="title">InvocationHandler</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> ProxyInvocationHandlerJava(Object target) &#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Object getProxy() &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果直接使用 idea 的 java 转 kotlin 功能将生成如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span>(<span class="keyword">private</span> <span class="keyword">val</span> target: Any) : InvocationHandler &#123;</span><br><span class="line">   <span class="keyword">val</span> proxy: Any</span><br><span class="line">      <span class="keyword">get</span>() = Proxy.newProxyInstance(<span class="keyword">this</span>.javaClass.classLoader, target.javaClass.interfaces, <span class="keyword">this</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Throws(Throwable::class)</span></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, *args)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是这种方式会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException: Parameter specified as non-<span class="literal">null</span> is <span class="literal">null</span>: method com.zhazha.test.proxy.ProxyInvocationHandler.invoke, parameter args</span><br><span class="line">	at com.zhazha.test.proxy.ProxyInvocationHandler.invoke(ProxyInvocationHandler.kt)</span><br><span class="line">	at com.sun.proxy.$Proxy0.sell(Unknown Source)</span><br><span class="line">	at com.zhazha.test.proxy.ProxyTestKt.main(ProxyTest.kt:<span class="number">7</span>)</span><br><span class="line">	at com.zhazha.test.proxy.ProxyTestKt.main(ProxyTest.kt)</span><br></pre></td></tr></table></figure>



<p>空指针？</p>
<p>注意这段： <code>NullPointerException: Parameter specified as non-null is null: method com.zhazha.test.proxy.ProxyInvocationHandler.invoke, parameter args</code></p>
<p>很多不想看英文的看到这行代码报错：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327420f32084419aa62bd39cd1676b0d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>然后以为是这边哪里函数参数或者返回值有空指针什么的。。。</p>
<p>结果忽视的最重要的信息</p>
<p>如果仔细看异常调用栈都能发现问题</p>
<p><code>parameter args at com.zhazha.test.proxy.ProxyInvocationHandler.invoke(ProxyInvocationHandler.kt)</code></p>
<p>明显底层是 invoke 方法报错了</p>
<p>也就是这个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(Throwable::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span>: Any &#123;</span><br><span class="line">   <span class="keyword">return</span> method.invoke(target, *args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而错误提示直指错误原因：</p>
<p> <code>NullPointerException: Parameter specified as non-null is null: method com.zhazha.test.proxy.ProxyInvocationHandler.invoke, parameter args</code></p>
<p>参数 <code>args</code> 是 <code>空的</code>，但实际被指定为 <code>non-null</code> 参数</p>
<p>需要将代码改成下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(Throwable::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;?)</span></span>: Any &#123;</span><br><span class="line">   <span class="keyword">return</span> method.invoke(target, *args!!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果发现又报错了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">	at com.zhazha.test.proxy.ProxyInvocationHandler.invoke(ProxyInvocationHandler.kt:<span class="number">13</span>)</span><br><span class="line">	at com.sun.proxy.$Proxy0.sell(Unknown Source)</span><br><span class="line">	at com.zhazha.test.proxy.ProxyTestKt.main(ProxyTest.kt:<span class="number">7</span>)</span><br><span class="line">	at com.zhazha.test.proxy.ProxyTestKt.main(ProxyTest.kt)</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> method.invoke(target, *args!!)</span><br></pre></td></tr></table></figure>



<p>这行报的错误</p>
<p>这里需要回到前面第四章节的内容 ： </p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0db59507480432aa27b1c7d1c4537bc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>所以我们可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(Throwable::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;?)</span></span>: Any &#123;</span><br><span class="line">   <span class="keyword">return</span> method.invoke(target, *(args ?: arrayOf()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者这样：</p>
<p><code>return method.invoke(target, *(args ?: emptyArray()))</code></p>
<p>但发现还是报错：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42201a1541a845729b76ef61b0855fa8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>啊这？ 巨坑好吧，说好的 <code>kotlin</code> 兼容 <code>java</code> 的么？可以无缝切换的呢？</p>
<p>这里如果不清楚为什么报错可以这样改代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(Throwable::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>, method: <span class="type">Method</span>, args: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;?)</span></span>: Any &#123;</span><br><span class="line">   <span class="keyword">val</span> any = method.invoke(target, *(args ?: emptyArray()))</span><br><span class="line">   println(any)</span><br><span class="line">   <span class="keyword">return</span> any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>你会发现 <code>any</code> 输出是 <code>null</code>， 为空了， 也是就是 <code>invoke</code> 调用的返回值为空，确实，前面的 <code>sell</code> 函数没有返回什么变量，只能是 <code>null</code> 的</p>
<p>但是 <code>invoke</code> 的返回类型却是 <code>Any</code> 不能为 <code>null</code></p>
<p>如果直接改成 <code>any!!</code> 就变成 <code>null!</code>! 又直接报错直接给你抛异常</p>
<p>含泪，改代码：把 <code>invoke</code> 返回值类型 <code>Any</code> 改成 <code>Any?</code> 完事</p>
<p>这里为什么可以改的原因是：<code>InvocationHandler</code> 接口的 <code>invoke</code> 是 <code>java</code> 类，<code>kotlin</code>使用 <code>java</code> 类默认时，参数和返回值都会被认为介于 <code>可空</code> 和 <code>不可空</code> 之间</p>
<p>之后就不会报错了</p>
<p>这里还有一个坑</p>
<p><code>InvocationHandler</code> 的 <code>public Object invoke(Object obj, Object... args)</code> 函数的 参数 <code>args</code> 是可变函数</p>
<p>在 <code>java</code> 中 数组和可变参数是一个东西：</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcfb542b029e4aea886fb61bf8b7c723~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" style="zoom:60%;" />



<p>但是在 <code>kotlin</code> 中不是</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632a740758d4438ab2ccedc3c0719668~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>从 <code>*args</code> 变成 <code>args</code> ，虽然 <code>IDE</code> 没有报错，但是在运行时报错了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: wrong number of arguments</span><br><span class="line">	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.base/java.lang.reflect.Method.invoke(Method.java:<span class="number">566</span>)</span><br><span class="line">	at com.zhazha.test.proxy.ProxyInvocationHandler.invoke(ProxyInvocationHandler.kt:<span class="number">13</span>)</span><br><span class="line">	at com.sun.proxy.$Proxy0.sell(Unknown Source)</span><br><span class="line">	at com.zhazha.test.proxy.ProxyTestKt.main(ProxyTest.kt:<span class="number">7</span>)</span><br><span class="line">	at com.zhazha.test.proxy.ProxyTestKt.main(ProxyTest.kt)</span><br></pre></td></tr></table></figure>



<p>报参数数量错误。。。 emmm</p>
<p>真的恶心</p>
<p>kotlin 的数组真的是败笔</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bangiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bangiao.github.io/2022/12/03/07kotlin/十、kotlin的注解和反射/">https://bangiao.github.io/2022/12/03/07kotlin/十、kotlin的注解和反射/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B3%A8%E8%A7%A3/">注解</a><a class="post-meta__tags" href="/tags/%E5%8F%8D%E5%B0%84/">反射</a><a class="post-meta__tags" href="/tags/KClass/">KClass</a><a class="post-meta__tags" href="/tags/KCallable/">KCallable</a><a class="post-meta__tags" href="/tags/KFuntion/">KFuntion</a><a class="post-meta__tags" href="/tags/KProperty/">KProperty</a><a class="post-meta__tags" href="/tags/%E6%B3%A8%E8%A7%A3%E7%9B%AE%E6%A0%87/">注解目标</a><a class="post-meta__tags" href="/tags/setparam/">setparam</a><a class="post-meta__tags" href="/tags/delegate/">delegate</a><a class="post-meta__tags" href="/tags/receiver/">receiver</a><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB/">动态代理类</a><a class="post-meta__tags" href="/tags/%E5%9D%91/">坑</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/12/03/07kotlin/%E5%8D%81%E4%B8%80%E3%80%81kotlin%E7%9A%84%E5%8D%8F%E7%A8%8B(%E4%BA%8C)%E2%80%94%E2%80%94%E5%86%B7%E6%B5%81flow/"><i class="fa fa-chevron-left">  </i><span>十一、kotlin的协程(二)——冷流flow</span></a></div><div class="next-post pull-right"><a href="/2022/12/03/07kotlin/%E4%B9%9D%E3%80%81kotlin%E7%9A%84%E6%B3%9B%E5%9E%8B/"><span>九、kotlin的泛型</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2023 By Bangiao</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这是博客github仓库地址：<a target="_blank" rel="noopener" href="https://github.com/bangiao/bangiao.github.io">bangiao.github.io</a>，欢迎访问!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>