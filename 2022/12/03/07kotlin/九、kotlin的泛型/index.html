<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="九、kotlin的泛型"><meta name="keywords" content="in,泛型,类型擦除,实化类型,reified,协变,逆变,convariant,contravariant,out,星号投影"><meta name="author" content="Bangiao"><meta name="copyright" content="Bangiao"><title>九、kotlin的泛型 | Bangiao's Notebooks</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B-%E5%87%BD%E6%95%B0-%E5%8F%82%E6%95%B0-%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简单示例: 函数, 参数, 属性和类的泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F-T-Integer"><span class="toc-number">1.2.</span> <span class="toc-text">泛型约束(T : Integer)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">主要内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">为一个泛型添加多个约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%B8%BA-null-%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%B8%BA-non-null"><span class="toc-number">1.3.</span> <span class="toc-text">泛型类型可以为 null 也可以为 non-null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%92%8C%E5%AE%9E%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">泛型运行时的类型擦除和实化类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">主要内容:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0-reified-T"><span class="toc-number">1.4.2.</span> <span class="toc-text">实化类型参数 reified T</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E5%9E%8B-%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text">变型: 泛型和子类型关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">类、类型和子类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">类和类型的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">子类型关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98"><span class="toc-number">1.6.</span> <span class="toc-text">协变和逆变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98-covariant"><span class="toc-number">1.6.1.</span> <span class="toc-text">协变(covariant)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1. 是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">java泛型类型擦除带来的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E6%B3%9B%E5%9E%8B%E5%AF%B9%E4%BA%8E%E2%80%9D%E6%B6%88%E5%A4%B1%E7%9A%84%E5%8D%8F%E5%8F%98%E5%85%B3%E7%B3%BB%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">java泛型对于”消失的协变关系”的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E4%BA%8E-kotlin-%E7%9A%84%E5%8D%8F%E5%8F%98%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">对应于 kotlin 的协变关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%A4%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%8D%8F%E5%8F%98"><span class="toc-number">1.6.1.4.1.</span> <span class="toc-text">类处类型参数的协变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A4%84%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98"><span class="toc-number">1.6.1.4.2.</span> <span class="toc-text">函数处集合泛型的协变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8F%98-contravariant-%E7%9B%B8%E5%8F%8D%E7%9A%84%E5%AD%90%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">逆变(contravariant): 相反的子类关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kotlin-%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">kotlin 中的逆变</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E9%80%86%E5%8F%98"><span class="toc-number">1.6.2.1.1.</span> <span class="toc-text">类的泛型参数逆变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0%E6%B3%9B%E5%9E%8B%E9%80%86%E5%8F%98"><span class="toc-number">1.6.2.1.2.</span> <span class="toc-text">函数集合参数泛型逆变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.3.</span> <span class="toc-text">协变逆变的总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98%E5%86%99%E4%B8%AA-copyData-%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">使用协变和逆变写个 copyData 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%AD-out-%E5%92%8C-in-%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.6.4.</span> <span class="toc-text">泛型类中 out 和 in 的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%9F%E5%8F%B7%E6%8A%95%E5%BD%B1-%E4%BD%BF%E7%94%A8-%E4%BB%A3%E6%9B%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.5.</span> <span class="toc-text">星号投影: 使用 * 代替类型参数</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://imgsa.baidu.com/forum/pic/item/c8179682d158ccbf63dc944d1bd8bc3eb03541a9.jpg"></div><div class="author-info__name text-center">Bangiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/bangiao">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">72</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">638</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的博客</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/4248168662314823">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30690165">CSDN</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/bangiao/">博客园</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/projects">Gitee笔记源码</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bangiao's Notebooks</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章列表</a><a class="site-page" href="/tags">文章标签</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/sources">笔记源码</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">九、kotlin的泛型</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p><code>kotlin</code>的泛型基础和 <code>java</code> 很像, 所以我建议学习 <code>kotlin</code> 的泛型前, 先去学习下 <code>java</code> 的泛型, 至少搞懂通配符, <code>&lt;? extends X&gt;</code> 和  <code>&lt;? super X&gt;</code> 是怎么回事, 怎么写 泛型函数, 泛型类, 知道泛型的本质是什么?</p>
</blockquote>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><blockquote>
<p>泛型: 将类型当作参数传递到类内</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>泛型</th>
</tr>
</thead>
<tbody><tr>
<td><code>fun funName(参数)</code></td>
<td><code>class ClassName&lt;类型&gt;</code></td>
</tr>
<tr>
<td>传递给函数</td>
<td>传递给对象</td>
</tr>
</tbody></table>
<p>我们需要将类型当作参数传递给对象, 传递的类型可能会被用于定义属性或者用于函数的泛型参数</p>
<p>需要注意:</p>
<blockquote>
<p>参数有可变参数 <code>vararg</code> 泛型也是, 可以传递泛型的子类类型</p>
</blockquote>
<h2 id="简单示例-函数-参数-属性和类的泛型"><a href="#简单示例-函数-参数-属性和类的泛型" class="headerlink" title="简单示例: 函数, 参数, 属性和类的泛型"></a>简单示例: 函数, 参数, 属性和类的泛型</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">print</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">   println(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericsDemo01</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> f: T) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">      println(t)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型约束-T-Integer"><a href="#泛型约束-T-Integer" class="headerlink" title="泛型约束(T : Integer)"></a>泛型约束(<code>T : Integer</code>)</h2><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><blockquote>
<ol>
<li>缩小类型的范围</li>
<li>一个约束 <code>T : Integer</code>  &#x3D;&#x3D;&gt; <code>T extends Integer</code></li>
<li>多个约束 <code>T where T: XXX, T: YYY</code> &#x3D;&#x3D;&gt; <code>T extends CharSequence &amp; Appendable</code></li>
</ol>
</blockquote>
<p>很多时候我们需要将泛型的类型约束在某个界限, 比如: sum函数的泛型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">sum</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 <code>a</code> 和 参数 <code>b</code> 并不是什么类型都支持 <code>+</code> 这项操作, 所以我们需要对传入的类型参数(泛型)做限制, 像下面这样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Integer&gt;</span> <span class="title">sum</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样操作类似于 java 的 <code>&lt;T extends Integer&gt;</code> , 限定 <code>T</code> 必须继承 <code>Integer</code>(或者说<code>T</code>必须是<code>Integer</code>的子类). </p>
<blockquote>
<p><strong>java 的<code>&lt;T extends Integer&gt;</code> 用于集合的泛型, 而泛型约束通常用于非集合的泛型, 因为集合泛型已经有 协变和逆变 的约束了, 不需要这一章的泛型约束</strong></p>
</blockquote>
<p>对的, 这样做就不会出现传入俩 <code>Any 类型</code>的 <code>a</code> 和 <code>b</code> 做加法运算符这样尴尬的事情</p>
<blockquote>
<p>泛型约束不会像集合泛型约束那样严格控制 <code>T</code> 必须是同一个, 你可以这样使用: </p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Number&gt;</span> <span class="title">printT</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">// a = 9999, b = 100.5</span></span><br><span class="line">   println(<span class="string">&quot;a = <span class="variable">$a</span>, b = <span class="variable">$b</span>&quot;</span>)</span><br><span class="line">   <span class="comment">// aClass = class java.lang.Integer, bClass = class java.lang.Double</span></span><br><span class="line">   println(<span class="string">&quot;aClass = <span class="subst">$&#123;a.javaClass&#125;</span>, bClass = <span class="subst">$&#123;b.javaClass&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   printT(<span class="number">9999</span>, <span class="number">100.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>a: T, b: T</code> 中的 <code>T</code> 是两个不一样的类型, 一个是 <code>Integer</code>, 另一个是 <code>Double</code></p>
<p>上面那段代码类似于 java 的这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">printT</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">   System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">   System.out.println(a.getClass());</span><br><span class="line">   System.out.println(b.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   printT(<span class="number">10</span>, <span class="number">20.1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>课外: 突然发现 不知道 泛型如何 写 sum 了, 所以想了下, 好像只能使用反射来实现</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">sum</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">   <span class="keyword">val</span> clazz = a.javaClass</span><br><span class="line">   <span class="keyword">val</span> sum = clazz.declaredMethods.firstOrNull &#123; it.name == <span class="string">&quot;sum&quot;</span> &#125; ?: <span class="keyword">throw</span> Exception(<span class="string">&quot;can&#x27;t find function. T not is a subclass of Number&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> sum.invoke(a, a, b) <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小笔记: 在反射获取 <code>sum</code> 函数时, 发现它的函数签名是: <code>int sum(int, int)</code> 但是我们<code>a: T</code> 类型的 <code>T</code> 会被认为是 <code>Integer</code>(泛型只能是<code>Integer</code>), 而获取 <code>sum</code> 却需要 <code>int</code> 比较麻烦, 最后发现 <code>Integer.TYPE</code> 是拆包类型<code>int</code> 可以考虑从这里下手</p>
</blockquote>
<h3 id="为一个泛型添加多个约束"><a href="#为一个泛型添加多个约束" class="headerlink" title="为一个泛型添加多个约束"></a>为一个泛型添加多个约束</h3><p><code>where</code> 类似于 <code>sql</code> 语句的 <code>where</code> 一样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">ensureTrailingPeriod</span><span class="params">(seq: <span class="type">T</span>)</span></span>: T <span class="keyword">where</span> T : CharSequence, T : Appendable &#123;</span><br><span class="line">   <span class="keyword">if</span> (!seq.endsWith(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">      seq.append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> seq</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>约束的好处不仅仅是让我们知道我们需要的类必须是约束和约束的子类. 同时还会让我们的 <code>T</code> 多出很多约束类的函数(包括扩展函数等)</p>
</blockquote>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a2deccb6904706b201c74d7503a5c2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p><code>endsWith</code> 函数是 <code>CharSequence</code> 的扩展函数, <code>append</code> 是 <code>Appendable</code> 接口的函数</p>
</blockquote>
<p>前面的 <code>sum</code> 函数也是</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2143518bf7c3470d9d11a59fdfafa589~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>java中也允许多约束泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">CharSequence</span> &amp; Appendable&gt; T <span class="title function_">ensureTrailingPeriod</span><span class="params">(T seq)</span></span><br></pre></td></tr></table></figure>



<h2 id="泛型类型可以为-null-也可以为-non-null"><a href="#泛型类型可以为-null-也可以为-non-null" class="headerlink" title="泛型类型可以为 null 也可以为 non-null"></a>泛型类型可以为 null 也可以为 non-null</h2><p>泛型的类型<code>T</code>类似于<strong>平台类型</strong>, <strong>是否为空由程序员决定, kotlin 不再进行可空管理, 程序员认为他是 可空类型 它就是可空类型, 程序员认为它非空类型, 它就是非空类型</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">print</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">   t?.let &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型运行时的类型擦除和实化类型"><a href="#泛型运行时的类型擦除和实化类型" class="headerlink" title="泛型运行时的类型擦除和实化类型"></a>泛型运行时的<strong>类型擦除</strong>和<strong>实化类型</strong></h2><h3 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容:"></a>主要内容:</h3><blockquote>
<ol>
<li>类型擦除 和 java 一样(妥妥的糟粕, 给整过来了)</li>
<li>实化类型: 用于 <code>is T</code> 和 <code>T::class.java</code></li>
</ol>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">isIntList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (list <span class="keyword">is</span> List&lt;<span class="built_in">Int</span>&gt;) &#123; <span class="comment">// 这里报错</span></span><br><span class="line">      println(<span class="string">&quot;这是错误的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">   isIntList(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8f46affafc41b5b713d05a69d573b1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>但是可以这样: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">is</span> List&lt;*&gt;)</span><br></pre></td></tr></table></figure>



<p>可以看出, 泛型被类型擦除为 <code>List&lt;Any?&gt;</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">isIntList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (list <span class="keyword">is</span> List&lt;Any?&gt;) &#123; <span class="comment">// 这样不会报错</span></span><br><span class="line">      println(<span class="string">&quot;不会报错了&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>kotlin 编译器可以判断在同一个作用域内的泛型类型</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">is</span> List&lt;<span class="built_in">Int</span>&gt;) &#123;</span><br><span class="line">    println(<span class="string">&quot;这样是可以的&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这种情况也会出现问题</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07998b3db7ef465fb9d1e7fb55704e80~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="实化类型参数-reified-T"><a href="#实化类型参数-reified-T" class="headerlink" title="实化类型参数 reified T"></a>实化类型参数 <code>reified T</code></h3><p>在运行期间, 类型被当作 <code>Any?</code> 类型, 但它想被强制转换成 <code>T</code> 类型明显是不行的, 这种情况下, 可以考虑使用 <code>inline</code> 和 <code>reified</code> 配合实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isIntList</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (list <span class="keyword">is</span> List&lt;T&gt;) &#123; <span class="comment">// 这里不会报错</span></span><br><span class="line">      println(<span class="string">&quot;不会报错&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同样的我们调用 <code>is T</code> 也不会报错了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isA</span><span class="params">(value: <span class="type">Any</span>)</span></span> = value <span class="keyword">is</span> T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line">   println(isA&lt;<span class="built_in">Int</span>&gt;(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>前面我们学过,  <code>inline</code> 内联的话, 会把代码拷贝到所有调用的地方, 使用上面这种方式<strong>kotlin编译器在<code>运行期间</code>可以识别到泛型的类型</strong></p>
<blockquote>
<p><code>inline</code> 在之前的章节中是为了提高性能, 消除<code>lambda</code>参数带来的副作用对象而使用的, 在本章节是为了<strong>实化类型</strong>, 这是第二个<code>inline</code> 的使用场景</p>
</blockquote>
<p>实例化参数的另一种使用场景是, 将 类型做参数传递后, 借助该类型获取 <code>Class</code> 类对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">loadService</span><span class="params">()</span></span>: ServiceLoader&lt;T&gt;? &#123;</span><br><span class="line">   <span class="keyword">return</span> ServiceLoader.load(T::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 以前需要在参数上多一个传递 Class 的参数, 现在不需要了</span></span><br><span class="line">   <span class="comment">// val loadService = loadService(Int::class)</span></span><br><span class="line">   <span class="keyword">val</span> loadService = loadService&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>以前需要在参数上多一个传递 Class 的参数, 现在不需要了</p>
</blockquote>
<h2 id="变型-泛型和子类型关系"><a href="#变型-泛型和子类型关系" class="headerlink" title="变型: 泛型和子类型关系"></a>变型: 泛型和子类型关系</h2><h3 id="类、类型和子类型"><a href="#类、类型和子类型" class="headerlink" title="类、类型和子类型"></a>类、类型和子类型</h3><h4 id="类和类型的区别"><a href="#类和类型的区别" class="headerlink" title="类和类型的区别"></a>类和类型的区别</h4><p>在很多情况下, 类都可以大体上当作类型, 但实际上, 类和类型不是一个东西就比如: 空类型和非空类型, <code>Int</code> 和 <code>Int?</code> , 请确认下 <code>Int?</code> 是类么?? 不是 那<code>Int?</code> 是类型么? 明显,是类型</p>
<p>又或者: <code>List</code>是个类而 <code>List&lt;T&gt;</code> 它又是个类型, 且他的类型有很多, 比如: <code>List&lt;Int&gt;</code> <code>List&lt;Double&gt;</code> <code>List&lt;Long&gt;</code> 等, 这些都是<strong>类型</strong>, 而<code>List</code> 是<strong>类</strong></p>
<h4 id="子类型关系"><a href="#子类型关系" class="headerlink" title="子类型关系"></a>子类型关系</h4><blockquote>
<p>子类型说的是一种 <strong>父子关系</strong> , 这种关系在 java 的类, java 的数组里存在, 而在 java 的泛型里却不见了</p>
</blockquote>
<p>(<strong>书本上的内容, 看不懂看下面</strong>)任何时候如果<strong>需要的是</strong>类型 A 的值，你都能够使用类型 B 的值当作 A 使用 ， 类型 B 就称为类型 A 的子类型。</p>
<blockquote>
<p>说简单点, <strong>A类指针(java叫引用)指向B类对象, 那么就可以说 A 的子类型是 B, 就这么简单(<code>val a: A = B()</code>)</strong></p>
</blockquote>
<p>比如: 现在有个引用 <code>val a: Number</code>和一个<code>Int</code>类型的对象<code>10</code>, 如果引用能够直接指向对象<code>val a: Number = 10</code> 则可以说 <code>Int</code> 是 <code>Number</code> 的<strong>子类型</strong>, 而同时我们可以说 <code>Number</code> 是 <code>Int</code> 的<strong>超类型</strong></p>
<blockquote>
<p>简单点: 子类的<strong>超类型</strong>是父类, 父类的<strong>子类型</strong>是子类, 只要记住这种关系就好</p>
</blockquote>
<h2 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h2><blockquote>
<p>高端的概念总会有落地的实现, 我们学习要达到的程度是用最简单的一句话描述这些概念</p>
</blockquote>
<blockquote>
<p>在生活中, 越宽的桶能够盛放越多的水, 越小的桶能够盛放越少的水, 而我们的类型也是, Any? 是 kotlin 中最宽泛的水桶, 它既能够存放非空的所有对象, 也能够存放可空的所有kotlin对象, 这就是多态的根本, 也是协变和逆变的根本</p>
</blockquote>
<h3 id="协变-covariant"><a href="#协变-covariant" class="headerlink" title="协变(covariant)"></a>协变(covariant)</h3><h4 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么?"></a>1. 是什么?</h4><p>协变: <strong>是一种关系, 一种父类引用 指向 子类对象 的关系</strong></p>
<ul>
<li><p><code>Number</code> 引用总能够指向 <code>Int</code> 对象, 那么 <code>Number</code> 的子类型是 <code>Int</code> , 则 <code>Number</code> 和 <code>Int</code> 是协变的</p>
</li>
<li><p>那么同样的 <code>Number[]</code> 引用 总能够 指向 <code>Int[]</code> , 则 <code>Number[]</code> 和 <code>Int[]</code> 是协变的</p>
</li>
<li><p>同样的,  <code>List&lt;Number&gt;</code> 的引用总能够 指向 <code>List&lt;Int&gt;</code> 那么我们也能够说: <code>List&lt;Number&gt;</code> 和 <code>List&lt;Int&gt;</code> 有协变关系(但<strong>在java中失效了</strong>)</p>
</li>
</ul>
<p>但, java 因为历史关系, 使用了类型擦除技术, 所以 任何类型变到泛型的话, 就不会有所谓的协变(逆变)关系, 因为到了运行时期 java 总把类型变成 <code>List&lt;Object&gt;</code> 或者 直接是 <code>List</code> 类型, 如果强制开出协变关系, 则会出现一些安全问题</p>
<h4 id="java泛型类型擦除带来的问题"><a href="#java泛型类型擦除带来的问题" class="headerlink" title="java泛型类型擦除带来的问题"></a>java泛型类型擦除带来的问题</h4><blockquote>
<p>会出现 哥哥 泛型的水桶, 被jvm拿走忘了只能装哥哥了, 装了个 弟弟 泛型类型的对象, 这明显不对, 我的水桶要的只能是 哥哥 或者 哥哥的子类, 最最重要的是 jvm 记性还不好(类型擦除), 会把所有装XXX的水桶, 记成水桶里什么东西都能装</p>
</blockquote>
<p>泛型在存在协变关系的数组中, 可以正确的判断出错误: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">2</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1000</span>;</span><br><span class="line">Object[] o = a;</span><br><span class="line">o[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 这里会报错 java.lang.ArrayStoreException: java.lang.Character   </span></span><br></pre></td></tr></table></figure>

<p><strong>Integer 引用想指向没有子类型关系的 Character对象, 直接报错</strong></p>
<p>如果把上面的数组完全换成集合就会变成如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">1000</span>);</span><br><span class="line">List&lt;Object&gt; objList = list; <span class="comment">// 父类引用指向子类对象, 按理来说 没错 object --&gt; Integer(但实际上这里不会编译通过的)</span></span><br><span class="line">objList.add(<span class="number">10.9</span>); <span class="comment">// 这里在运行期间将会编译通过, 运行通过, 因为还是 父类引用指向子类的对象, object --&gt; double</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddc518f3050b46af831f65d5289667db~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>对比下有协变的数组:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb24d31041d847c8be429f143f982da1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这种泛型和数组的不一致就表示泛型不存在协变关系</p>
<blockquote>
<p>为了解决上面的问题, java 引入了属于 java 的<strong>泛型的协变</strong></p>
</blockquote>
<h4 id="java泛型对于”消失的协变关系”的解决方案"><a href="#java泛型对于”消失的协变关系”的解决方案" class="headerlink" title="java泛型对于”消失的协变关系”的解决方案"></a>java泛型对于”消失的协变关系”的解决方案</h4><blockquote>
<p>协变关系, 又有人叫 <code>子类型关系</code></p>
</blockquote>
<p>java 引入了 通配符<code>?</code>, 然后用 <code>List&lt;? extends Number&gt;</code> 表示协变, 相当于<strong>没有类型擦除</strong>的 <code>List&lt;Number&gt;</code>, 接受<code>Number</code>及<code>Number</code>的子类存入<code>List&lt;Number&gt;</code> 集合中</p>
<p>所以 <code>List&lt;? extends Number&gt;</code> 集合可以存入 </p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d602caba0e1468fbedfb959ded1bef9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>上面这些类的对象</p>
<blockquote>
<p>那么他是如何解决的上面那个问题的呢? </p>
</blockquote>
<p>答: java 的解决方法很简单, 一刀切, 如果<strong>类型是 <code>&lt;? extends Number&gt;</code> 协变的, 那么他就不允许写入, 修改等操作. 只允许读取</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d6302c4e9db49dc936469ae4cab808b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p> 我特么, 解决不了问题, 就解决提出问题的人是吧???</p>
</blockquote>
<blockquote>
<p>小总结: <code>List&lt;? extends Number&gt;</code> 不好记里面可以存放什么类, 可以直接认为是 支持协变的 <code>List&lt;Number&gt;</code> 理解就好了, 支持协变的话, <code>Number</code> 集合可以存入它和它的子类</p>
</blockquote>
<blockquote>
<p>当然我们也可以认为<code>?</code>就是我们写的类, <code>class ? extends Number &#123;&#125;</code> 表示写了个<code>Number</code>的子类, 意味着<code>?</code>是子类, 所以<code>?</code>表示所有的子类</p>
</blockquote>
<h4 id="对应于-kotlin-的协变关系"><a href="#对应于-kotlin-的协变关系" class="headerlink" title="对应于 kotlin 的协变关系"></a>对应于 <code>kotlin</code> 的协变关系</h4><p>在 <code>kotlin</code> 中, 协变将会是:<br><strong>1. 在类处类型参数协变</strong><br><strong>2. 在函数处集合泛型的协变</strong></p>
<h5 id="类处类型参数的协变"><a href="#类处类型参数的协变" class="headerlink" title="类处类型参数的协变"></a>类处类型参数的协变</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> : T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>out</code> 放在那里的位置, 主要有两个功能:</p>
<ul>
<li>子类型将会被保留(<code>Producer&lt;Cat&gt;</code>是<code>Producer&lt;Animal&gt;</code>的子类)</li>
<li><code>T</code> 只能用在 <code>out</code> 位置</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5b8f26e7a9f43f0a3d1927a60b3841b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p><code>in</code> 的位置在函数参数, <code>out</code> 位置在函数返回值, 既是<code>in</code>又是<code>out</code>则不需要标记, 同样的 <code>out</code> 标记的泛型只能读取, 不能写入, <code>in</code>标记的泛型只能写入不能读取(和<code>java</code>优点不太一样???)</p>
</blockquote>
<blockquote>
<p>上面的<code>transform</code>函数, 参数明显是范围越大越好, 所以使用 <code>? super Number</code>也就是<code>kotlin</code>中的<code>in T</code>, 而通过函数<code>transform</code>函数处理之后返回的范围应该越小越好, 所以使用<code>? extends Number</code> 也就是<code>out T</code></p>
</blockquote>
<ol>
<li><code>MutableList</code>不能使用<code>out</code>, 因为<code>out</code>只能往外输出(读取)对象而不能往里写入对象, 但<code>MutableList</code>可以写入可以读取, 明显矛盾</li>
<li>协变后的集合不允许写入, 只允许读取</li>
<li>协变的<code>out B</code>表示只能填入<code>B</code>或者<code>B的子类</code></li>
</ol>
<h5 id="函数处集合泛型的协变"><a href="#函数处集合泛型的协变" class="headerlink" title="函数处集合泛型的协变"></a>函数处集合泛型的协变</h5><p>和 java 类似的用法</p>
<p><code>out T</code> 对应了 java 的 <code>? extends T</code></p>
<p><code>in T</code> 对应了 java 的 <code>? super T</code></p>
<p>我们使用下面的代码来了解<code>协变</code>的一些特性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">B</span> : <span class="type">A</span>()</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">C</span> : <span class="type">B</span>()</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">D</span> : <span class="type">C</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先协变<code>out B</code>可以看作是<code>? extends B</code>也就是所谓的<code>上界</code>, 说白了只能接受<code>B</code>以及<code>B</code>的子类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l0: ArrayList&lt;<span class="keyword">out</span> B&gt; = arrayListOf(B(), C(), D())</span><br><span class="line"><span class="comment">// 但如果我们加添 B 的父类 A 对象试试</span></span><br><span class="line"><span class="keyword">val</span> l1: ArrayList&lt;<span class="keyword">out</span> B&gt; = arrayListOf(A(), B(), C(), D()) <span class="comment">// error</span></span><br><span class="line"><span class="comment">// 这里就会报错, 无法添加高于B的对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然可以这么写, 但最好别这么用, 协变在调用函数传参的时候才能得到充分的体现</p>
</blockquote>
</li>
<li><p>协变无法添加元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> l0: ArrayList&lt;<span class="keyword">out</span> B&gt; = arrayListOf(B())</span><br><span class="line">l0.add(C()) <span class="comment">// error, 无法再次添加对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>再次声明: <code>val l0: ArrayList&lt;out B&gt; = arrayListOf(B())</code> 虽然运行这么写, 但最好不要这么用</p>
</blockquote>
</li>
<li><p>看下面的<code>f1</code>和<code>f2</code>函数</p>
</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c2dd47355f240368f25c89c6f8992da~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>但是可以这么传递:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5771a1bbb7c430b9024a5a159e78af4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="逆变-contravariant-相反的子类关系"><a href="#逆变-contravariant-相反的子类关系" class="headerlink" title="逆变(contravariant): 相反的子类关系"></a>逆变(<code>contravariant</code>): 相反的子类关系</h3><p>正常情况下, <code>Animal</code> 是 <code>Cat</code> 的父类, <code>Animal</code> 的子类型是 <code>Cat</code> , <code>List&lt;Animal&gt;</code>也是<code>List&lt;Cat&gt;</code>的子类型, 这是<strong>协变</strong>, 但如果 <code>List&lt;Cat&gt;</code>是<code>List&lt;Animal&gt;</code>的子类型的话, 这种<strong>子类型关系逆反</strong>了, 这就是<strong>逆变</strong></p>
<blockquote>
<p>研究逆变需要了解两个步骤</p>
<ul>
<li><p><strong>初始化阶段</strong></p>
<p>初始化阶段<code>List&lt;in Cat&gt;</code> 可以看作是<code>Any</code>类型 </p>
</li>
<li><p><strong>使用阶段</strong></p>
<p>在使用的时候, <code>in Cat</code>变成了<code>List&lt;Cat&gt;</code></p>
</li>
</ul>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f8d2b506bc144e79d5ecbf3c1576f4b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e718b43c9e420bb1f14103caab0f5a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="kotlin-中的逆变"><a href="#kotlin-中的逆变" class="headerlink" title="kotlin 中的逆变"></a>kotlin 中的逆变</h4><p>同样的 kotlin 支持:<br><strong>1. 类的泛型参数逆变</strong><br><strong>2. 函数集合参数泛型逆变</strong></p>
<h5 id="类的泛型参数逆变"><a href="#类的泛型参数逆变" class="headerlink" title="类的泛型参数逆变"></a>类的泛型参数逆变</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数集合参数泛型逆变"><a href="#函数集合参数泛型逆变" class="headerlink" title="函数集合参数泛型逆变"></a>函数集合参数泛型逆变</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ca42ab0ca2840149e2ced92bde8efba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>逆变在调用函数并传参的时候得到体现, 而在使用逆变后的对象添加参数时, 又恢复了 父类指针指向子类对象的赋值兼容性原则</p>
<h3 id="协变逆变的总结"><a href="#协变逆变的总结" class="headerlink" title="协变逆变的总结"></a>协变逆变的总结</h3><p>父类 &#x3D;&#x3D;&gt; 当前类 &#x3D;&#x3D;&gt; 当前类子类</p>
<p>​        |–&gt;   👆       –&gt;</p>
<p>​        👆 这里就是上界的边界</p>
<blockquote>
<p>协变: 规定了泛型(类型)上界(上边界), 该上限限定了只能传递某个类型及该类型的子类()</p>
</blockquote>
<p>父类 &#x3D;&#x3D;&gt;   当前类   &#x3D;&#x3D;&gt;   当前类子类</p>
<p>Any –&gt;  👆 &lt;–|</p>
<p>​               👆 这里就是下界的边界</p>
<blockquote>
<p>逆变: 规定了下界(下边界), 规定了只能传递某个类型及该类型的父类</p>
</blockquote>
<blockquote>
<p>在 kotlin 中, 如果泛型被标记为 <code>out</code>, 则该泛型只能调用符合泛型 <code>out</code> 位置的函数, 比如<code>fun get() : T</code>, 如果泛型被标记为 <code>in</code>, 那么只能调用该类的复合 <code>in</code> 位置的函数比如: <code>fun add(t: T): void</code></p>
</blockquote>
<blockquote>
<p><code>out</code> 协变, 只读, <code>in</code> 逆变, 能读写</p>
</blockquote>
<h4 id="使用协变和逆变写个-copyData-函数"><a href="#使用协变和逆变写个-copyData-函数" class="headerlink" title="使用协变和逆变写个 copyData 函数"></a>使用协变和逆变写个 <code>copyData</code> 函数</h4><ol>
<li>普通方式实现该函数</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyData01</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">      destination.add(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用约束的方式实现该函数</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * T 是 R 的子类或者 T 就是 R,  记作: T &lt;= R</span></span><br><span class="line"><span class="comment"> * 所以 source: MutableList&lt;T&gt; 是子类集</span></span><br><span class="line"><span class="comment"> * destination: MutableList&lt;R&gt; 是父类集</span></span><br><span class="line"><span class="comment"> * 把子类集source的 item 依次给 父类集的 destination</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : R, R&gt;</span> <span class="title">copyData02</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">R</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">      <span class="comment">// T 是子类(source)</span></span><br><span class="line">      <span class="comment">// R 是父类(destination)</span></span><br><span class="line">      <span class="comment">// R ==&gt; T   父类 指向 子类</span></span><br><span class="line">      <span class="comment">// destination ==&gt; source  父类 指向 子类</span></span><br><span class="line">      destination.add(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式不好左区分, 到底哪个是父类, 哪个是子类, 哪个是输出, 哪个是输入</p>
</blockquote>
<ol start="3">
<li>使用协变的方式实现函数</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对读取函数使用 out 泛型修饰符</span></span><br><span class="line"><span class="comment"> * out T 表示 T 或者 T 的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyData03</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">      destination.add(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * in T: T 的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyData04</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">      destination.add(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面这就是声明处变型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyData05</span><span class="params">(source: <span class="type">MutableList</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">      destination.add(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List 本身就是只读的, 所以看 List 源码的话会看到 public interface List&lt;out E&gt; 这段代码</span></span><br><span class="line"><span class="comment"> * 看到 out E 了么?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyData06</span><span class="params">(source: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, destination: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">      destination.add(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>source: MutableList&lt;out T&gt;, destination: MutableList&lt;in T&gt;</code> 这种方式能够很明显的发现哪个是输出, 哪个是输入</p>
</blockquote>
<h3 id="泛型类中-out-和-in-的位置"><a href="#泛型类中-out-和-in-的位置" class="headerlink" title="泛型类中 out 和 in 的位置"></a>泛型类中 <code>out</code> 和 <code>in</code> 的位置</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5b8f26e7a9f43f0a3d1927a60b3841b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><code>kotlin</code> 支持在 类声明 处定义泛型的 变型 , 也支持像 java 一样在 函数位置写上 变型 </p>
<h3 id="星号投影-使用-代替类型参数"><a href="#星号投影-使用-代替类型参数" class="headerlink" title="星号投影: 使用 * 代替类型参数"></a>星号投影: 使用 <code>*</code> 代替类型参数</h3><ol>
<li>星号投影不清楚存入的类型到底是哪个, 所以一般不做写入, 仅作读取</li>
</ol>
<p>所以功能上类似于 <code>List&lt;out Any?&gt;</code>, 在没有任何类型信息的情况下,  <code>Any</code> 是最好的选择</p>
<ol start="2">
<li>使用星号投影的, 说明开发者并不需要知道读取出来的泛型具体是什么类型</li>
</ol>
<blockquote>
<p>说白一点, 星号投影把它当作 <code>out Any?</code> 吧, 读取出来的对象当作 <code>Any?</code> 对象就行, 不能写入</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bangiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bangiao.github.io/2022/12/03/07kotlin/九、kotlin的泛型/">https://bangiao.github.io/2022/12/03/07kotlin/九、kotlin的泛型/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/in/">in</a><a class="post-meta__tags" href="/tags/%E6%B3%9B%E5%9E%8B/">泛型</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/">类型擦除</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E5%8C%96%E7%B1%BB%E5%9E%8B/">实化类型</a><a class="post-meta__tags" href="/tags/reified/">reified</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E5%8F%98/">协变</a><a class="post-meta__tags" href="/tags/%E9%80%86%E5%8F%98/">逆变</a><a class="post-meta__tags" href="/tags/convariant/">convariant</a><a class="post-meta__tags" href="/tags/contravariant/">contravariant</a><a class="post-meta__tags" href="/tags/out/">out</a><a class="post-meta__tags" href="/tags/%E6%98%9F%E5%8F%B7%E6%8A%95%E5%BD%B1/">星号投影</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/12/03/07kotlin/%E5%8D%81%E3%80%81kotlin%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"><i class="fa fa-chevron-left">  </i><span>十、kotlin的注解和反射</span></a></div><div class="next-post pull-right"><a href="/2022/12/03/07kotlin/%E5%85%AB%E3%80%81kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"><span>八、kotlin的高阶函数</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2023 By Bangiao</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这是博客github仓库地址：<a target="_blank" rel="noopener" href="https://github.com/bangiao/bangiao.github.io">bangiao.github.io</a>，欢迎访问!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>