<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="十一、kotlin的协程(一)"><meta name="keywords" content="异步,协程,无栈协程,有栈协程,调度,挂起函数,suspend,runBlocking,协程作用域,等待协程结束,job,结构化并发,coroutineScope,协程取消,协程超时,NonCancellable,超时取消,组合挂起函数,async,异步结构化并发,协程上下文调度器,调度器,协程上下文,线程,协程和线程的区别,线程池,非受限调度器,受限调度器,调试协程,idea插件调试,日志,子协程,协程取名,协程上下文继承,线程本地数据,拦截器"><meta name="author" content="Bangiao"><meta name="copyright" content="Bangiao"><title>十一、kotlin的协程(一) | Bangiao's Notebooks</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%89%8D%E6%8F%90"><span class="toc-number">1.</span> <span class="toc-text">学习的前提</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">协程是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">协程的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%8C%89%E7%85%A7%E6%9C%89%E6%A0%88%E5%92%8C%E6%97%A0%E6%A0%88%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">协程按照有栈和无栈分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9D%83%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.2.</span> <span class="toc-text">按照调度的控制权分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B-%E6%88%96%E8%80%85%E8%AF%B4%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.</span> <span class="toc-text">为什么使用协程? 或者说协程的优势是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E5%B7%A5%E5%86%8D%E6%98%8E%E7%BB%86%E4%BA%9B"><span class="toc-number">3.1.</span> <span class="toc-text">协程和线程的分工再明细些</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">协程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello%E5%8D%8F%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">Hello协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">挂起函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">什么是挂起函数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">为什么要使用挂起函数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%8E%BB%E9%99%A4suspend-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E8%B0%83%E7%94%A8%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">怎么去除suspend(普通函数怎么调用挂起函数)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runBlocking-%E5%8D%8F%E7%A8%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA"><span class="toc-number">4.3.</span> <span class="toc-text">runBlocking: 协程作用域构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%8D%8F%E7%A8%8B%E7%BB%93%E6%9D%9F-job"><span class="toc-number">4.4.</span> <span class="toc-text">等待协程结束(job)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">4.5.</span> <span class="toc-text">结构化并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#coroutineScope-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA"><span class="toc-number">4.6.</span> <span class="toc-text">coroutineScope: 作用域构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#runBlocking-%E5%92%8C-coroutineScope-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.6.1.</span> <span class="toc-text">runBlocking 和 coroutineScope 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88%E4%B8%8E%E8%B6%85%E6%97%B6"><span class="toc-number">4.7.</span> <span class="toc-text">协程的取消与超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E8%AE%A1%E7%AE%97%E4%B8%AD%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.7.1.</span> <span class="toc-text">结束计算中协程的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-finally-%E4%B8%AD%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">4.7.2.</span> <span class="toc-text">在 finally 中释放资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E5%8F%96%E6%B6%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97NonCancellable"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">不能取消的代码块NonCancellable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88-%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%96%E6%B6%88%E5%8D%8F%E7%A8%8B"><span class="toc-number">4.7.3.</span> <span class="toc-text">超时取消(使用时间延迟的方式取消协程)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">组合挂起函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E5%B9%B6%E5%8F%91"><span class="toc-number">4.8.1.</span> <span class="toc-text">async 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8-async-CoroutineStart-LAZY"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">延迟启动 async(CoroutineStart.LAZY)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.2.</span> <span class="toc-text">异步风格的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">4.8.3.</span> <span class="toc-text">异步结构化并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">4.9.</span> <span class="toc-text">协程上下文调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87-%E5%BD%93%E4%BD%9CArrayList%E7%B1%BB%E4%BC%BC%E7%9A%84%E9%9B%86%E5%90%88%E5%B0%B1%E5%A5%BD"><span class="toc-number">4.9.1.</span> <span class="toc-text">协程上下文(当作ArrayList类似的集合就好)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.9.2.</span> <span class="toc-text">调度器和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%9C%E4%B8%BA%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">4.9.3.</span> <span class="toc-text">线程池作为调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%BE%AE%E5%8F%97%E9%99%90%E8%B0%83%E5%BA%A6%E5%99%A8-vs-%E5%8F%97%E9%99%90%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">4.9.4.</span> <span class="toc-text">⾮受限调度器 vs 受限调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.9.5.</span> <span class="toc-text">调试协程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-idea-%E7%89%B9%E6%AE%8A%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95"><span class="toc-number">4.9.5.1.</span> <span class="toc-text">使用 idea 特殊插件调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%B0%83%E8%AF%95"><span class="toc-number">4.9.5.2.</span> <span class="toc-text">打印日志的方式调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC"><span class="toc-number">4.9.6.</span> <span class="toc-text">一个协程在多个线程之间跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%8D%8F%E7%A8%8B"><span class="toc-number">4.9.7.</span> <span class="toc-text">子协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%8D%8F%E7%A8%8B%E5%8F%96%E5%90%8D"><span class="toc-number">4.9.8.</span> <span class="toc-text">为协程取名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E2%BD%82%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">4.9.8.1.</span> <span class="toc-text">组合协程上下⽂中的元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%A7%E6%89%BF"><span class="toc-number">4.9.9.</span> <span class="toc-text">协程的上下文继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">4.9.10.</span> <span class="toc-text">线程本地数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.1.</span> <span class="toc-text">拦截器的作用是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">拦截器怎么用?</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://imgsa.baidu.com/forum/pic/item/c8179682d158ccbf63dc944d1bd8bc3eb03541a9.jpg"></div><div class="author-info__name text-center">Bangiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/bangiao">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">606</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的博客</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/4248168662314823">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30690165">CSDN</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/bangiao/">博客园</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/projects">Gitee笔记源码</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bangiao's Notebooks</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章列表</a><a class="site-page" href="/tags">文章标签</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/sources">笔记源码</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">十一、kotlin的协程(一)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="学习的前提"><a href="#学习的前提" class="headerlink" title="学习的前提"></a>学习的前提</h1><ol>
<li><code>java</code>线程需要大概知道点</li>
<li><strong>协程是线程执行的任务, 协程和用户线程的区别在于, 协程背靠强大的编译器, 协程有专属于协程的调度器和一堆方便好用的函数, 用户可以在一定的范围下把协程给自己想要的线程执行</strong></li>
<li>了解什么是挂起? 挂起的意思是保存上下文环境, 将协程暂停, 挂起, 然后线程继续做别的事情</li>
<li>线程负责执行, 协程负责任务</li>
</ol>
<h1 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么?"></a>协程是什么?</h1><p>我觉得协程是一种开发人员可以自行决定代码在何处<strong>挂起</strong>、何处<strong>恢复</strong>的功能</p>
<p>如果我就这么说你肯定会不满意！为什么？</p>
<p>因为上面定义的是 <code>Generator</code> 类型的协程 ，是 <code>python</code> <code>JavaScript</code> <code>lua</code> 的协程</p>
<p>这种线程不支持真正的多线程</p>
<blockquote>
<p><code>python</code>有多线程，但不支持多线程并发（<code>GIL</code>）</p>
</blockquote>
<p>对于 <code>kotlin</code> 来说协程即满足了上面的挂起和恢复功能，还满足了 切线程</p>
<h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><p>在市面上, 协程的概念没有特别明细, 各个编程语言设计者都有自己的想法和思路, 虽然协程的实现细节可能不一样, 但大体分类还是能区分出来的</p>
<h3 id="协程按照有栈和无栈分类"><a href="#协程按照有栈和无栈分类" class="headerlink" title="协程按照有栈和无栈分类"></a>协程按照有栈和无栈分类</h3><p>有栈协程: 这种协程和线程一样, 有着自己的线程栈</p>
<p>有栈协程可以在任意函数调用层任意的位置调度, 而无栈协程在这方面表现的力不从心, 市面上的 <code>golang</code> 就是有栈协程实现的, 不过<br><code>golang</code>做了很多的优化, 每个协程栈的大小最小是<code>4k</code>, 和线程的 上百<code>kb</code> 级别对比起来, 轻了很多很多</p>
<p>无栈协程: 无栈协程, 一般没有记录的协程栈, 主要存储的数据都在状态机或者闭包的方式实现, <code>kotlin</code>通常被认为是无栈协程, 使用状态机代替协程栈, 它在挂起函数的挂起点生成一个状态机记录协程数据</p>
<h3 id="按照调度的控制权分类"><a href="#按照调度的控制权分类" class="headerlink" title="按照调度的控制权分类"></a>按照调度的控制权分类</h3><p>这种方式我们分为: 对称协程和非对称协程</p>
<p>对称协程: 任何一个协程都是独立的, 平等的, 调度的权利可以在协程和协程间转移, 就像 <code>golang</code> , 他就是对称协程, 借助 <code>channel</code> 来转移调度权</p>
<p>非对称协程: 协程和协程之间的调度权是调度与被调度, 所以是不对等的</p>
<h1 id="为什么使用协程-或者说协程的优势是什么"><a href="#为什么使用协程-或者说协程的优势是什么" class="headerlink" title="为什么使用协程? 或者说协程的优势是什么?"></a>为什么使用协程? 或者说协程的优势是什么?</h1><p>答: 协程的优势在于</p>
<ol>
<li>精细化调度, 前一秒还在用 <code>UI</code> 线程执行一些 <code>UI</code> 更新的操作, 后一秒发现任务需要 阻塞, 该阻塞任务就切给其他线程去执行了, <code>UI</code>线程继续刷新<code>UI</code></li>
<li>像写一般代码一样写出异步代码, 更加便捷的写出高并发代码</li>
<li>如果协程库底层实现了属于协程的非阻塞 <code>IO</code> 函数的话, 协程还合适 <code>IO</code> 操作</li>
<li>协程自身的上下文切换不需要陷入到内核中, 而且协程的使用使得 <strong>线程</strong> 的数量变少, 减少了上下文切换需要的频率</li>
</ol>
<h2 id="协程和线程的分工再明细些"><a href="#协程和线程的分工再明细些" class="headerlink" title="协程和线程的分工再明细些"></a>协程和线程的分工再明细些</h2><p>协程并不是取代线程而产生的, 协程抽象于线程, 线程是<code>CPU</code>的最小单元, 从另一个角度看, 线程分割了<code>CPU</code>的执行力, <strong>协程是组织好的代码流程</strong>, 协程需要线程执行, 但又不会直接操控线程, 而是借助协程调度器(看源码是借助<code>Interruptor</code>), 调度的协程</p>
<h1 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h1><h2 id="Hello协程"><a href="#Hello协程" class="headerlink" title="Hello协程"></a>Hello协程</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GlobalScope启动的线程可能存在问题, 需要添加该注解表示下</span></span><br><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建一个全局的协程空间, 该协程的声明周期会直到 app 结束后才会释放, 所以需要注意这点, 该函数更 new Thread 一样</span></span><br><span class="line">   GlobalScope.launch &#123;</span><br><span class="line">      <span class="comment">// 挂起函数, 主线程执行到这里, 会挂起该作用域的协程, 然后主线程跳出该协程作用域</span></span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      <span class="comment">// 等待协程被挂起 1 sec 后, 执行下面代码</span></span><br><span class="line">      println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 1&quot;</span>) <span class="comment">// Thread[DefaultDispatcher-worker-1,5,main]: 1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 主线程遇到上面的 挂起函数后, 直接跳到这里, 执行打印</span></span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 2&quot;</span>) <span class="comment">// Thread[main,5,main]: 2</span></span><br><span class="line">   <span class="comment">// 主线程等待 2 sec</span></span><br><span class="line">   Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上面代码的解读:</p>
<ol>
<li><p><code>delay</code> 是挂起函数, 和线程中的 <code>Thread.Sleep(...)</code> 一样, 但是挂起函数只能给协程执行的, 不能给普通线程执行, 否则会报错</p>
</li>
<li><p><strong>遇到挂起函数后, 协程其实还不会被挂起, 除非协程遇到异步调用</strong>, 而上面的 <code>delay(1000)</code> 恰恰是异步调用, 这里将会产生一个挂起点, 协程将被挂起</p>
</li>
</ol>
<blockquote>
<p>在 kotlin 1.5 中 <code>GlobalScope</code> 已经被 <code>kotlin</code> 团队指出存在问题, 所以使用的时候需要注意, 考虑好, <code>GlobalScope</code> 申请的协程是否在另一个地方也被使用, 或者你申请的协程是否同时被另一个人使用? <code>GlobalScope</code> 申请的协程会跟着<code>app</code>同生共死, 即使你没用再使用它, 它还是在, 并且 <code>GlobalScope</code> 获取的协程无法 <code>cancel</code> 取消, 所以需要使用的话请慎重考虑其带来的后果</p>
</blockquote>
<h2 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h2><h3 id="什么是挂起函数"><a href="#什么是挂起函数" class="headerlink" title="什么是挂起函数?"></a>什么是挂起函数?</h3><p>在<code>kotlin</code>中 被 <code>suspend</code> 标记的函数叫<strong>挂起函数</strong></p>
<p><strong><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F3994917-421263f1f0e41d16.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650228753&t=a500c9cf960ad108ea0a153fea9154a4" alt="img"></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果代码反编译成<code>java</code>代码, 就成为: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> Object f(Continuation $completion) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 <strong>挂起函数</strong> 的区别了 <code>Continuation</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> <span class="comment">// 将某个步骤的结果传递给 result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CoroutineContext</code>可以看成是协程存储部分功能的集合</p>
<p><strong>该接口非常的明显了, 存储的是一个协程上下文和一个用于异步操作结束协程恢复调用使用的函数<code>resumeWith</code></strong></p>
<h3 id="为什么要使用挂起函数"><a href="#为什么要使用挂起函数" class="headerlink" title="为什么要使用挂起函数?"></a>为什么要使用挂起函数?</h3><p>协程遇到挂起函数并且<strong>遇到异步操作</strong>, 协程就会被挂起, 但<strong>线程不会被阻塞, 可以去运行其他协程或者处理其他事物</strong></p>
<blockquote>
<p>挂起函数, 未必就一定会挂起协程, 只有在挂起函数内部出现<strong>异步操作</strong>才会被挂起, 我们把挂起函数内部的异步操作叫做<strong>挂起点</strong></p>
</blockquote>
<blockquote>
<p>这样的好处就是这条线程不会被阻塞, 真正阻塞的是协程, 该线程可以继续做其他操作</p>
</blockquote>
<h3 id="怎么去除suspend-普通函数怎么调用挂起函数"><a href="#怎么去除suspend-普通函数怎么调用挂起函数" class="headerlink" title="怎么去除suspend(普通函数怎么调用挂起函数)"></a>怎么去除<code>suspend</code>(普通函数怎么调用挂起函数)</h3><p>我们都知道, 挂起函数有一个接口<code>Continuation</code>, 如果我们要在普通函数中调用挂起函数的话</p>
<p>需要我们定义一个自己的<code>Continuation</code></p>
<p>比如: 我要在不在 <code>main</code> 函数上头添加<code>suspend</code>关键字的话, 我们可以</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">suspend</span> &#123;</span><br><span class="line">		coroutineScope &#123;</span><br><span class="line">			println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: zhazha&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span><span class="symbol">@coroutineScope</span> <span class="number">100</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 在这里创建一个对象 Continuation</span></span><br><span class="line">	&#125;.startCoroutineCancellable(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">			<span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">			println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: <span class="subst">$&#123;result.getOrNull()&#125;</span>&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>但其实上面那种方式也是创建一个协程的方式, 只不过它比较复杂而已, 我们有了更简单的方式创建一个协程</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> continuation = <span class="keyword">suspend</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;in coroutine&quot;</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    <span class="keyword">get</span>() = Dispatchers.IO</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        log(<span class="string">&quot;resumeWith result = <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">continuation.resume(<span class="built_in">Unit</span>)</span><br></pre></td></tr></table></figure>



<p>当然你也可以变成创建了个<code>Continuation</code></p>
<p>直接这么执行:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">    continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;.join()</span><br></pre></td></tr></table></figure>



<p>如果不在<code>main</code>上添加<code>suspend</code>还可以使用<code>CoroutinesScope</code>去创建</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CoroutineScope(Dispatchers.IO).launch &#123; </span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        println(<span class="string">&quot;zhazha&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果你的协程需要等待时，使用 <code>runBlocking</code> 的方式</p>
</blockquote>
<h2 id="runBlocking-协程作用域构建"><a href="#runBlocking-协程作用域构建" class="headerlink" title="runBlocking: 协程作用域构建"></a><code>runBlocking</code>: 协程作用域构建</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 下面的 this: CoroutineScope 就是协程作用域</span></span><br><span class="line">   <span class="comment">// 在后台启动⼀个新的协程并继续</span></span><br><span class="line">   GlobalScope.launch &#123;</span><br><span class="line">      delay(<span class="number">1000</span>) <span class="comment">// ⾮阻塞的等待 1 秒钟（默认时间单位是毫秒）</span></span><br><span class="line">      println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 1&quot;</span>) <span class="comment">// 在延迟后打印输出</span></span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 2&quot;</span>) <span class="comment">// 协程已在等待, 主线程还在继续执行</span></span><br><span class="line">   <span class="comment">// 另一个协程作用域</span></span><br><span class="line">   runBlocking &#123;</span><br><span class="line">      <span class="comment">// 挂起协程, 但由于 runBlocking 的效果, 里面的子协程必须全部执行完毕才会释放主线程, 所以主线程一直阻塞在 delay(2000)</span></span><br><span class="line">      delay(<span class="number">2000</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>runBlocking</code> 申请了个协程作用域, 该函数阻塞了主线程, 直到 <code>runBlocking</code> 作用域内的子协程全部执行结束, 记住是子线程</li>
</ol>
<blockquote>
<p>记笔记: <code>runBlocking</code> 会阻塞主线程, 一般时候没人敢用, 仅仅在测试的时候用用就得了, 一般情况下考虑使用 <code>coroutineScope</code></p>
</blockquote>
<p>下面的代码中使用 <code>GlobalScope.launch</code> 将不再是 <code>runBlocking</code> 的子协程, 所以不受 <code>runBlocking</code> 的约束</p>
<blockquote>
<p>在源码中你会发现这样:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns [EmptyCoroutineContext].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>GlobalScope</code> 有自己的协程上下文, 而我们的 <code>runBlocking</code> 他有自己的协程上下文, 这俩协程上下文压根不同, 所以 <code>runBlocking</code> 无法阻塞 <code>GlobalScope</code> 启动的协程</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="comment">// 申请一个阻塞执行线程的协程作用域</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   <span class="comment">// 使用全局协程执行下面代码</span></span><br><span class="line">   GlobalScope.launch &#123;</span><br><span class="line">      <span class="comment">// 挂起函数, 挂起了协程</span></span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      <span class="comment">// 挂起完毕后, 线程开始执行下面的打印</span></span><br><span class="line">      println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 1&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 主线程执行打印</span></span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 2&quot;</span>)</span><br><span class="line">   <span class="comment">// 主线程挂起等待</span></span><br><span class="line">   delay(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以上面的<code>delay(2000)</code>如果被注释掉, 则主线程直接退出</p>
<p>如果是这样:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   launch &#123;</span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 1&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则, 主线程会等待 <code>launch</code> 函数的子线程结束</p>
<p>如果需要 <code>GlobalScope.launch</code> 被主线程等待, 则需要把返回值的 <code>Job</code> 提出来, 然后<code>job.join()</code></p>
<h2 id="等待协程结束-job"><a href="#等待协程结束-job" class="headerlink" title="等待协程结束(job)"></a>等待协程结束(<code>job</code>)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="comment">// 由于 job.join() 是挂起函数, 所以调用该挂起函数的函数也要是挂起函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 1&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: 2&quot;</span>)</span><br><span class="line">   job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在前面 <code>GlobalScope.launch</code> 中, 我们发现其实类似于我们启动一个 <code>Thread</code> 线程, 他是全局的, 不能够监管的, 所以还是尽量少用 <code>GlobalScope.launch</code> 这种全局方式</p>
</blockquote>
<h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">	println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: 0&quot;</span>)</span><br><span class="line">	launch &#123;</span><br><span class="line">		println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: 1&quot;</span>)</span><br><span class="line">		launch &#123;</span><br><span class="line">			println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: 2&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	launch &#123;</span><br><span class="line">		println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: 3&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main <span class="meta">@coroutine</span>#<span class="number">1</span>: <span class="number">0</span></span><br><span class="line">main <span class="meta">@coroutine</span>#<span class="number">2</span>: <span class="number">1</span></span><br><span class="line">main <span class="meta">@coroutine</span>#<span class="number">3</span>: <span class="number">3</span></span><br><span class="line">main <span class="meta">@coroutine</span>#<span class="number">4</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fcdn.ancii.com%2Farticle%2Fimage%2Fv1%2FQj%2Fzb%2FRO%2FORzjbQVFJasX5aR2DaTg2_Zx5KSH75KdTtVIpx5BAia9LyPTgZZSHVXLmD0EXF8rqx7I6wNKrfm8sZfDDWa_VVi2VTSs7pccZdNATAby1js.jpg&refer=http%3A%2F%2Fcdn.ancii.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650383334&t=4d9ef356fbf0c3ef35200847fe8bf1d3" alt="img"></p>
<p>我们还可以用下面这段代码看看, kotlin协程底层怎么设计的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Starting a coroutine block...&quot;</span>) <span class="comment">// 启动一个父协程, 并且开启协程作用域</span></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">&quot; Coroutine block started&quot;</span>) <span class="comment">// 协程作用域开始位置</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;  1/ First coroutine start&quot;</span>) <span class="comment">// 启动子协程</span></span><br><span class="line">            delay(<span class="number">100</span>) <span class="comment">// 延迟挂起 100ms</span></span><br><span class="line">            println(<span class="string">&quot;  1/ First coroutine end&quot;</span>) <span class="comment">// 第一个子协程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(<span class="string">&quot;  2/ Second coroutine start&quot;</span>) <span class="comment">// 第二个子协程</span></span><br><span class="line">            delay(<span class="number">50</span>) <span class="comment">// 延迟挂起 50 ms</span></span><br><span class="line">            println(<span class="string">&quot;  2/ Second coroutine end&quot;</span>) <span class="comment">// 第二个子协程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot; Two coroutines have been launched&quot;</span>) <span class="comment">// 协程作用域结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Back from the coroutine block&quot;</span>) <span class="comment">// 结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Starting a coroutine block…</span><br><span class="line"> Coroutine block started</span><br><span class="line"> Two coroutines have been launched</span><br><span class="line">  1/ First coroutine start</span><br><span class="line">  2/ Second coroutine start</span><br><span class="line">  2/ Second coroutine end</span><br><span class="line">  1/ First coroutine end</span><br><span class="line">Back from the coroutine block</span><br></pre></td></tr></table></figure>



<p>这样上面的 <code>runBlocking</code> 就能够控制内部的子协程, 直到子协程结束, 线程才会退出该协程作用域</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dd762d1317e47c3be40a48b771dc481~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://silica.io/understanding-kotlin-coroutines/5/">图片代码出处</a></p>
</blockquote>
<h2 id="coroutineScope-作用域构建"><a href="#coroutineScope-作用域构建" class="headerlink" title="coroutineScope: 作用域构建"></a><code>coroutineScope</code>: 作用域构建</h2><p>除了上面的 <code>runBlocking</code> 外, <code>kotlin</code> 还提供了<code>coroutineScope</code> 用于构建协程作用域</p>
<p><code>coroutineScope</code> 和 <code>runBlocking</code> 一样, 会保证协程作用域内的子协程执行完毕后, 才会结束该作用域</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">   coroutineScope &#123;</span><br><span class="line">      delay(<span class="number">1000</span>)</span><br><span class="line">      println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="runBlocking-和-coroutineScope-的区别"><a href="#runBlocking-和-coroutineScope-的区别" class="headerlink" title="runBlocking 和 coroutineScope 的区别"></a><code>runBlocking</code> 和 <code>coroutineScope</code> 的区别</h3><p><code>runBlocking</code> 会阻塞主线程在该协程作用域中, 而 <code>coroutineScope</code> 不会, 他是挂起函数, 不会阻塞线程, 而会释放线程, 用于其他用途使用, 但是如果释放的线程此时没事干, 还是会滞留在 <code>coroutineScope</code> 作用域内, 只不过该线程随时有空罢了</p>
<blockquote>
<p>假设上面的主线程是 <code>UI</code> 线程的话, 你还使用 <code>runBlocking</code> , 完蛋了, <code>UI</code> 线程阻塞, <code>app</code>卡顿. 但是我学 <code>kotlin</code> 不是用于 <code>android</code> 所以读者自测</p>
</blockquote>
<h2 id="协程的取消与超时"><a href="#协程的取消与超时" class="headerlink" title="协程的取消与超时"></a>协程的取消与超时</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Unconfined)</span><br><span class="line">   scope.launch &#123;</span><br><span class="line">      repeat(<span class="number">100000</span>) &#123;</span><br><span class="line">         delay(<span class="number">1000</span>) <span class="comment">// 因为有延迟中断操作才会取消</span></span><br><span class="line">         println(<span class="string">&quot;ping&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   TimeUnit.SECONDS.sleep(<span class="number">6</span>)</span><br><span class="line">   scope.cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果协程执行的是 <code>CPU 密集</code> 计算的话, 则取消不会生效</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">	<span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">	<span class="keyword">val</span>  job = launch(Dispatchers.Default) &#123;</span><br><span class="line">		<span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">		<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">				println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">				nextPrintTime += <span class="number">500L</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delay(<span class="number">1300L</span>)</span><br><span class="line">	println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">	job.cancelAndJoin()</span><br><span class="line">	println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意, 只要协程没有进入协程的异步操作, 也不会让协程结束</p>
<blockquote>
<p>协程遇到<code>Thread.current.Sleep(500)</code>也不会导致协程去修改 <code>isActive</code> 属性，因为这段代码<code>sleep</code>的是线程而不是协程</p>
</blockquote>
<h3 id="结束计算中协程的方式"><a href="#结束计算中协程的方式" class="headerlink" title="结束计算中协程的方式"></a>结束计算中协程的方式</h3><p>可以使用 <code>isActive</code> 让计算中的协程停止:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">	<span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">	<span class="keyword">val</span>  job = launch(Dispatchers.Default) &#123;</span><br><span class="line">		<span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">		<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; <span class="number">10</span> &amp;&amp; isActive) &#123;</span><br><span class="line">			<span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">				println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">				nextPrintTime += <span class="number">500L</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delay(<span class="number">1300L</span>)</span><br><span class="line">	println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">	job.cancelAndJoin()</span><br><span class="line">	println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果我们修改成下面的代码, 则协程不会退出</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">	<span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">	<span class="keyword">val</span> job = launch &#123;</span><br><span class="line">		<span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">		<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">			<span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">				println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> isActive = <span class="variable">$isActive</span>...&quot;</span>)</span><br><span class="line">				nextPrintTime += <span class="number">500L</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delay(<span class="number">1300L</span>)</span><br><span class="line">	println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">	job.cancelAndJoin()</span><br><span class="line">	println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将代码中的 <code>while(i &lt; 10)</code> 和 协程的 <code>Dispatcher.Default</code> 去掉</p>
<p>这里的 <code>main</code> 协程不会有时间停止下来执行下面这段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delay(<span class="number">1300L</span>)</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">job.cancelAndJoin()</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: Now I can quit.&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>为什么会这样？</p>
<p>我们给<code>jvm</code>添加参数 <code>-ea</code> 让 <code>kotlin</code> 进入调试模式</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80818d43407447c9bfc2fc876f62f263~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>此时，我们将看到这样的打印：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main @coroutine#2: I&#x27;m sleeping 0 isActive = true...</span><br><span class="line">main @coroutine#2: I&#x27;m sleeping 1 isActive = true...</span><br><span class="line">main @coroutine#2: I&#x27;m sleeping 2 isActive = true...</span><br></pre></td></tr></table></figure>



<p>我们可以很直观的发现，一直都是我们的 <code>main @coroutine#2</code> 协程在执行</p>
<p>而我们前面能够正常退出的代码呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultDispatcher-worker-1 @coroutine#2: job: I&#x27;m sleeping 0 ...</span><br><span class="line">DefaultDispatcher-worker-1 @coroutine#2: job: I&#x27;m sleeping 1 ...</span><br><span class="line">DefaultDispatcher-worker-1 @coroutine#2: job: I&#x27;m sleeping 2 ...</span><br><span class="line">main @coroutine#1: main: I&#x27;m tired of waiting!</span><br><span class="line">main @coroutine#1: main: Now I can quit.</span><br></pre></td></tr></table></figure>



<p>这里能够保证 <code>cancelAndJoin</code> 这段代码有另一个线程的另一个协程在执行</p>
<p>然后我们把 <code>while(i &lt; 6)</code> 代码添加上去</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">   <span class="keyword">val</span>  job = launch &#123;</span><br><span class="line">      <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">      <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; <span class="number">6</span> &amp;&amp; isActive) &#123;</span><br><span class="line">         <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">            nextPrintTime += <span class="number">500L</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   delay(<span class="number">1300L</span>)</span><br><span class="line">   println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">   job.cancelAndJoin()</span><br><span class="line">   println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ...</span><br><span class="line">job: I&#x27;m sleeping 1 ...</span><br><span class="line">job: I&#x27;m sleeping 2 ...</span><br><span class="line">job: I&#x27;m sleeping 3 ...</span><br><span class="line">job: I&#x27;m sleeping 4 ...</span><br><span class="line">job: I&#x27;m sleeping 5 ...</span><br><span class="line">main: I&#x27;m tired of waiting!</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure>



<p>诶，可以正常停止，为什么会这样？</p>
<p>很简单，<code>i</code> 的条件满足了，而且 <code>job</code> 打印多了不是？ 明显不是协程 <code>cancel</code> 导致的线程结束</p>
<p>这里可能还会有一个需要纠结的问题点：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6374b328c08745939b541e165a61b9e7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>上图中 <code>delay</code> 不是挂起的协程么？线程不是没挂起么？</p>
<p>为什么后面的 三行 代码不会被线程执行呢？</p>
<p>而是变成线程在 <code>delay</code> 这里等待么？ 那岂不是阻塞了线程？ 矛盾是不是？</p>
<p>答案很简单， <code>delay</code> 虽然挂起的协程，但你没告诉<code>kotlin</code> <code>delay</code> 内部真正的延迟代码到底是哪个线程执行？</p>
<p>所以最后还是 <code>main</code> 线程 在执行 <code>delay</code> 的等待</p>
<h3 id="在-finally-中释放资源"><a href="#在-finally-中释放资源" class="headerlink" title="在 finally 中释放资源"></a>在 <code>finally</code> 中释放资源</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">	<span class="keyword">val</span> job = launch &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">				println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: job: I&#x27;m sleeping <span class="variable">$it</span> ...&quot;</span>)</span><br><span class="line">				delay(<span class="number">500</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">				println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: I&#x27;m running finally <span class="subst">$&#123;it&#125;</span>&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delay(<span class="number">1300</span>)</span><br><span class="line">	job.cancelAndJoin()</span><br><span class="line">	println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span> is finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,5,main]: job: I&#x27;m sleeping 0 ...</span><br><span class="line">Thread[main,5,main]: job: I&#x27;m sleeping 1 ...</span><br><span class="line">Thread[main,5,main]: job: I&#x27;m sleeping 2 ...</span><br><span class="line">Thread[main,5,main]: I&#x27;m running finally 0</span><br><span class="line">Thread[main,5,main]: I&#x27;m running finally 1</span><br><span class="line">Thread[main,5,main]: I&#x27;m running finally ...</span><br><span class="line">Thread[main,5,main]: I&#x27;m running finally 998</span><br><span class="line">Thread[main,5,main]: I&#x27;m running finally 999</span><br><span class="line">Thread[main,5,main] is finished</span><br></pre></td></tr></table></figure>

<p>一千次循环, 每次循环延迟<code>500ms</code>, 等待<code>1300ms</code>, 所以它会打印<strong>3次</strong>(<code>println</code>先打印的, 所以<strong>3次</strong>), 等到<code>1300ms</code>后, <code>job</code>被取消后, 协程就退出了, 此时<code>finally</code>还会执行</p>
<blockquote>
<p>还是那句话, 协程执行代码都来不及, 怎么会有时间执行下面的<code>cancelAndJoin</code>函数呢?</p>
</blockquote>
<p>为什么会这样呢?</p>
<p>前面说的过, 协程在执行<code>计算密集型</code>代码时, 协程不会被结束</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isActive) &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: I&#x27;m running finally <span class="subst">$&#123;it&#125;</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@repeat</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加上面这样的代码, 协程直接被退出</p>
<h4 id="不能取消的代码块NonCancellable"><a href="#不能取消的代码块NonCancellable" class="headerlink" title="不能取消的代码块NonCancellable"></a>不能取消的代码块<code>NonCancellable</code></h4><ul>
<li>为什么需要它?</li>
</ul>
<p>看下面这段代码: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: I&#x27;m sleeping <span class="variable">$it</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: I&#x27;m running finally&quot;</span>)</span><br><span class="line">         delay(<span class="number">1000L</span>)</span><br><span class="line">         println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   delay(<span class="number">1000</span>)</span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">   job.cancelAndJoin()</span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现<code>println(&quot;$&#123;Thread.currentThread()&#125;: And I&#39;ve just delayed for 1 sec because I&#39;m non-cancellable&quot;)</code> 这段代码不执行, 说明协程虽然收到了<code>cancel</code>指示, 将标志修改为<code>isActive == false</code>状态, 但此时协程还有任务需要进行, 不会立即取消, 当协程遇到<code>delay</code>函数被挂起, 一被挂起就会被<code>cancelAndJoin</code>函数的<code>Join</code>功能认为协程已经处理结束, 直接强制执行<code>cancel</code>功能结束掉协程</p>
<p>解决方案是添加协程功能<code>NonCancellable</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: I&#x27;m sleeping <span class="variable">$it</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         withContext(NonCancellable) &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: I&#x27;m running finally&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   delay(<span class="number">1300</span>)</span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">   job.cancelAndJoin()</span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span>: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式可以让协程正在执行<code>NonCancellable</code>标记的代码时, 不会被<code>cancel</code>掉</p>
<h3 id="超时取消-使用时间延迟的方式取消协程"><a href="#超时取消-使用时间延迟的方式取消协程" class="headerlink" title="超时取消(使用时间延迟的方式取消协程)"></a>超时取消(使用时间延迟的方式取消协程)</h3><blockquote>
<p>前面的 <code>Executors.newScheduledThreadPool(1).schedule</code> 代码去延迟1300L毫秒, 在这里我们也可以使用</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test07</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: I&#x27;m sleeping ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;Done&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方式会报错一个错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main <span class="meta">@coroutine</span>#<span class="number">1</span>: I<span class="string">&#x27;m sleeping ...</span></span><br><span class="line"><span class="string">main @coroutine#1: I&#x27;</span>m sleeping ...</span><br><span class="line">main <span class="meta">@coroutine</span>#<span class="number">1</span>: I<span class="string">&#x27;m sleeping ...</span></span><br><span class="line"><span class="string">kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms</span></span><br></pre></td></tr></table></figure>

<p><code>withTimeout</code>还有返回值, 但是上面的代码并没有得到返回值</p>
<p>我们还可以用<code>withTimeoutOrNull</code> 这样就不会报错了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test08</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: I&#x27;m sleeping ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;Done&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main @coroutine#1: I&#x27;m sleeping ...</span><br><span class="line">main @coroutine#1: I&#x27;m sleeping ...</span><br><span class="line">main @coroutine#1: I&#x27;m sleeping ...</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>直接打印出了 <code>null</code></p>
<h2 id="组合挂起函数"><a href="#组合挂起函数" class="headerlink" title="组合挂起函数"></a>组合挂起函数</h2><h3 id="async-并发"><a href="#async-并发" class="headerlink" title="async 并发"></a><code>async</code> 并发</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> time1 = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = doSomethingUsefulOne()</span><br><span class="line">        <span class="keyword">val</span> two = doSomethingUsefulTwo()</span><br><span class="line">        println(one + two)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$time1</span> ms&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> time02 = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$time02</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这段函数将 两个 协程子任务 的 <code>delay</code> 做了同步延迟, 这样最多只要等待一秒时间就延迟结束了, 但如果是串行执行的话, 则需要 <code>delay</code> 两秒</p>
</blockquote>
<p><code>async</code> 和 <code>launch</code> 的区别在于, <code>async</code> 可以接收其内部 作用域 的返回值</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54698530f4a47e1ab0ef77ddff15772~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0bf8ca2a7534f1a961dc313e6b3bebf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>多了个</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br></pre></td></tr></table></figure>

<p>函数, 用于接受返回值</p>
<h4 id="延迟启动-async-CoroutineStart-LAZY"><a href="#延迟启动-async-CoroutineStart-LAZY" class="headerlink" title="延迟启动 async(CoroutineStart.LAZY)"></a>延迟启动 <code>async</code>(<code>CoroutineStart.LAZY</code>)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="comment">// 协程延迟运行</span></span><br><span class="line">        <span class="keyword">val</span> one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        <span class="comment">// 协程在这里正式启动</span></span><br><span class="line">        one.start()</span><br><span class="line">        two.start()</span><br><span class="line">        <span class="comment">// 等待两个协程任务执行完毕</span></span><br><span class="line">        println(<span class="string">&quot;I answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步风格的函数"><a href="#异步风格的函数" class="headerlink" title="异步风格的函数"></a>异步风格的函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">somethingUsefulOneAsync</span><span class="params">()</span></span> = GlobalScope.async &#123;</span><br><span class="line">    doSomethingUsefulOne()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">somethingUsefulTwoAsync</span><span class="params">()</span></span> = GlobalScope.async &#123;</span><br><span class="line">    doSomethingUsefulTwo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = somethingUsefulOneAsync()</span><br><span class="line">        <span class="keyword">val</span> two = somethingUsefulTwoAsync()</span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的编写协程的方式不被推荐</p>
<p>因为需要<code>somethingUsefulOneAsync</code>和<code>somethingUsefulTwoAsync</code>的结果来计算</p>
<p>如果<code>One</code>函数失败, 则<code>Two</code>函数也不能执行, 反之亦然</p>
<p>但是在上面的代码中, 可能会出现 <code>One</code> 出现异常, 但是被全局异常捕获了, 虽然 <code>One</code> 函数不再执行, 但是不影响程序执行 <code>Two</code>函数, 该执行的还是会继续执行</p>
<p>所以我们需要一个协程作用域框住这两个函数, 这样就能做到多个协程的原子性, 也就是所谓的<code>一荣俱荣, 一耻具耻</code></p>
<blockquote>
<p>这种情况我没有合适的环境演示, 交给你们了, 不过在没有所谓的全局异常捕获器时, 不会发生上面的问题, 不过既然 <code>One</code>和<code>Two</code>两个业务的代码有严重的依赖, 肯定是需要一个类似事务一样的功能管理下的</p>
</blockquote>
<p>那么要解决上面问题的方法就很简单了, 给个更大的协程作用域将<code>One</code>和<code>Two</code>包裹起来就好</p>
<h3 id="异步结构化并发"><a href="#异步结构化并发" class="headerlink" title="异步结构化并发"></a>异步结构化并发</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">concurrentSum</span><span class="params">()</span></span> : <span class="built_in">Int</span> = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">    <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">val</span> measureTimeMillis = measureTimeMillis &#123;</span><br><span class="line">        println(concurrentSum())</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$measureTimeMillis</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 kotlin 中, 推荐使用上面这种方式</p>
<p>这样做的好处是, 在 <code>coroutineScope</code> 作用域内的所有协程, 只要在该作用域内抛出了异常, 就会取消该作用域内的所有协程</p>
<blockquote>
<p>这种方式如果内部有个协程不能因为一个异常终止, 可以考虑使用前面的 <strong>### 不能取消的协程</strong> <code>withContext(NonCancellable)</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">concurrentSum</span><span class="params">()</span></span>: <span class="built_in">Int</span> = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">    <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        withContext(NonCancellable) &#123;</span><br><span class="line">            repeat(<span class="number">3</span>) &#123;</span><br><span class="line">                delay(<span class="number">1000</span>)</span><br><span class="line">                println(<span class="string">&quot;delay 1 sec&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">&quot;抛出运行时异常终止协程&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;抛出运行时异常终止协程&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> measureTimeMillis = measureTimeMillis &#123;</span><br><span class="line">        println(concurrentSum())</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$measureTimeMillis</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的输出结果是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">抛出运行时异常终止协程</span><br><span class="line">delay 1 sec</span><br><span class="line">delay 1 sec</span><br><span class="line">delay 1 sec</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: 抛出运行时异常终止协程</span><br></pre></td></tr></table></figure>

<p>结果显示, 不会立即结束该作用域, 而是等到 延迟3秒后, 再抛出</p>
<h2 id="协程上下文调度器"><a href="#协程上下文调度器" class="headerlink" title="协程上下文调度器"></a>协程上下文调度器</h2><h3 id="协程上下文-当作ArrayList类似的集合就好"><a href="#协程上下文-当作ArrayList类似的集合就好" class="headerlink" title="协程上下文(当作ArrayList类似的集合就好)"></a>协程上下文(当作<code>ArrayList</code>类似的集合就好)</h3><blockquote>
<p>协程的上下文是 <code>CoroutineContext</code> 它负责在协程的调度过程中存储一些中间元素, 而他的主要元素是 <strong><code>Job</code></strong> 、<strong>调度器(<code>coroutine dispatcher</code>)<strong>、</strong>协程的名字(<code>CoroutineName</code>)</strong> 和 <strong>协程异常(<code>CoroutineExceptionHandler</code>)</strong>, 它可以做 加法 减法 组合</p>
</blockquote>
<blockquote>
<p><strong>我们可以把协程上下文调度器看作是一个集合, 一个容器</strong>, 里面存放的 <strong><code>Job</code></strong> 、<strong>调度器(<code>coroutine  dispatcher</code>)<strong>、</strong>协程的名字(<code>CoroutineName</code>)</strong> 和 <strong>协程异常(<code>CoroutineExceptionHandler</code>)</strong></p>
</blockquote>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F1211741-0bcfd77e12d83378.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650228753&t=35a01b0990cfa57f33b5453a9fbe1169" alt="img"></p>
<h3 id="调度器和线程"><a href="#调度器和线程" class="headerlink" title="调度器和线程"></a>调度器和线程</h3><p>调度器的主要作用是将协程安排给线程执行, 至于是哪个线程, 由调度器决定, 它可以限制协程在一个特定的线程中执行, 或将它分派给一个线程池执行又或者是不受任何限制的执行</p>
<p>所有的协程构建器<code>launch</code>或者<code>async</code>都有一个参数叫<code>CoroutineContext</code>, 主要的目的是分派哪个类型的调度器给构建器使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 前面的数字是打印的顺序</span></span><br><span class="line">    launch &#123; <span class="comment">// 运⾏在⽗协程的上下⽂中，即 runBlocking 主协程</span></span><br><span class="line">        <span class="comment">// 3 main runBlocking      : I&#x27;m working in thread main</span></span><br><span class="line">        println(<span class="string">&quot;main runBlocking      : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; <span class="comment">// 不受限的 -- 将⼯作在主线程中</span></span><br><span class="line">        <span class="comment">// 1 Unconfined            : I&#x27;m working in thread main</span></span><br><span class="line">        println(<span class="string">&quot;Unconfined            : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Default) &#123; <span class="comment">// 将会获取默认调度器 DefaultDispatcher</span></span><br><span class="line">        <span class="comment">// 2 Default               : I&#x27;m working in thread DefaultDispatcher-worker-1</span></span><br><span class="line">        println(<span class="string">&quot;Default               : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> context = newSingleThreadContext(<span class="string">&quot;MyOwnThread&quot;</span>)</span><br><span class="line">    launch(context) &#123; <span class="comment">// 将使它获得⼀个新的线程, 该线程是专属线程, 当线程资源非常昂贵, 如果不再使用, 则需要 close 掉</span></span><br><span class="line">        <span class="comment">// 4 newSingleThreadContext: I&#x27;m working in thread MyOwnThread</span></span><br><span class="line">        println(<span class="string">&quot;newSingleThreadContext: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    context.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印详情都在注释里了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unconfined            : I&#x27;m working in thread main</span><br><span class="line">Default               : I&#x27;m working in thread DefaultDispatcher-worker-1</span><br><span class="line">main runBlocking      : I&#x27;m working in thread main</span><br><span class="line">newSingleThreadContext: I&#x27;m working in thread MyOwnThread</span><br></pre></td></tr></table></figure>

<p>我们依次分析:</p>
<ol>
<li><p><code>launch &#123; …… &#125;</code>: 其中的协程上下文(和调度器)继承自 <code>runBlocking</code> 的上下文</p>
</li>
<li><p><code>Dispatchers.Unconfined</code>: 一个特殊的调度器, 它的特点是不指定协程必须在哪个线程执行, 来者不拒, 哪个线程执行它, 它就是哪个线程在执行</p>
</li>
<li><p><code>launch(Dispatchers.Default)</code>: 与 <code>GlobalScope.launch</code> 使用的相同的线程池</p>
</li>
<li><p><code>newSingleThreadContext</code>: 使用这种方式, 将会创建一个专属线程, 用于协程的执行, 但是线程是个比较昂贵的资源, 所以如果不再使用了, 这种方式的线程需要 <code>close</code> 掉, 或者设计成顶层属性, 给整个系统使用</p>
</li>
</ol>
<h3 id="线程池作为调度器"><a href="#线程池作为调度器" class="headerlink" title="线程池作为调度器"></a>线程池作为调度器</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">   Executors.newFixedThreadPool(<span class="number">5</span>).asCoroutineDispatcher().use &#123;dispatcher -&gt;</span><br><span class="line">      List(<span class="number">1000</span>) &#123;</span><br><span class="line">         GlobalScope.launch(dispatcher) &#123;</span><br><span class="line">            log(i++)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;.forEach &#123;</span><br><span class="line">         it.join()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   TimeUnit.SECONDS.sleep(<span class="number">1</span>)</span><br><span class="line">   log(<span class="string">&quot;i = <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到上面这段代码, 你是否对调度器有了新的认识???</p>
<h3 id="⾮受限调度器-vs-受限调度器"><a href="#⾮受限调度器-vs-受限调度器" class="headerlink" title="⾮受限调度器 vs 受限调度器"></a>⾮受限调度器 vs 受限调度器</h3><p>当协程调度器是 <code>Dispatchers.Unconfined</code> 时, 调度器不会执行协程在特定种类的线程中运行, 如果是受限调度器的话, 执行之前是 <code>IO 线程</code>, 挂起恢复之后还是 <code>IO 线程</code>执行</p>
<blockquote>
<p>非受限调度器是 &#x3D;&gt; 假设协程挂起前运行协程的线程是<code>t1</code>, 在协程挂起恢复后运行协程的线程可能是<code>t1</code>也可能是别的任意协程</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">        println(<span class="string">&quot;Unconfined      : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        println(<span class="string">&quot;Unconfined      : After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">&quot;main runBlocking: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;main runBlocking: After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终他会输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unconfined      : I&#x27;m working in thread main @coroutine#2</span><br><span class="line">main runBlocking: I&#x27;m working in thread main @coroutine#3</span><br><span class="line">Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor @coroutine#2</span><br><span class="line">main runBlocking: After delay in thread main @coroutine#3</span><br></pre></td></tr></table></figure>

<p>看到了没? 因为 <code>Unconfined</code> 做了个 <code>delay</code> 之后线程就变了, 而对照组没有任何的变化, 还是 <code>main</code> 线程在执行</p>
<p>为什么会变化呢? 因为协程在遇到 <code>delay</code> 之后<code>main</code>就已经去执行别的任务了, 剩下的事情由执行挂起函数的线程在执行<code>kotlinx.coroutines.DefaultExecutor</code>, 等到<code>Unconfined</code>协程恢复之后, 随机安排线程执行该协程</p>
<p>还有很多方式证明上面这条特性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">        println(<span class="string">&quot;Unconfined      : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123;&#125;</span><br><span class="line">        println(<span class="string">&quot;Unconfined      : After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">&quot;main runBlocking: I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123;&#125;</span><br><span class="line">        println(<span class="string">&quot;main runBlocking: After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unconfined      : I&#x27;m working in thread main</span><br><span class="line">Unconfined      : After delay in thread DefaultDispatcher-worker-1</span><br><span class="line">main runBlocking: I&#x27;m working in thread main</span><br><span class="line">main runBlocking: After delay in thread main</span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果是受限调度器执行的协程, 在协程挂起前面都是同一个线程</p>
<p>但, 如果是非受限调度器, 则挂起前后不是同一个线程</p>
</blockquote>
<h3 id="调试协程和线程"><a href="#调试协程和线程" class="headerlink" title="调试协程和线程"></a>调试协程和线程</h3><blockquote>
<p>协程可以在一个线程上挂起在另一个线程上恢复, ide可没这么智能, 没办法全程跟踪发现协程某时某刻到底在干啥</p>
</blockquote>
<h4 id="使用-idea-特殊插件调试"><a href="#使用-idea-特殊插件调试" class="headerlink" title="使用 idea 特殊插件调试"></a>使用 idea 特殊插件调试</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea768da5886447a58246a959e4c724d8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>使用<code>Coroutine</code>调试器，你可以：</p>
<ol>
<li>检查每个<code>Coroutine</code>的状态</li>
<li>查看运行和挂起的<code>Coroutines</code>的局部变量和捕获变量的值</li>
<li>查看完整的协程创建栈以及协程内部的调⽤栈。栈包含所有带有变量的栈帧，甚⾄包含那些在标准调试期间会丢失的栈帧</li>
<li>获取包含每个协程的状态以及栈信息的完整报告。要获取它，请右键单击 <code>Coroutines</code> 选项卡，然后点击 <code>Get Coroutines Dump</code></li>
</ol>
<h4 id="打印日志的方式调试"><a href="#打印日志的方式调试" class="headerlink" title="打印日志的方式调试"></a>打印日志的方式调试</h4><p>没什么好说的, <code>print</code> or <code>log</code> 把想要打印出来的信息打印出来完事</p>
<p><code>kotlin</code> 为了用户更好的使用日志调试, 增加了 <code>-Dkotlinx.coroutines.debug</code> 参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;IO      :  2 <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;main: 0 <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">        println(<span class="string">&quot;Unconfined      : 1 <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        doSomething()</span><br><span class="line">        println(<span class="string">&quot;Unconfined      : 3 <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用前:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">main: 0 <span class="title">main</span></span></span><br><span class="line"><span class="function"><span class="title">Unconfined</span>      : 1 <span class="title">main</span></span></span><br><span class="line"><span class="function"><span class="title">IO</span>      :  2 <span class="title">DefaultDispatcher</span>-<span class="title">worker</span>-1</span></span><br><span class="line"><span class="function"><span class="title">Unconfined</span>      : 3 <span class="title">DefaultDispatcher</span>-<span class="title">worker</span>-1</span></span><br></pre></td></tr></table></figure>

<p>使用后:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">main: 0 <span class="title">main</span> @<span class="title">coroutine</span>#1</span></span><br><span class="line"><span class="function"><span class="title">Unconfined</span>      : 1 <span class="title">main</span> @<span class="title">coroutine</span>#2</span></span><br><span class="line"><span class="function"><span class="title">IO</span>      :  2 <span class="title">DefaultDispatcher</span>-<span class="title">worker</span>-1 @<span class="title">coroutine</span>#2</span></span><br><span class="line"><span class="function"><span class="title">Unconfined</span>      : 3 <span class="title">DefaultDispatcher</span>-<span class="title">worker</span>-1 @<span class="title">coroutine</span>#2</span></span><br></pre></td></tr></table></figure>

<p>会发现多出了 <code>@coroutine#1</code> <code>@coroutine#2</code> 之类的字符, 这些就是协程标识符, 其中<code>@coroutine#1</code>就是主协程, 由 <code>runBlocking</code> 给予, 而 <code>@coroutine#2</code> 是子协程</p>
<blockquote>
<p>标识符只有在调试模式才能出现, 除了<code>-Dkotlinx.coroutines.debug</code> 外, 给VM增加 <code>-ea</code> 参数也能进入调试模式, 也可以打印出协程的名字</p>
</blockquote>
<h3 id="一个协程在多个线程之间跳转"><a href="#一个协程在多个线程之间跳转" class="headerlink" title="一个协程在多个线程之间跳转"></a>一个协程在多个线程之间跳转</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">&quot;[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newSingleThreadContext(<span class="string">&quot;ctx1&quot;</span>).use &#123; ctx1 -&gt;</span><br><span class="line">        newSingleThreadContext(<span class="string">&quot;ctx2&quot;</span>).use &#123; ctx2 -&gt;</span><br><span class="line">            runBlocking(ctx1) &#123;</span><br><span class="line">                log(<span class="string">&quot;Started in ctx1&quot;</span>)</span><br><span class="line">                withContext(ctx2) &#123;</span><br><span class="line">                    log(<span class="string">&quot;Working in ctx2&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;Back to ctx1&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ctx1 @coroutine#<span class="number">1</span>] Started <span class="keyword">in</span> ctx1</span><br><span class="line">[ctx2 @coroutine#<span class="number">1</span>] Working <span class="keyword">in</span> ctx2</span><br><span class="line">[ctx1 @coroutine#<span class="number">1</span>] Back to ctx1</span><br></pre></td></tr></table></figure>

<p>他展示了同一个协程在不同线程间执行的情况, 并且 上面使用了 <code>use</code> , 这样 <code>newSingleThreadContext</code> 申请的线程不用我们手动 <code>close</code></p>
<h3 id="子协程"><a href="#子协程" class="headerlink" title="子协程"></a>子协程</h3><p>当父协程被取消之后, 子协程都会递归取消</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test02</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> request = launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">&quot;job1: I have my own context and execute independently!&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job1: I am not affected by cancellation of the request&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> job2 = launch(coroutineContext) &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: I am a child of the request coroutine&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job2: 父协程被取消, 这一行不会执行&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        job1.join()</span><br><span class="line">        job2.join()</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    request.cancel()</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;main: Who has survived request cancellation?&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">job1: I have my own context and execute independently!</span><br><span class="line">job2: I am a child of the request coroutine</span><br><span class="line">main: Who has survived request cancellation?</span><br></pre></td></tr></table></figure>







<h3 id="为协程取名"><a href="#为协程取名" class="headerlink" title="为协程取名"></a>为协程取名</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>:<span class="built_in">Unit</span> = runBlocking(CoroutineName(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">    log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> v1 = async(CoroutineName(<span class="string">&quot;v1 coroutine&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        log(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="number">255</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> v2 = async(CoroutineName(<span class="string">&quot;v2 coroutine&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        log(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;4 result = <span class="subst">$&#123;v1.await() + v2.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组合协程上下⽂中的元素"><a href="#组合协程上下⽂中的元素" class="headerlink" title="组合协程上下⽂中的元素"></a>组合协程上下⽂中的元素</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    launch(Dispatchers.Default + CoroutineName(<span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合上下文, 将协程名字改成 <code>test</code></p>
<p><code>[DefaultDispatcher-worker-1 @test#2] 1</code></p>
<h3 id="协程的上下文继承"><a href="#协程的上下文继承" class="headerlink" title="协程的上下文继承"></a>协程的上下文继承</h3><p>如果新的协程在另一个协程的<code>CoroutineScope</code> 中创建, 则我们成新协程叫子协程, 而另一个协程叫父协程, 此时子协程上下文除<code>Job</code> 外都会继承至父协程, 而<code>Job</code>将会是父协程<code>Job</code> 的子作业, 但<code>Job</code> 是新的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> scope = CoroutineScope(Dispatchers.IO + Job() + CoroutineName(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">   <span class="keyword">val</span> job = scope.launch &#123;</span><br><span class="line">      log(<span class="string">&quot;1 <span class="subst">$&#123;coroutineContext[Job]&#125;</span>&quot;</span>)</span><br><span class="line">      launch &#123;</span><br><span class="line">         log(<span class="string">&quot;2 <span class="subst">$&#123;coroutineContext[Job]&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-<span class="number">1</span> @test#<span class="number">2</span>] <span class="number">1</span> &quot;test#<span class="number">2</span>&quot;:StandaloneCoroutine&#123;Active&#125;@<span class="number">3</span>eb7ab0f</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span> @test#<span class="number">3</span>] <span class="number">2</span> &quot;test#<span class="number">3</span>&quot;:StandaloneCoroutine&#123;Active&#125;@<span class="number">33</span>bb030c</span><br></pre></td></tr></table></figure>



<h3 id="线程本地数据"><a href="#线程本地数据" class="headerlink" title="线程本地数据"></a>线程本地数据</h3><p>我们知道 <code>ThreadLocal</code> 其实是在 <code>Thread</code> 中定义的一个变量<code>Map</code>， 使得该<code>Map</code>和我们的线程绑定在一起</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eadcc05f9c214d2e98c36fca6765cb74~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>只要我们 <code>new</code> 出一个 <code>Thread</code> 线程， 那么就会有一个 <code>threadLocals</code>的字段，但这个字段可能是 <code>null</code>， 如果我们调用了 <code>Threadlocal</code> 的 <code>set</code>、<code>get</code> 方法时才会创建他</p>
<p>不过讨论这个没啥用，但是我们可以借助这种方法，将 <code>ThreadLocal</code> 绑定在 <code>协程</code> 上， why？为什么要这么玩？</p>
<p>这里需要注意，<code>kotlin</code>的协程和线程可不是一对一的，是多对多</p>
<p>可能出现 <code>协程1</code> 此刻绑定 <code>线程1</code> 下一刻 <code>协程1</code> 便绑定于 <code>线程2</code> </p>
<p>这样令 <code>ThreadLocal</code> 很难做啊。。。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df2a211fb4714bb1b7a85bc9563efcd8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> threadLocal: ThreadLocal&lt;String?&gt; = ThreadLocal&lt;String?&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    threadLocal.<span class="keyword">set</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    log(<span class="string">&quot;1 <span class="subst">$&#123;threadLocal.get()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default + threadLocal.asContextElement(<span class="string">&quot;launch&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;2 <span class="subst">$&#123;threadLocal.get()&#125;</span>&quot;</span>)</span><br><span class="line">        yield()</span><br><span class="line">        log(<span class="string">&quot;3 <span class="subst">$&#123;threadLocal.get()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    log(<span class="string">&quot;4 <span class="subst">$&#123;threadLocal.get()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#<span class="number">1</span>] <span class="number">1</span> main</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span> @coroutine#<span class="number">2</span>] <span class="number">2</span> launch</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">2</span> @coroutine#<span class="number">2</span>] <span class="number">3</span> launch</span><br><span class="line">[main @coroutine#<span class="number">1</span>] <span class="number">4</span> main</span><br></pre></td></tr></table></figure>

<p>请注意：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DefaultDispatcher-worker-1 @coroutine#2] 2 launch</span><br><span class="line">[DefaultDispatcher-worker-2 @coroutine#2] 3 launch</span><br></pre></td></tr></table></figure>

<p>在不同的 <code>Thread</code> 有着相同的 <code>ThreadLocal</code> 值</p>
<p>但会出现新的问题, 协程无法判断 <code>ThreadLocal</code> 此时是否还是可用的, 是不是该协程可以访问的存在, 所以 <code>kotlin</code> 提供了一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.ensurePresent()</span><br></pre></td></tr></table></figure>

<p>检测 <code>ThreadLocal</code> 是否存在于当前的协程上下文中, 如果不存在则抛出异常 <code>IllegalStateException</code></p>
<blockquote>
<p><code>ThreadLocal</code>还有个有⼀个关键限制，即：当⼀个<strong>线程</strong>局部变量变化(<strong>注意不是协程改变的</strong>)时，则这个新值不会传播给协程调⽤者（因为上下⽂元素⽆法追踪所有 <code>ThreadLocal</code> 对象访问），并且下次挂起时更新的值将丢失</p>
</blockquote>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><blockquote>
<p>扩展知识, 本篇幅新手最好别看, 等学的差不多开始分析源码了, 再来</p>
</blockquote>
<h2 id="拦截器的作用是什么"><a href="#拦截器的作用是什么" class="headerlink" title="拦截器的作用是什么?"></a>拦截器的作用是什么?</h2><p>在kotlin中的拦截器可以拦截恢复调用, 所以也可以拦截我们的协程, 将协程交给我们想要的线程执行</p>
<h2 id="拦截器怎么用"><a href="#拦截器怎么用" class="headerlink" title="拦截器怎么用?"></a>拦截器怎么用?</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">	launch(LogInterceptor()) &#123;</span><br><span class="line">		log(<span class="string">&quot;launch ...&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogInterceptor</span> : <span class="type">ContinuationInterceptor</span> &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt;</span><br><span class="line">		<span class="keyword">get</span>() = ContinuationInterceptor</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> LogContinuation(continuation)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogContinuation</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">		<span class="keyword">get</span>() = continuation.context</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">		log(<span class="string">&quot;intercept before&quot;</span>)</span><br><span class="line">		continuation.resumeWith(result)</span><br><span class="line">		log(<span class="string">&quot;intercept after&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们需要知道 <code>Continuation</code> 是什么?</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现, 他有一个接口, 存放了一个协程上下文和<code>resumeWith</code>函数, 看这接口大概的用处应该是为了回调使用的</p>
<p>现在我们适量的往 源码 里探下, </p>
<p>从 launch 函数开始分析:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">// 组合协程上下文 , 这里可以把 CoroutineContext 当作一个 ArrayList</span></span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的 <code>LogInterceptor</code> 被存放在 <code>context</code> 中, 现在我们只要跟着它走, 就一定能找到 <code>ContinuationInterceptor</code> 拦截的关键时刻</p>
<p>上面那段代码记住 <code>start: CoroutineStart = CoroutineStart.DEFAULT</code>, 这段代码, 用户后续判断</p>
<p><code>newContext</code> 我们可以将其当作 <code>ArrayList</code>, 用于组合多个 <code>Element</code> 参数 (前面说过的, 协程上下文可以组合的)</p>
<p>下面是协程上下文组合的函数, 可以不用看</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext =</span><br><span class="line">    <span class="keyword">if</span> (context === EmptyCoroutineContext) <span class="keyword">this</span> <span class="keyword">else</span> <span class="comment">// fast path -- avoid lambda creation</span></span><br><span class="line">        context.fold(<span class="keyword">this</span>) &#123; acc, element -&gt;</span><br><span class="line">            <span class="keyword">val</span> removed = acc.minusKey(element.key)</span><br><span class="line">            <span class="keyword">if</span> (removed === EmptyCoroutineContext) element <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// make sure interceptor is always last in the context (and thus is fast to get when present)</span></span><br><span class="line">                <span class="keyword">val</span> interceptor = removed[ContinuationInterceptor]</span><br><span class="line">                <span class="keyword">if</span> (interceptor == <span class="literal">null</span>) CombinedContext(removed, element) <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> left = removed.minusKey(ContinuationInterceptor)</span><br><span class="line">                    <span class="keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="keyword">else</span></span><br><span class="line">                        CombinedContext(CombinedContext(left, element), interceptor)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>回到核心需要分析的代码</p>
<p>核心代码在这里 <code>coroutine.start(start, coroutine, block)</code> 我们跟进去看看, 记住第二个参数里面存着我们的 <code>LogInterceptor</code> 拦截器的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">startCoroutineImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    receiver: <span class="type">R</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    completion: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = <span class="keyword">when</span> (start) &#123;</span><br><span class="line">    CoroutineStart.DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion, onCancellation)</span><br><span class="line">    CoroutineStart.ATOMIC -&gt; block.startCoroutine(receiver, completion)</span><br><span class="line">    CoroutineStart.UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)</span><br><span class="line">    CoroutineStart.LAZY -&gt; <span class="built_in">Unit</span> <span class="comment">// will start lazily</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们记住的代码: <code>start: CoroutineStart = CoroutineStart.DEFAULT</code> 你看这不是对上了么? 走的</p>
<p><code>CoroutineStart.DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion, onCancellation)</code></p>
<p>最终我们找到了这段代码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(</span><br><span class="line">    receiver: R, completion: Continuation&lt;T&gt;,</span><br><span class="line">    onCancellation: ((cause: Throwable) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">) =</span><br><span class="line">    runSafely(completion) &#123;</span><br><span class="line">        createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>), onCancellation)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>createCoroutineUnintercepted</code> 没办法分析, 不过看起来不像, 我们就跟进 <code>intercepted</code> </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<p>进入后看到最终的代码了: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">    intercepted</span><br><span class="line">        ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">            .also &#123; intercepted = it &#125;</span><br></pre></td></tr></table></figure>

<p><code>ContinuationInterceptor</code> 就跟我们前面的 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogInterceptor</span> : <span class="type">ContinuationInterceptor</span> &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt;</span><br><span class="line">		<span class="keyword">get</span>() = ContinuationInterceptor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> key 值一样, 而上面的操作就跟下面的操作一个样</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; context = new ArrayList();</span><br><span class="line">intercepted = context[ContinuationInterceptor];</span><br></pre></td></tr></table></figure>

<p>最终拿到了我们的 <code>LogInterceptor</code> 并且返回了</p>
<p>最终会回到这里: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(</span><br><span class="line">    receiver: R, completion: Continuation&lt;T&gt;,</span><br><span class="line">    onCancellation: ((cause: Throwable) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">) =</span><br><span class="line">    runSafely(completion) &#123;</span><br><span class="line">        createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>), onCancellation)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们把上面代码稍微改下, 更好理解 <code>LogInterceptor.resumeCancellableWith(Result.success(Unit), onCancellation)</code></p>
<p>很明显了, 我们跟进<code>resumeCancellableWith</code> 函数, 发现: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)</span><br><span class="line">    <span class="keyword">else</span> -&gt; resumeWith(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是 <code>LogInterceptor</code> 调用的   <code>resumeCancellableWith</code> 函数, 所以 <code>this</code> 明显不是 <code>is DispatchedContinuation</code> , 我们的代码只会走 <code>else -&gt; resumeWith(result)</code> </p>
<p>最后你会发现它回到我们的代码了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogContinuation</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">		<span class="keyword">get</span>() = continuation.context</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 代码回到这个函数</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">		log(<span class="string">&quot;intercept before&quot;</span>)</span><br><span class="line">		continuation.resumeWith(result)</span><br><span class="line">		log(<span class="string">&quot;intercept after&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着执行完 <code>resumeWith</code> 我们定义的函数</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bangiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bangiao.github.io/2022/12/03/07kotlin/十一、kotlin的协程(一)/">https://bangiao.github.io/2022/12/03/07kotlin/十一、kotlin的协程(一)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5/">异步</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a><a class="post-meta__tags" href="/tags/%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B/">无栈协程</a><a class="post-meta__tags" href="/tags/%E6%9C%89%E6%A0%88%E5%8D%8F%E7%A8%8B/">有栈协程</a><a class="post-meta__tags" href="/tags/%E8%B0%83%E5%BA%A6/">调度</a><a class="post-meta__tags" href="/tags/%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0/">挂起函数</a><a class="post-meta__tags" href="/tags/suspend/">suspend</a><a class="post-meta__tags" href="/tags/runBlocking/">runBlocking</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E4%BD%9C%E7%94%A8%E5%9F%9F/">协程作用域</a><a class="post-meta__tags" href="/tags/%E7%AD%89%E5%BE%85%E5%8D%8F%E7%A8%8B%E7%BB%93%E6%9D%9F/">等待协程结束</a><a class="post-meta__tags" href="/tags/job/">job</a><a class="post-meta__tags" href="/tags/%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/">结构化并发</a><a class="post-meta__tags" href="/tags/coroutineScope/">coroutineScope</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E5%8F%96%E6%B6%88/">协程取消</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E8%B6%85%E6%97%B6/">协程超时</a><a class="post-meta__tags" href="/tags/NonCancellable/">NonCancellable</a><a class="post-meta__tags" href="/tags/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88/">超时取消</a><a class="post-meta__tags" href="/tags/%E7%BB%84%E5%90%88%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0/">组合挂起函数</a><a class="post-meta__tags" href="/tags/async/">async</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91/">异步结构化并发</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B0%83%E5%BA%A6%E5%99%A8/">协程上下文调度器</a><a class="post-meta__tags" href="/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/">调度器</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/">协程上下文</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/">协程和线程的区别</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a><a class="post-meta__tags" href="/tags/%E9%9D%9E%E5%8F%97%E9%99%90%E8%B0%83%E5%BA%A6%E5%99%A8/">非受限调度器</a><a class="post-meta__tags" href="/tags/%E5%8F%97%E9%99%90%E8%B0%83%E5%BA%A6%E5%99%A8/">受限调度器</a><a class="post-meta__tags" href="/tags/%E8%B0%83%E8%AF%95%E5%8D%8F%E7%A8%8B/">调试协程</a><a class="post-meta__tags" href="/tags/idea%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95/">idea插件调试</a><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%BF%97/">日志</a><a class="post-meta__tags" href="/tags/%E5%AD%90%E5%8D%8F%E7%A8%8B/">子协程</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E5%8F%96%E5%90%8D/">协程取名</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%A7%E6%89%BF/">协程上下文继承</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE/">线程本地数据</a><a class="post-meta__tags" href="/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/12/03/07kotlin/kotlin%E7%9A%84%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/"><i class="fa fa-chevron-left">  </i><span>kotlin的集合操作</span></a></div><div class="next-post pull-right"><a href="/2022/12/03/07kotlin/%E5%8D%81%E4%B8%80%E3%80%81kotlin%E7%9A%84%E5%8D%8F%E7%A8%8B(%E4%BA%8C)%E2%80%94%E2%80%94%E5%86%B7%E6%B5%81flow/"><span>十一、kotlin的协程(二)——冷流flow</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2022 By Bangiao</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这是博客github仓库地址：<a target="_blank" rel="noopener" href="https://github.com/bangiao/bangiao.github.io">bangiao.github.io</a>，欢迎访问!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>