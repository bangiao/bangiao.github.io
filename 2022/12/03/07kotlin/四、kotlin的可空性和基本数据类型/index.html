<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="四、kotlin的可空性和基本数据类型(一)"><meta name="keywords" content="懒加载,lateinit,类型转换,可空性,基本数据类型,问号表达式,elvis运算符,if,!!.,?,非空断言运算符,先决条件函数,as?,安全类型转换,延迟初始化,惰性初始化,泛型可空性,平台类型,其他数据类型,数字转换,Any,Any?,根类型,Unit类型,void,Nothing类型,可空性集合"><meta name="author" content="Bangiao"><meta name="copyright" content="Bangiao"><title>四、kotlin的可空性和基本数据类型(一) | Bangiao's Notebooks</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">可空性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">怎么用?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E4%BD%BF%E7%94%A8%E5%AE%89%E5%85%A8%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.1.</span> <span class="toc-text">方法一: 使用安全调用运算符 ?.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-Elvis%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.2.</span> <span class="toc-text">方法二: Elvis运算符 ?:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89-if"><span class="toc-number">1.3.3.</span> <span class="toc-text">方法三: if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B-%E4%BD%BF%E7%94%A8%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.4.</span> <span class="toc-text">方法四: 使用非空断言运算符!!.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%94-%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">方式五: 先决条件函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%BD%AC%E6%8D%A2-as"><span class="toc-number">1.4.</span> <span class="toc-text">安全转换 as?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">let 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E6%80%A7%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">可空性扩展函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96-lateinit"><span class="toc-number">1.7.</span> <span class="toc-text">延迟初始化 lateinit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD-lateinit-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.1.</span> <span class="toc-text">判断 lateinit 修饰的对象是否已经被初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.8.</span> <span class="toc-text">懒加载初始化(惰性初始化)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%AF%E7%A9%BA%E6%80%A7-%E6%B3%9B%E5%9E%8B%E5%8F%AF%E7%A9%BA%E6%80%A7"><span class="toc-number">1.9.</span> <span class="toc-text">类型参数的可空性(泛型可空性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E6%80%A7%E5%9C%A8-kotlin-%E5%92%8C-java-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text">可空性在 kotlin 和 java 之间的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">平台类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E7%B1%BB%E5%9E%8B%E9%81%87%E5%88%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">平台类型遇到继承</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">基本数据类型和其他数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">可空的基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">数字转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Any-%E5%92%8C-Any-%E6%A0%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">Any 和 Any? 根类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unit-%E7%B1%BB%E5%9E%8B-kotlin-%E7%9A%84-void"><span class="toc-number">2.5.</span> <span class="toc-text">Unit 类型: kotlin 的 void</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nothing-%E7%B1%BB%E5%9E%8B-%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E4%B8%8D%E8%BF%94%E5%9B%9E"><span class="toc-number">2.6.</span> <span class="toc-text">Nothing 类型: 这个函数不返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E6%80%A7%E5%92%8C%E9%9B%86%E5%90%88"><span class="toc-number">2.7.</span> <span class="toc-text">可空性和集合</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://imgsa.baidu.com/forum/pic/item/c8179682d158ccbf63dc944d1bd8bc3eb03541a9.jpg"></div><div class="author-info__name text-center">Bangiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/bangiao">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">632</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的博客</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/4248168662314823">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30690165">CSDN</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/bangiao/">博客园</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/projects">Gitee笔记源码</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bangiao's Notebooks</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章列表</a><a class="site-page" href="/tags">文章标签</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/sources">笔记源码</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">四、kotlin的可空性和基本数据类型(一)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h1><blockquote>
<p>前言: 可空性是kotlin类型系统提供的功能, 帮助你避免 <code>NullPointerException</code> </p>
</blockquote>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h2><p>是一种可以为 <code>null</code> 的类型, 本质是下面这样: </p>
<blockquote>
<p><code>Type? == Type or null</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: String? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说白了, 你就把他当作一种新的类型就好, 这样的话, 如果遇到</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="built_in">Int</span>? = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="built_in">Int</span> = a <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>这面这种情况时, 不会觉得诧异, 毕竟是不同的类型不是么??? </p>
</blockquote>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在不影响程序运行性能的前提下, 显示的帮助程序员避免空指针异常 <code>NullPointerException</code> </p>
<blockquote>
<p>可空类型在编译期间, 就把空指针异常解决了, 在运行期间不做任何操作, 所以不影响运行时性能</p>
</blockquote>
<p>在java中这样容易出现空指针异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strLen</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length(); <span class="comment">// 这句话无法确定 s 是否为 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际的java项目,  都需要 <code>if</code> 判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用 三目运算符, 一行解决, 但也很麻烦</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strLen</span><span class="params">(String s)</span>  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == s || (len = s.length()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;字符串长度为空&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然 <code>jdk1.8</code> 之后出现的 <code>Optional</code> , 但还是麻烦的, 不仅使代码变得冗长而且还存在性能问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strLen</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(s).orElse(<span class="string">&quot;&quot;</span>).length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 kotlin 重写这个函数前需要程序员主动判断该函数是否接受实参为空的情况, 如果需要支持的话, </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>?)</span></span> = s?.length</span><br></pre></td></tr></table></figure>

<p>在上面代码中, <code>s?.length</code> 如果 <code>s</code> 为 <code>null</code> 的话, 则该函数直接返回 <code>null</code> , 函数调用者 可以借助返回值 <code>null</code> 使用 <code>if</code> 判断是否为空</p>
<p>如果实参一定不为 <code>null</code> 的话, 则</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s: <span class="type">String</span>)</span></span> = s.length</span><br></pre></td></tr></table></figure>

<p>对了, 和前面的 <code>when</code> 的 <code>is Int</code> 智能转换一样, 可空类型也存在智能转换</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: String? = <span class="string">&quot;zhazha&quot;</span></span><br><span class="line"><span class="keyword">var</span> b: String</span><br><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    b = a <span class="comment">// 这行代码不会报错</span></span><br><span class="line">    println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用?"></a>怎么用?</h2><h3 id="方法一-使用安全调用运算符"><a href="#方法一-使用安全调用运算符" class="headerlink" title="方法一: 使用安全调用运算符 ?."></a>方法一: 使用安全调用运算符 <code>?.</code></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753393955ad740659132ca2cbff3cb3e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 前面的示例代码中 <code>s?.length</code> 会发现 <code>?</code> 运算符, 这种方式相当于</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="literal">null</span> <span class="keyword">else</span> s.length</span><br></pre></td></tr></table></figure>

<p>如果 <code>s == null</code> 的情况下 整个 <code>s?.length</code> 表达式的值为 <code>null</code>, 在该表达式为 <code>null</code> 的情况下, 会出现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> len: <span class="built_in">Int</span>? = s?.length</span><br><span class="line"><span class="comment">//          👆</span></span><br></pre></td></tr></table></figure>
<p>接收该函数返回值的变量类型也应该是 可空的, 毕竟结果可能是 <code>null</code></p>
<p>所以使用安全调用操作符<code>?</code>, 其接收结果的变量也需要可空操作符</p>
<p>另外 <code>?</code> 运算符还可以链式调用, 比如: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name:String? = person?.children?.name</span><br></pre></td></tr></table></figure>

<p>只要有一步骤结果为 <code>null</code>, 后面的代码不再运行, 整个表达式的结果为 <code>null</code> </p>
<blockquote>
<p><code>?</code> 这种方式是线程安全的</p>
</blockquote>
<h3 id="方法二-Elvis运算符"><a href="#方法二-Elvis运算符" class="headerlink" title="方法二: Elvis运算符 ?:"></a>方法二: Elvis运算符 <code>?:</code></h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c77ccc6f4321488f8c4d88b09b1d75c9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> firstName: String? = <span class="string">&quot;zhazha&quot;</span></span><br><span class="line"><span class="keyword">val</span> lastName: String = firstName ?: <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到使用这种方式之后 <code>?</code> 运算符消失了</p>
<p>类似于:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (firstName == <span class="literal">null</span>) <span class="string">&quot;&quot;</span> <span class="keyword">else</span> firstName</span><br></pre></td></tr></table></figure>

<p>Elvis 还是这样: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lastName: String = firstName ?: <span class="keyword">throw</span> Exception(<span class="string">&quot;错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="方法三-if"><a href="#方法三-if" class="headerlink" title="方法三: if"></a>方法三: if</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (firstName != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> lastName: String = firstName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方法在你觉得代码可读性比较低时，使用, 但是有个前提, <code>firstName</code> 不为 <code>共享变量</code>(多线程的共享变量), 否则还是会报错</p>
</blockquote>
<h3 id="方法四-使用非空断言运算符"><a href="#方法四-使用非空断言运算符" class="headerlink" title="方法四: 使用非空断言运算符!!."></a>方法四: 使用非空断言运算符<code>!!.</code></h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/692d561548654970b2e40c509ef586a8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>使用这种方式确实可以脱下<code>?</code> 外衣, 但对于空指针的检测直接关闭了, 表达式中的变量是否会发生空指针异常已经不管了</p>
<blockquote>
<p><strong>这里的“已经不管了”，是错的</strong>。正确的说法是 <code>null!!</code> 如果对象本身就是 <code>null</code> 直接抛出<strong>空指针异常</strong>，所以 <code>!!</code> 是一种不负责任的行为，除非你能保证该变量百分百不会是 <code>null</code>，最好别用，可以使用 <code>?:</code> 代替</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> firstName: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> lastName: String = firstName</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式不推荐使用, 除非你能保证该值绝对不为空, 比如: 不使用 <code>object</code> 定义的单例</p>
</blockquote>
<h3 id="方式五-先决条件函数"><a href="#方式五-先决条件函数" class="headerlink" title="方式五: 先决条件函数"></a>方式五: 先决条件函数</h3><p>这些函数都能脱下 <code>?</code> 外衣</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> firstName: String? = <span class="literal">null</span></span><br><span class="line"><span class="comment">//    checkNotNull(firstName)</span></span><br><span class="line"><span class="comment">//    checkNotNull(firstName) &#123; &quot;firstName 为空&quot; &#125;</span></span><br><span class="line"><span class="comment">//    requireNotNull(firstName) &#123; &quot;firstName 为空&quot; &#125;</span></span><br><span class="line"><span class="comment">//    check(firstName != null)</span></span><br><span class="line">    require(firstName != <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">val</span> s: String = firstName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要给函数类型添加可空性, <code>val funType: (() -&gt; T)?</code> 这样做</p>
</blockquote>
<h2 id="安全转换-as"><a href="#安全转换-as" class="headerlink" title="安全转换 as?"></a>安全转换 <code>as?</code></h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60051973236245e59d46d522570a16d7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>前面的章节学过, as 作为强转操作符, 在使用的过程中可以 配合 is 强制转换, 但如果类型转化不成功就会报<code>ClassCastException</code></p>
<p>所以kotlin创造了 <code>as?</code> 使用方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Any</span>, b: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c: <span class="built_in">Int</span>? = a <span class="keyword">as</span>? <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">val</span> d: <span class="built_in">Int</span>? = b <span class="keyword">as</span>? <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在例子中, 如果 Any 参数指向的类型不是 Int , 则返回 null 给 c 变量, 否则强转成功</p>
<p>一般 <code>as?</code> 配合 <code>?:</code> 使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Any</span>, b:<span class="type">Any</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c: <span class="built_in">Int</span> = a <span class="keyword">as</span>? <span class="built_in">Int</span> ?: <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> d: <span class="built_in">Int</span> = b <span class="keyword">as</span>? <span class="built_in">Int</span> ?: <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> c + d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="let-函数"><a href="#let-函数" class="headerlink" title="let 函数"></a><code>let</code> 函数</h2><p><code>let</code> 函数源码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出它就是个<code>扩展函数</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str:String? = <span class="literal">null</span></span><br><span class="line">    println(str?.let &#123; it.length + <span class="number">100</span> &#125;) <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出了 <code>null</code> , <code>str == null</code>, 所以 <code>str? == null</code> 后面的<code>let</code>函数将不执行, 直接返回 <code>null</code> 但是我们需要 <code>null</code> 的时候等于 <code>0</code> 最终要打印 <code>100</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str:String? = <span class="literal">null</span></span><br><span class="line">    println(str.let &#123; (it?.length ?: <span class="number">0</span>) + <span class="number">100</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看到代码中的 <code>str.let</code> 了么? <code>str == null</code> 但是 <code>str.let</code> 却不会报错? 看的出来 扩展函数 的优势了么? <code>null.let</code> 不会报错, 了解扩展函数的本质后, 会发现不报错也合理, 扩展函数仅仅是把目标对象的 <code>this</code> 当作 形式参数 , 但这里的 <code>this</code> 是 <code>null</code> , 传递一个等于 <code>null</code> 的参数没问题吧???</p>
</blockquote>
<h2 id="可空性扩展函数"><a href="#可空性扩展函数" class="headerlink" title="可空性扩展函数"></a>可空性扩展函数</h2><p>为可空类型定义扩展函数处理 <code>null</code> 问题</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str.isNullOrBlank()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> Exception(<span class="string">&quot;str == null or str is blank&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码就类似这样: <code>return this == null || this.isBlank()</code> </p>
<p>可以看的出来 <code>str == null</code> 而 <code>null</code> 能调用 <code>null.isNullOrBlank()</code> (null直接调用 <code>isNullOrBlank</code> 会报错, 但 把 <code>null</code> 赋值给 <code>str</code> , 再调用 <code>isNullOrBlank</code> 不会报错)</p>
<blockquote>
<p>只有扩展函数才能做到这一点，普通成员方法的调用是通过对象实例来分发的，因此实例为 <code>null</code> 时（成员方法）永远不能被执行。</p>
</blockquote>
<h2 id="延迟初始化-lateinit"><a href="#延迟初始化-lateinit" class="headerlink" title="延迟初始化 lateinit"></a>延迟初始化 <code>lateinit</code></h2><p>很多时候, 成员属性的初始化未必全部都需要在构造函数内完成, 看下面这段代码的成员属性 <code>a</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="keyword">val</span> b: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a: Person <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">constructor</span>(a: Person, b: <span class="built_in">Int</span>) : <span class="keyword">this</span>(b) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// init balabala</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>a</code> 报错, 主要的问题是 kotlin 对象的初始化顺序是 </p>
<p>调用<code>主构造函数</code> &#x3D;&gt; <code>主构造外的成员属性或者init代码块</code>(根据这俩的定义顺序判断) &#x3D;&gt; 再调用<code>次构造函数</code></p>
<blockquote>
<p>比如 <code>b</code> 在主构造函数内, 而 <code>a</code> 在主构造函数外</p>
</blockquote>
<blockquote>
<p>次构造函数在构建一个对象的时候, 会调用两个构造函数, 一个是主构造函数, 另一个是次构造函数(在有主构造函数的前提下, 如果没有, 类里面全都是次构造函数则不然)</p>
</blockquote>
<p>而 <code>主构造函数外属性</code> 和 <code>init代码块</code> 在构造一个对象时, 都会被编译器放入到 <code>主构造函数体内</code> </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这是主构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>(b: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b</span><br><span class="line">    <span class="comment">// 上面就是主构造全部的内容</span></span><br><span class="line">    <span class="comment">// 接下来是init和主构造函数外属性的内容</span></span><br><span class="line">    <span class="keyword">this</span>.a = ? <span class="comment">// error, 在初始化变量 a 的时候不清楚要给它初始化成什么???? 所以报错了</span></span><br><span class="line">    <span class="comment">// init balabala</span></span><br><span class="line">    <span class="comment">// 然后再调用次构造函数(如果你使用次构造函数构造一个对象的话)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后调用次构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>(a: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a <span class="comment">// 在次构造函数初始化时, 主构造函数报错了, 次构造函数来不及构建一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遇到这种情况一般都解决方案都是 <code>var a: Int = 0</code> 给它初始化, 但是在一些架构中, 人家有专门的初始化方案, 不需要程序员主动帮助初始化, 比如: <code>Spring</code></p>
<p>这时候就需要 <code>lateinit</code> 关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="keyword">val</span> b: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> a: Person</span><br><span class="line">    <span class="keyword">constructor</span>(a: Person, b: <span class="built_in">Int</span>) : <span class="keyword">this</span>(b) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// init balabala</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这关键字有限制的: </p>
<ol>
<li>不能修饰 <code>val</code> 属性, 只能修饰 <code>var</code></li>
<li>不能修饰基础数据类型, 比如: <code>Int Double Float Long</code> 之类的属性</li>
</ol>
<h3 id="判断-lateinit-修饰的对象是否已经被初始化"><a href="#判断-lateinit-修饰的对象是否已经被初始化" class="headerlink" title="判断 lateinit 修饰的对象是否已经被初始化"></a>判断 <code>lateinit</code> 修饰的对象是否已经被初始化</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> equipment: String</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ready</span><span class="params">()</span></span> &#123;</span><br><span class="line">        equipment = <span class="string">&quot;sharp knife&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">battle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>::equipment.isInitialized) &#123;</span><br><span class="line">            println(equipment)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="懒加载初始化-惰性初始化"><a href="#懒加载初始化-惰性初始化" class="headerlink" title="懒加载初始化(惰性初始化)"></a>懒加载初始化(惰性初始化)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> config: String <span class="keyword">by</span> lazy &#123; loadConfig() &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadConfig</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;load Config...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;xxxxxxxxx&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br></pre></td></tr></table></figure>

<p>lazy 后面传入的是 函数类型 , 一个无参数的返回 T 类型的函数类型 <code>() -&gt; T</code></p>
<h2 id="类型参数的可空性-泛型可空性"><a href="#类型参数的可空性-泛型可空性" class="headerlink" title="类型参数的可空性(泛型可空性)"></a>类型参数的可空性(泛型可空性)</h2><p>类型参数传递可以是空的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printHashCode</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    print(t?.hashCode())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    printHashCode(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型参数传递的是 <code>T</code> 没有任何的 <code>?</code> , 但是仍然可以传递 <code>null</code> , 这时在函数内部如果没写上 <code>t?</code> 那么就会报 空指针异常 </p>
<blockquote>
<p><code>null</code> 的类型是 <code>Any?</code></p>
</blockquote>
<h2 id="可空性在-kotlin-和-java-之间的问题"><a href="#可空性在-kotlin-和-java-之间的问题" class="headerlink" title="可空性在 kotlin 和 java 之间的问题"></a>可空性在 kotlin 和 java 之间的问题</h2><h3 id="平台类型"><a href="#平台类型" class="headerlink" title="平台类型"></a>平台类型</h3><p>kotlin调用 java 的函数时, 无法判断 java 的参数是否为 可空性 , 所以专门推出了 平台类型</p>
<p><code>java的平台类型 = kotlin的可空类型 or kotlin的非空类型</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bee8549629f465fa27bf58f0202c2ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这项判断由程序员自主判断</p>
<p>在java下, 创建 <code>Person</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 kotlin 中使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">yellAt</span><span class="params">(person: <span class="type">Person</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//    println(person.name.toUpperCase() + &quot;!!!&quot;) // java.lang.NullPointerException: person.name must not be null</span></span><br><span class="line">    println(person.name?.toUpperCase() + <span class="string">&quot;!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="literal">null</span>)</span><br><span class="line">    yellAt(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>person: Person</code> 参数没有 可空性 <code>?</code>, 但他是 <code>平台类型</code>, 程序员可以选择是否按照可空类型判断 <code>person.name?.toUpperCase()</code>, 也可以按照非空判断 <code>person.name.toUpperCase()</code> 怎么不报错怎么来</p>
<p>kotlin 用 <code>Person!</code> 表示一个来自java平台的 平台类型 , 用户不可以自行使用 <code>!</code> , 它仅仅是提示程序员 该变量 未知可空性</p>
<h4 id="平台类型遇到继承"><a href="#平台类型遇到继承" class="headerlink" title="平台类型遇到继承"></a>平台类型遇到继承</h4><p>kotlin 继承重写 java 函数时, 可以选择 类型为 可空的 ,也可以选择类型为 非空的 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StringProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringPrinter</span> : <span class="type">StringProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NullableStringPrinter</span> : <span class="type">StringProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(value: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        println(value ?: <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="基本数据类型和其他数据类型"><a href="#基本数据类型和其他数据类型" class="headerlink" title="基本数据类型和其他数据类型"></a>基本数据类型和其他数据类型</h1><blockquote>
<p>kotlin 没有包装类型</p>
</blockquote>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol>
<li>kotlin不区分基本数据类型和包装类型, kotlin使用的都是包装类型,但是在运行时使用的却是基础类型. 对kotlin编码期间的函数最终都会被kotlin编译器修改成对基础类型的操作</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="built_in">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> plus = a.plus(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>java 反编译后: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">plus</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不得不吹一波 kotlin 编译器的强大, 但强大带来的却是编译速度缓慢, 哎~~~</p>
</blockquote>
<ol start="2">
<li>泛型的基本数据类型最终会被编译成 <code>Integer</code></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br></pre></td></tr></table></figure>

<p>Java: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>kotlin的基本数据类型不能存储 <code>null</code></li>
</ol>
<p>kotlin的基本数据类型和java的一致, 都不能存储 <code>null</code>, java的基本数据类型在 kotlin 中不会变成 平台类型 而是直接变成 基本数据类型 </p>
<h2 id="可空的基本数据类型"><a href="#可空的基本数据类型" class="headerlink" title="可空的基本数据类型"></a>可空的基本数据类型</h2><p>kotlin的可空基本数据类型无法翻译成 java 的 基本数据类型, 所以任何可空类型, 最终都会变成 包装类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>?) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">isOldThan</span><span class="params">(other: <span class="type">Person</span>)</span></span>: <span class="built_in">Boolean</span>? = <span class="keyword">this</span>.age?.let &#123;</span><br><span class="line">      other.age?.let &#123; it2 -&gt;</span><br><span class="line">         it &gt; it2</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> person = Person(<span class="string">&quot;zhazha&quot;</span>, <span class="number">23</span>)</span><br><span class="line">   <span class="keyword">val</span> person1 = Person(<span class="string">&quot;xixix&quot;</span>, <span class="number">21</span>)</span><br><span class="line">   <span class="keyword">val</span> b = person.isOldThan(person1)</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">null</span> == b) println(<span class="string">&quot;不清楚&quot;</span>) <span class="keyword">else</span> <span class="keyword">if</span> (b) println(<span class="string">&quot;大于&quot;</span>) <span class="keyword">else</span> println(<span class="string">&quot;小于&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h2><ol>
<li>kotlin 不会将基本数据类型隐式转换, 比如 小范围的<code>Int</code> 变量转换成 <code>Long</code>, 这和java还是有区别, 这样做的好处在于更加的安全可控</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span> = a <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>kotlin 对每个基本数据类型提供了 <code>toXXXX</code> 函数(除了 <code>Boolean</code>), 这种显示的转换可以大范围转小范围, 也可小范围转大范围</p>
</li>
<li><p>在 java 中, 包装类型的比较会出现下面这种问题</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">42</span>).equals(<span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">42</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这俩明明都是 <code>42</code> 但不相等, 在 java 中 <code>equals</code> 有判断类型的, 所以会返回<code>false</code>, 如果需要则要转换成相同类型</p>
<p>在 kotlin 中, 如果变量没有转换到同一个类型, 也无法比较</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4390222b93db446cb2c0a70990a4122b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>需要转换</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c406ea1c329442978c86e3cb7999c737~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="Any-和-Any-根类型"><a href="#Any-和-Any-根类型" class="headerlink" title="Any 和 Any? 根类型"></a>Any 和 Any? 根类型</h2><ol>
<li><p><code>Any</code> 类似于 java 的<code>Object</code> 对象, 是 kotlin 所有非空类的共有根类, 而不论是空类还是非空类的所有类都可以传给 <code>Any?</code></p>
</li>
<li><p><code>Any</code> 有很多 <code>Object</code> 的函数, 但并不是所有, 有些函数 比如 <code>wait / notify</code> 函数只能通过 <code>Any</code> 强转成 <code>Object</code> 来调用该函数</p>
</li>
</ol>
<h2 id="Unit-类型-kotlin-的-void"><a href="#Unit-类型-kotlin-的-void" class="headerlink" title="Unit 类型: kotlin 的 void"></a>Unit 类型: kotlin 的 void</h2><p><code>Unit</code> 和 <code>void</code> 的差别在于: </p>
<ol>
<li><p>在 kotlin 中, <code>Unit</code> 是一个类, <code>Unit</code> 可以当作函数的参数, 平时使用时 <code>Unit</code> 会被转化成 java 的 <code>void</code></p>
</li>
<li><p><code>Unit</code> 不需要主动的 <code>return</code> , 会隐式的返回 <code>Unit</code></p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">&quot;kotlin.Unit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nothing-类型-这个函数不返回"><a href="#Nothing-类型-这个函数不返回" class="headerlink" title="Nothing 类型: 这个函数不返回"></a>Nothing 类型: 这个函数不返回</h2><p><code>Nothing</code> 没有值, 只有被当作函数返回值或者被当作泛型函数返回值的类型参数使用才会有意义</p>
<p>源码: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nothing</span> <span class="keyword">private</span> <span class="keyword">constructor</span>()</span><br></pre></td></tr></table></figure>

<p>使用: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(message: <span class="type">String</span>)</span></span>: <span class="built_in">Nothing</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> Exception(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可空性和集合"><a href="#可空性和集合" class="headerlink" title="可空性和集合"></a>可空性和集合</h2><p><code>List&lt;Int?&gt;</code> 和 <code>List&lt;Int?&gt;?</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7e9c35234ec4c2592c009ffda0e8cc1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bangiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bangiao.github.io/2022/12/03/07kotlin/四、kotlin的可空性和基本数据类型/">https://bangiao.github.io/2022/12/03/07kotlin/四、kotlin的可空性和基本数据类型/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/">懒加载</a><a class="post-meta__tags" href="/tags/lateinit/">lateinit</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">类型转换</a><a class="post-meta__tags" href="/tags/%E5%8F%AF%E7%A9%BA%E6%80%A7/">可空性</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">基本数据类型</a><a class="post-meta__tags" href="/tags/%E9%97%AE%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/">问号表达式</a><a class="post-meta__tags" href="/tags/elvis%E8%BF%90%E7%AE%97%E7%AC%A6/">elvis运算符</a><a class="post-meta__tags" href="/tags/if/">if</a><a class="post-meta__tags" href="/tags/">!!.</a><a class="post-meta__tags" href="/tags/">?</a><a class="post-meta__tags" href="/tags/%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6/">非空断言运算符</a><a class="post-meta__tags" href="/tags/%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6%E5%87%BD%E6%95%B0/">先决条件函数</a><a class="post-meta__tags" href="/tags/as/">as?</a><a class="post-meta__tags" href="/tags/%E5%AE%89%E5%85%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">安全类型转换</a><a class="post-meta__tags" href="/tags/%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96/">延迟初始化</a><a class="post-meta__tags" href="/tags/%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96/">惰性初始化</a><a class="post-meta__tags" href="/tags/%E6%B3%9B%E5%9E%8B%E5%8F%AF%E7%A9%BA%E6%80%A7/">泛型可空性</a><a class="post-meta__tags" href="/tags/%E5%B9%B3%E5%8F%B0%E7%B1%BB%E5%9E%8B/">平台类型</a><a class="post-meta__tags" href="/tags/%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">其他数据类型</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/">数字转换</a><a class="post-meta__tags" href="/tags/Any/">Any</a><a class="post-meta__tags" href="/tags/Any/">Any?</a><a class="post-meta__tags" href="/tags/%E6%A0%B9%E7%B1%BB%E5%9E%8B/">根类型</a><a class="post-meta__tags" href="/tags/Unit%E7%B1%BB%E5%9E%8B/">Unit类型</a><a class="post-meta__tags" href="/tags/void/">void</a><a class="post-meta__tags" href="/tags/Nothing%E7%B1%BB%E5%9E%8B/">Nothing类型</a><a class="post-meta__tags" href="/tags/%E5%8F%AF%E7%A9%BA%E6%80%A7%E9%9B%86%E5%90%88/">可空性集合</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/12/03/07kotlin/%E5%9B%9B%E3%80%81kotlin%E4%BB%A3%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><i class="fa fa-chevron-left">  </i><span>四、kotlin代数类型和模式匹配(二)</span></a></div><div class="next-post pull-right"><a href="/2022/12/03/07kotlin/%E4%B8%89%E3%80%81kotlin%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1(%E4%B8%80)/"><span>三、kotlin的类和对象(一)</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2022 By Bangiao</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这是博客github仓库地址：<a target="_blank" rel="noopener" href="https://github.com/bangiao/bangiao.github.io">bangiao.github.io</a>，欢迎访问!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>