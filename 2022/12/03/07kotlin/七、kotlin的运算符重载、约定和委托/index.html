<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="七、kotlin的运算符重载、约定和委托"><meta name="keywords" content="集合,in,约定,重载运算符,重载算术运算符,重载二元运算符,重载符合运算符,重载比较运算符,等号运算符,equals,compareTo,排序运算符,比较运算符,数组操作符,get/set操作对象,contains,rangTo,iterator,invoke,KFunction,函数类型当父类,解构声明,组件函数,componentN,委托,委托事件,by,getValue,setValue,懒加载,lazy,委托属性,观察者模式"><meta name="author" content="Bangiao"><meta name="copyright" content="Bangiao"><title>七、kotlin的运算符重载、约定和委托 | Bangiao's Notebooks</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.</span> <span class="toc-text">约定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">重载算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%BA%8C%E5%85%83%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.</span> <span class="toc-text">重载二元算术运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%A4%8D%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">重载复合运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">重载一元操作符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">重载比较运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6-equals"><span class="toc-number">3.1.</span> <span class="toc-text">等号运算符: equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E8%BF%90%E7%AE%97%E7%AC%A6-compareTo"><span class="toc-number">3.2.</span> <span class="toc-text">排序运算符: compareTo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E7%BA%A6%E5%AE%9A-%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">4.</span> <span class="toc-text">集合和约定(集合的操作符重载)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%80%9F%E5%8A%A9-get-set-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">[]操作符重载借助 get&#x2F;set 操作对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#in-%E7%BA%A6%E5%AE%9A-contains%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">in 约定(contains函数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rangTo-%E7%BA%A6%E5%AE%9A-n-n-1"><span class="toc-number">4.3.</span> <span class="toc-text">rangTo 约定 n..n+1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8iterator%E7%BA%A6%E5%AE%9A-in"><span class="toc-number">4.4.</span> <span class="toc-text">for 循环中使用iterator约定 in</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#invoke-%E7%BA%A6%E5%AE%9A"><span class="toc-number">5.</span> <span class="toc-text">invoke 约定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84-invoke-%E7%BA%A6%E5%AE%9A"><span class="toc-number">5.1.</span> <span class="toc-text">类的 invoke 约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KFunction-%E7%9A%84-invoke-%E7%BA%A6%E5%AE%9A"><span class="toc-number">5.2.</span> <span class="toc-text">KFunction 的 invoke 约定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%BD%93%E7%88%B6%E7%B1%BB"><span class="toc-number">5.2.1.</span> <span class="toc-text">函数类型当父类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%A3%B0%E6%98%8E%E5%92%8C%E7%BB%84%E4%BB%B6%E5%87%BD%E6%95%B0componentN"><span class="toc-number">6.</span> <span class="toc-text">解构声明和组件函数componentN</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E7%94%A8%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E7%9A%84%E9%80%BB%E8%BE%91-%E5%A7%94%E6%89%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">重用属性访问的逻辑: 委托事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-%E7%BA%A6%E5%AE%9A-by-%E5%92%8C-getValue-setValue-%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">委托属性的基本用法(约定 by 和 getValue&#x2F;setValue 函数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7-%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8Cby-lazy"><span class="toc-number">7.2.</span> <span class="toc-text">使用委托属性: 惰性初始化和by lazy()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD-%E2%96%B2"><span class="toc-number">7.2.1.</span> <span class="toc-text">使用另一个属性来实现懒加载 ▲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kotlin%E6%8F%90%E4%BE%9B%E7%9A%84-lazy-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.2.2.</span> <span class="toc-text">kotlin提供的 lazy 函数实现懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lazy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.2.3.</span> <span class="toc-text">lazy 源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7"><span class="toc-number">7.3.</span> <span class="toc-text">实现委托属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">委托的观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98%E7%9A%84%E5%8F%98%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-number">7.5.</span> <span class="toc-text">属性委托的变化规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-map-%E4%B8%AD%E4%BF%9D%E5%AD%98%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">7.6.</span> <span class="toc-text">在 map 中保存属性值</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://imgsa.baidu.com/forum/pic/item/c8179682d158ccbf63dc944d1bd8bc3eb03541a9.jpg"></div><div class="author-info__name text-center">Bangiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/bangiao">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">72</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">638</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">我的博客</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://juejin.cn/user/4248168662314823">掘金</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30690165">CSDN</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.cnblogs.com/bangiao/">博客园</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/bangiao_admin/projects">Gitee笔记源码</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bangiao's Notebooks</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章列表</a><a class="site-page" href="/tags">文章标签</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/sources">笔记源码</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">七、kotlin的运算符重载、约定和委托</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>如果我们定义了个 <code>plus</code> 的操作符重载函数, 那么就可以在该类的实例上使用 <code>+</code> 运算符, 这就是<code>约定</code></p>
<p><code>kotlin</code> 规定了很多这种规定, 但这些规定程序员都可以不需要知道, 只要依靠 <code>IDEA</code> 的智能提示就行了</p>
<h1 id="重载算术运算符"><a href="#重载算术运算符" class="headerlink" title="重载算术运算符"></a>重载算术运算符</h1><h2 id="重载二元算术运算"><a href="#重载二元算术运算" class="headerlink" title="重载二元算术运算"></a>重载二元算术运算</h2><p>定义一个成员的 <code>plus</code> 操作符重载函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">      <span class="keyword">return</span> Point(<span class="keyword">this</span>.x + other.x, <span class="keyword">this</span>.y + other.y)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Point&#123;x = <span class="variable">$x</span>, y = <span class="variable">$y</span>&#125;&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> point2 = Point(<span class="number">1</span>, <span class="number">2</span>) + Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">   println(point2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>可以看出使用的是修饰符 <code>operator</code> 定义一个操作符重载函数</p>
</li>
<li><p><code>plus 函数</code>根据约定概念对应了运算符的 <code>+</code></p>
</li>
<li><p>对应的可重载的函数还有:</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/760d9186bd6a457f975b6db0a7e39e32~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="4">
<li>不论操作符重载函数如何写, 都不会影响操作符的优先级</li>
</ol>
<p>不会导致 <code>* /</code> 的优先级低于 <code>+ -</code></p>
<ol start="5">
<li>可以定义扩展函数的操作符重载 ★</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">   <span class="keyword">return</span> Point(<span class="keyword">this</span>.x + other.x, <span class="keyword">this</span>.y + other.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>kotlin</code> 既可以用成员函数重载操作符, 也可以用扩展函数重载操作符</p>
</blockquote>
<ol start="6">
<li>操作符左右两边的类型可以不一样</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">times</span><span class="params">(d: <span class="type">Double</span>)</span></span>: Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point((<span class="keyword">this</span>.x * d).toInt(), (<span class="keyword">this</span>.y * d).toInt())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(p * <span class="number">1.5</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意: 操作符重载函数的左右两边顺序不可以调换, 上面定义的函数 <code>Point</code> 类型为左, <code>Double</code> 类型为右, 所以 <code>(1.5 * p)</code> 是不可以的, 如果需要则还得创建新的扩展操作符重载函数</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e61d0b4d9c9d402d993913f3b9781a9c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Double</span>.<span class="title">times</span><span class="params">(point: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">   <span class="keyword">return</span> Point((<span class="keyword">this</span> * point.x).toInt(), (<span class="keyword">this</span> * point.y).toInt())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>定义重载操作符扩展函数比较麻烦, 可以这样:</li>
</ol>
<blockquote>
<p>我建议在定义操作符重载函数时, 可以先把需要的运算公式写好, 比如我要写个将值为 <code>&#39;a&#39;</code> 的变量 <code>* 3</code> 得到 <code>&quot;aaa&quot;</code> 的字符串 这样的操作符重载扩展函数, 我们可以先写上 <code>val str: String = &#39;a&#39; * 3</code> </p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b18826af701d49a2a7a4c8fc2675833d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p>然后我们可以创建扩展函数了</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Char</span>.<span class="title">times</span><span class="params">(count: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">   TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在加上我们需要的功能和返回值</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Char</span>.<span class="title">times</span><span class="params">(count: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">   <span class="keyword">return</span> toString().repeat(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不过需要注意, 生成的操作符重载扩展函数默认是 <code>private</code> 如果不需要可以删除掉 <code>private</code> 可见性修饰符</p>
</blockquote>
<p>同时注意, 上面这个扩展函数的亮点:  接收者是 <code>Char</code> 类型, 参数是 <code>Int</code> 类型, 但返回值是 <code>String</code> 类型, 也就是 <code>Char + Int = String</code> 看起来挺奇怪的~~~</p>
<ol start="8">
<li><code>kotlin</code> 没有定义位运算符, 所以关于位的运算符都不可以重载, 不过<code>kotlin</code>提供了很多中缀调用函数</li>
</ol>
<ul>
<li><code>shl</code> 带符号左移</li>
<li><code>shr</code> 带符号右移</li>
<li><code>ushr</code> 无符号右移</li>
<li><code>and</code> 按位与</li>
<li><code>or</code> 按位或</li>
<li><code>xor</code> 异或</li>
<li><code>inv</code> 按位取反</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="number">0x0F</span> and <span class="number">0x0F</span>)</span><br></pre></td></tr></table></figure>

<h2 id="重载复合运算符"><a href="#重载复合运算符" class="headerlink" title="重载复合运算符"></a>重载复合运算符</h2><p>在 <code>kotlin</code> 中 <code>+=</code> 和 <code>-=</code> 这种运算符被称之为复合运算符</p>
<ol>
<li>复合运算符<code>+=</code>下, 面对可变对象的操作符重载, 它定义了新的引用对象, 这种可以直接复用前面写的对 <code>+</code> 的操作符重载函数</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = Point(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">point += Point(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 这里不用再定义新的复合操作符重载函数了, 因为 point = point + Point(2, 3) 前面已经有关于它的 plus 操作符重载函数了</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>+=</code> 复合操作符修改容器内部的内容, 不重新分配新的引用时, 需要定义操作符重载函数了</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arrayList = arrayListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">arrayList += <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><code>+=</code> 操作符重载会定义一个叫 <code>plusAssign</code> 的函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableCollection<span class="type">&lt;in T&gt;</span>.<span class="title">plusAssign</span><span class="params">(element: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.add(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>当同一个类写了 <code>plus</code> 和 <code>plusAssign</code> 两个操作符重载函数, 理论上这俩函数都会被调用, 所以 这俩操作符重载函数还是别同时存在了, 如果真要同时存在, 那么可以把接收者修改为 <code>val</code> 类型,这样 <code>plusAssign</code> 就失效了, 因为 <code>val</code> 不支持再次赋值</li>
</ol>
<h2 id="重载一元操作符"><a href="#重载一元操作符" class="headerlink" title="重载一元操作符"></a>重载一元操作符</h2><p>按照前面的小窍诀, 先写上一元操作符</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> point = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">println(-point)</span><br></pre></td></tr></table></figure>

<p>然后借助 ide 能够生成 操作符重载扩展函数(你也可以选择成员函数)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span>: Point &#123;</span><br><span class="line">   <span class="keyword">return</span> Point(-<span class="keyword">this</span>.x, -<span class="keyword">this</span>.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2c72ddc25c742fd9c8392c931204c52~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>一元操作符没有参数</p>
</li>
<li><p>自增和自减操作符的函数重载</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">inc</span><span class="params">()</span></span>: Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(<span class="keyword">this</span>.x++, <span class="keyword">this</span>.y++)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自增操作符有这样的操作 <code>i++</code> 和 <code>++i</code>, 这两种方式在 <code>kotlin</code> 中重载操作符都是用的同一个扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decimal = BigDecimal(<span class="number">0</span>)</span><br><span class="line">decimal++</span><br><span class="line">println(decimal)</span><br><span class="line">++decimal</span><br><span class="line">println(decimal)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> BigDecimal.<span class="title">inc</span><span class="params">()</span></span>: BigDecimal = <span class="keyword">this</span>.add(BigDecimal.ONE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> BigDecimal.<span class="title">inc</span><span class="params">()</span></span>: BigDecimal = <span class="keyword">this</span>.add(BigDecimal.ONE)</span><br></pre></td></tr></table></figure>

<p>原本以为操作符重载函数相同,  ++i 和 i++ 将变得一样的效果结果发现</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>反编译后发现原来还是强大的 <code>kotlin</code> 编译器做的操作</p>
<p>i++ 反编译后将会变成这样: (大致的样子)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i++ 就会是下面那样: </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(i);</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ++i 则会是这样: </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure>

<p>看到了么? 一个是 先打印再 +1, 另一个是先 +1 再打印, kotlin编译器 yyds</p>
<h1 id="重载比较运算符"><a href="#重载比较运算符" class="headerlink" title="重载比较运算符"></a>重载比较运算符</h1><p><code>==</code> <code>===</code> <code>!=</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> 等这些都是比较运算符</p>
<h2 id="等号运算符-equals"><a href="#等号运算符-equals" class="headerlink" title="等号运算符: equals"></a>等号运算符: <code>equals</code></h2><ol>
<li>根据<code>kotlin</code>的约定, <code>==</code> 和 <code>equals</code> 对应</li>
<li><code>==</code> 和 <code>!=</code> 可以和 <code>null</code> 做比较, 比如 <code>a.equals(b)</code> 中 <code>a</code> 会先判断 <code>null</code> , 然后再调用 <code>equals</code> 判断</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e50d14c1bc64225beb0ba7fab4792fa~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="3">
<li><code>===</code> 恒等运算符</li>
</ol>
<p>(1) 恒等运算符和<code>java</code> 的 <code>==</code> 运算符一样, 比较的是 地址, <code>java</code> 中 叫 <code>引用</code></p>
<p>(2) 恒等运算符 <code>===</code> 不能被重载</p>
<ol start="4">
<li><code>==</code> 运算符不支持扩展函数操作符重载</li>
</ol>
<p><code>==</code> 的约定是 <code>equals</code> 而 该函数在 <code>Any</code> 中已经存在, 此时定义操作符重载的扩展函数的话, 永远不会调用到, 因为 <code>Any</code> 成员函数的优先级永远高于扩展函数</p>
<ol start="5">
<li>如果写了 <code>==</code> 的操作符重载扩展函数, 则不用再写个 <code>!=</code> 的操作符重载扩展函数了, <code>kotlin</code>编译器会帮你的</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(obj: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="comment">// 比较引用(地址)</span></span><br><span class="line">   <span class="keyword">if</span> (obj === <span class="keyword">this</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   <span class="comment">// 比较类型</span></span><br><span class="line">   <span class="keyword">if</span> (obj !<span class="keyword">is</span> Point) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">this</span>.x == obj.x) &amp;&amp; (<span class="keyword">this</span>.y == obj.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> point1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> point2 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (point1 == point2) &#123;</span><br><span class="line">   println(<span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   println(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>仔细看, <code>equals</code> 不是操作符重载函数, 而是重写函数, 所以根本没办法写 <code>equals</code> 的操作符重载函数</p>
</blockquote>
<h2 id="排序运算符-compareTo"><a href="#排序运算符-compareTo" class="headerlink" title="排序运算符: compareTo"></a>排序运算符: <code>compareTo</code></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3705c32062a249aa950c47aa7b17d7bc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>排序运算符有两种实现方式</p>
<ol>
<li>实现 <code>Comparable</code></li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17a3ba583800406294aafab241c5ef72~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="2">
<li>操作符重载函数</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9359a356e8dc4925bda37b9a2fe5bca1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p>我们会看到 <code>compareValuesBy</code> 函数, 该函数接受两个比较对象, 选择比较对象的字段, 依照传递参数的顺序比较, 如果<code>Person::firstName</code> 比较有结果(不相等的话)则后面不再比较 <code>Person::lastName</code></p>
</blockquote>
<h1 id="集合和约定-集合的操作符重载"><a href="#集合和约定-集合的操作符重载" class="headerlink" title="集合和约定(集合的操作符重载)"></a>集合和约定(集合的操作符重载)</h1><h2 id="操作符重载借助-get-set-操作对象"><a href="#操作符重载借助-get-set-操作对象" class="headerlink" title="[]操作符重载借助 get/set 操作对象"></a><code>[]</code>操作符重载借助 <code>get/set</code> 操作对象</h2><p>在 <code>kotlin</code> 中我们可以这样: </p>
<p>只读集合读取:<br><code>val value = map[key]</code></p>
<p>可变集合写入:<br><code>mutableMap[key] = value</code></p>
<p>这些操作都是 kotlin 底层的操作, 主要实现方式是借助 <code>get</code> 和 <code>set</code> 函数完成的, 如果是 读取 则 kotlin 会把读取改成 <code>get(key)</code> 函数, 如果是写入, 则 kotlin 会把它改成 <code>put(key, value)</code>(类似<code>set</code>这样的函数)</p>
<p>那么现在我们要怎么给自定义的类添加类似的操作呢??? </p>
<p>拿出前面的Point类为例, 以 <code>p[0]</code> 获取 <code>x 变量</code>, 以 <code>p[1]</code> 获取 <code>y</code> 变量</p>
<p>借助我们前面的小聪明, 利用 ide 生成了下面两个函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">when</span>(index) &#123;</span><br><span class="line">      <span class="number">1</span> -&gt; <span class="keyword">this</span>.x = value</span><br><span class="line">      <span class="number">2</span> -&gt; <span class="keyword">this</span>.y = value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">when</span>(index) &#123;</span><br><span class="line">      <span class="number">1</span> -&gt; <span class="keyword">this</span>.x</span><br><span class="line">      <span class="number">2</span> -&gt; <span class="keyword">this</span>.y</span><br><span class="line">      <span class="keyword">else</span> -&gt; <span class="literal">null</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">   <span class="keyword">val</span> point = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">   println(point[<span class="number">0</span>])</span><br><span class="line">   println(point[<span class="number">1</span>])</span><br><span class="line">   </span><br><span class="line">   point[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">   point[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来 <code>index</code> 对应这 <code>p[index]</code> 的 <code>index</code>, 这样就可以借助约定规则, 使用 <code>get</code> 操作符重载函数方式实现我们的要求</p>
<h2 id="in-约定-contains函数"><a href="#in-约定-contains函数" class="headerlink" title="in 约定(contains函数)"></a>in 约定(contains函数)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span>(<span class="keyword">val</span> upperLeft: Point, <span class="keyword">val</span> lowerRight: Point) &#123;</span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(point: <span class="type">Point</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> point.x <span class="keyword">in</span> min(upperLeft.x, lowerRight.y) until max(lowerRight.x, upperLeft.x) &amp;&amp;</span><br><span class="line">            point.y <span class="keyword">in</span> min(upperLeft.y, lowerRight.y) until max(lowerRight.y, upperLeft.y)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> rectangle = Rectangle(Point(<span class="number">4</span>, <span class="number">4</span>), Point(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">   <span class="keyword">val</span> point = Point(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">   println(point <span class="keyword">in</span> rectangle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rangTo-约定-n-n-1"><a href="#rangTo-约定-n-n-1" class="headerlink" title="rangTo 约定 n..n+1"></a><code>rangTo</code> 约定 <code>n..n+1</code></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> now = LocalDateTime.now()</span><br><span class="line"><span class="keyword">val</span> vacation = now..now.plusDays(<span class="number">10</span>)</span><br><span class="line">println(now.plusWeeks(<span class="number">1</span>) <span class="keyword">in</span> vacation)</span><br></pre></td></tr></table></figure>

<p><code>now..now.plusDays(10)</code> 会被编译成</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClosedRange vacation = RangesKt.rangeTo((Comparable)now, (Comparable)now.plusDays(<span class="number">10L</span>));</span><br></pre></td></tr></table></figure>

<h2 id="for-循环中使用iterator约定-in"><a href="#for-循环中使用iterator约定-in" class="headerlink" title="for 循环中使用iterator约定 in"></a><code>for</code> 循环中使用<code>iterator</code>约定 <code>in</code></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (c <span class="keyword">in</span> <span class="string">&quot;abcd&quot;</span>) &#123;</span><br><span class="line">      println(c)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>in</code> 底层源码: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">iterator</span><span class="params">()</span></span>: CharIterator = <span class="keyword">object</span> : CharIterator() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">get</span>(index++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = index &lt; length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="invoke-约定"><a href="#invoke-约定" class="headerlink" title="invoke 约定"></a><code>invoke</code> 约定</h1><h2 id="类的-invoke-约定"><a href="#类的-invoke-约定" class="headerlink" title="类的 invoke 约定"></a>类的 <code>invoke</code> 约定</h2><p>把类对象当作函数调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>(<span class="keyword">val</span> greeting: String) &#123;</span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">      println(<span class="string">&quot;<span class="variable">$greeting</span> <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> greeter = Greeter(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">   greeter(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KFunction-的-invoke-约定"><a href="#KFunction-的-invoke-约定" class="headerlink" title="KFunction 的 invoke 约定"></a><code>KFunction</code> 的 <code>invoke</code> 约定</h2><h3 id="函数类型当父类"><a href="#函数类型当父类" class="headerlink" title="函数类型当父类"></a>函数类型当父类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Issue</span>(</span><br><span class="line">   <span class="keyword">val</span> id: String, <span class="keyword">val</span> project: String, <span class="keyword">val</span> type: String,</span><br><span class="line">   <span class="keyword">val</span> priority: String, <span class="keyword">val</span> description: String</span><br><span class="line">) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImportantIssuesPredicate</span>(<span class="keyword">val</span> project: String) : (Issue) -&gt; <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(issue: <span class="type">Issue</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> issue.project == project &amp;&amp; issue.isImportant()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Issue.<span class="title">isImportant</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> type == <span class="string">&quot;Bug&quot;</span> &amp;&amp;</span><br><span class="line">            (priority == <span class="string">&quot;Major&quot;</span> || priority == <span class="string">&quot;Critical&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> issue1 = Issue(<span class="string">&quot;IDEA-154446&quot;</span>, <span class="string">&quot;IDEA&quot;</span>, <span class="string">&quot;Bug&quot;</span>, <span class="string">&quot;Major&quot;</span>, <span class="string">&quot;Save settings failed&quot;</span>)</span><br><span class="line">   <span class="keyword">val</span> issue2 = Issue(</span><br><span class="line">      <span class="string">&quot;KT-12183&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Kotlin&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Feature&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Normal&quot;</span>,</span><br><span class="line">      <span class="string">&quot; Intention: convert several calls on the same receiver to with/apply&quot;</span></span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">val</span> predicate = ImportantIssuesPredicate(<span class="string">&quot;IDEA&quot;</span>)</span><br><span class="line">   listOf(issue1, issue2).filter(predicate).forEach &#123;</span><br><span class="line">      println(it.id)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class ImportantIssuesPredicate(val project: String) : (Issue) -&gt; Boolean</code> 看这个</p>
<p>前面学过的, 函数类型里面有一个函数, 它就是 <code>invoke</code>, 所以我们的类<code>ImportantIssuesPredicate</code>继承了函数类型, 就必须重写<code>invoke</code>函数</p>
<p>而下面的 <code>listOf(issue1, issue2).filter(predicate)</code> 这里的过滤函数可以传入 <code>ImportantIssuesPredicate</code>类, 说明该类本质上还是 <code>(Issue) -&gt; Boolean</code> , 只不过多存储了 个属性 <code>project</code> 和扩展函数<code>isImportant</code></p>
<h1 id="解构声明和组件函数componentN"><a href="#解构声明和组件函数componentN" class="headerlink" title="解构声明和组件函数componentN"></a>解构声明和组件函数<code>componentN</code></h1><p>将一个复合值展开, 用来初始化多个变量, 这就是解构声明</p>
<p>但如果要实现普通对象的解构, 需要添加组件函数, </p>
<p>下图显示的就是普通函数无法使用解构声明, 需要创建成员组件函数或者扩展组件函数, 当然还可以将类改成数据类 <code>data class Point</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e483558715e4c66a288f33c767723a5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">component1</span><span class="params">()</span></span>: <span class="built_in">Int</span> = x</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">component2</span><span class="params">()</span></span>: <span class="built_in">Int</span> = y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">   <span class="keyword">val</span> (x, y) = p</span><br><span class="line">   println(<span class="string">&quot;x = <span class="variable">$x</span>, y = <span class="variable">$y</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们的解构声明就是按照组件函数来分配复合函数解构出来的值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">NameComponents</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> extension: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">splitFileName</span><span class="params">(fullName: <span class="type">String</span>)</span></span>: NameComponents &#123;</span><br><span class="line">   <span class="keyword">val</span> split = fullName.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> NameComponents(split[<span class="number">0</span>], split[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> (name, extension) = splitFileName(<span class="string">&quot;1.txt&quot;</span>)</span><br><span class="line">   println(<span class="string">&quot;name = <span class="variable">$name</span>, extension = <span class="variable">$extension</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现了一个函数返回多个值的功能, 但解构声明也不是无限的, 它仅允许解析一个对象前5个字段</p>
</blockquote>
<h1 id="重用属性访问的逻辑-委托事件"><a href="#重用属性访问的逻辑-委托事件" class="headerlink" title="重用属性访问的逻辑: 委托事件"></a>重用属性访问的逻辑: 委托事件</h1><h2 id="委托属性的基本用法-约定-by-和-getValue-setValue-函数"><a href="#委托属性的基本用法-约定-by-和-getValue-setValue-函数" class="headerlink" title="委托属性的基本用法(约定 by 和 getValue/setValue 函数)"></a>委托属性的基本用法(约定 <code>by</code> 和 <code>getValue/setValue</code> 函数)</h2><p>在前面的委托类中我们知道, 委托的本质是借鸡生蛋</p>
<p>类委托本质是, 委托人继承了某个接口, 但该接口函数的实现委托人委托给了另一个同样实现了该接口的子类对象, 并且以类组合的方式调用函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="type">InterfaceB</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="keyword">val</span> cObject: InterfaceB = C()) : InterfaceB <span class="keyword">by</span> cObject &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">        cObject.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而本章节的属性委托的本质是: 属性把<code>get/set函数</code>交给另一个同样实现的了<code>get/set(getValue/setValue)</code>的对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p:Type <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中 <code>Deletgate()</code> 在委托期间会产生对象, 用于初始化 <code>p</code> 属性, 而委托人需要按照约定定义才能够被 <code>by</code> 委托</p>
<p>而这份约定协议是这样: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Foo, String</span>&gt; &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Foo</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">      TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Foo</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">      TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>约定表明了, 约定对象需要实现 <code>ReadWriteProperty</code>接口</p>
<p>或者约定是这样的: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(foo: <span class="type">Foo</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">      TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(foo: <span class="type">Foo</span>, property: <span class="type">KProperty</span>&lt;*&gt;, s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">      TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要定义两个操作符重载 <code>getValue/setValue</code> 函数</p>
<p>上面这两种约定都可以</p>
<blockquote>
<p>记住, 委托是委托给另一个对象的 <code>getValue</code> 和 <code>setValue</code> , 但不仅仅是 这两 函数, 还可以是 <code>get</code> 和 <code>set</code> 函数, 只要委托的对象可以 <code>println(object[&quot;propertyName&quot;])</code> 或者 <code>object[&quot;propertyName&quot;] = value</code>, 都可以被当做委托的对象(<code>by</code>后面的对象)</p>
</blockquote>
<p>为什么我会这么认为呢? 看 gradle 的 kts </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> compileKotlin: KotlinCompile <span class="keyword">by</span> tasks</span><br><span class="line">println(compileKotlin.javaClass)</span><br><span class="line">compileKotlin.kotlinOptions &#123;</span><br><span class="line">   freeCompilerArgs = listOf(<span class="string">&quot;-opt-in=kotlin.RequiresOptIn&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ck = tasks[<span class="string">&quot;compileKotlin&quot;</span>] <span class="keyword">as</span> KotlinCompile</span><br><span class="line">ck.kotlinOptions &#123;</span><br><span class="line">   freeCompilerArgs = listOf(<span class="string">&quot;-opt-in=kotlin.RequiresOptIn&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>tasks</code> 只有 <code>get</code> 方法</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bed760e34f4d4490bca00bf977bfb1e8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="使用委托属性-惰性初始化和by-lazy"><a href="#使用委托属性-惰性初始化和by-lazy" class="headerlink" title="使用委托属性: 惰性初始化和by lazy()"></a>使用委托属性: 惰性初始化和<code>by lazy()</code></h2><h3 id="使用另一个属性来实现懒加载-▲"><a href="#使用另一个属性来实现懒加载-▲" class="headerlink" title="使用另一个属性来实现懒加载 ▲"></a>使用另一个属性来实现懒加载 ▲</h3><p>以前我们要实现属性懒加载的话, 需要借助临时可空属性, 在第一次需要加载该属性是判断下临时属性是否为 <code>null</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> _emails: List&lt;String&gt;? = <span class="literal">null</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">val</span> email: List&lt;String&gt;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">         <span class="keyword">if</span> (_emails == <span class="literal">null</span>) &#123;</span><br><span class="line">            _emails = loadEmail(<span class="keyword">this</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> _emails!!</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadEmail</span><span class="params">(person: <span class="type">Person</span>)</span></span>: List&lt;String&gt;? &#123;</span><br><span class="line">      <span class="keyword">return</span> listOf(<span class="string">&quot;2033@qq.com&quot;</span>, <span class="string">&quot;2133@qq.com&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式使用的比较多, 不需要任何概念, 直接搞了个懒加载属性, 而且从代码上判断我们的<code>email</code> 属性完全依赖 <code>_email</code> 所以翻译成 <code>java</code> 源码时肯定是只有 <code>_email</code> 属性的, 而 <code>email</code> 仅有 <code>get/set</code> 函数(这里是 <code>val</code>所以只有 <code>get</code>)</p>
</blockquote>
<h3 id="kotlin提供的-lazy-函数实现懒加载"><a href="#kotlin提供的-lazy-函数实现懒加载" class="headerlink" title="kotlin提供的 lazy 函数实现懒加载"></a><code>kotlin</code>提供的 <code>lazy</code> 函数实现懒加载</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">   <span class="keyword">val</span> emails <span class="keyword">by</span> lazy &#123; loadEmail() &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadEmail</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">      println(<span class="string">&quot;loadEmail被调用&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> listOf(<span class="string">&quot;2033@qq.com&quot;</span>, <span class="string">&quot;2933@qq.com&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>lazy</code> 是一个标准库函数, 他的参数是 lambda <code>() -&gt; T</code> 而<code>lazy</code>返回值是 lambda 的返回值, </p>
</li>
<li><p><code>lazy</code> 是线程安全的, <code>lazy</code>可以根据需要切换你想要的线程锁, 或者完全关闭锁</p>
</li>
<li><p><code>lazy</code> 函数最后会返回一个存在<code>getValue</code>函数的对象</p>
</li>
</ol>
<h3 id="lazy-源码分析"><a href="#lazy-源码分析" class="headerlink" title="lazy 源码分析"></a><code>lazy</code> 源码分析</h3><ul>
<li>从这里开始分析</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> emails <span class="keyword">by</span> lazy &#123; loadEmail() &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>by</code> 属性的话, 正常来说会调用 <code>by</code> 后面对象的 <code>getValue/setValue</code> 函数, 看情况, <code>lazy</code> 应该有实现 <code>getValue</code> 函数</li>
</ul>
<p><code>lazy &#123; loadEmail() &#125;</code> 这个返回的绝对是一个对象, 且应该有 <code>getValue</code>或者<code>setValue</code> 函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br></pre></td></tr></table></figure>

<p>发现它 <code>new</code> 了个 <code>SynchronizedLazyImpl</code> 这个类对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</span><br><span class="line">    <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">        <span class="keyword">get</span>() &#123; <span class="comment">// 略 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是核心算法, 要分析也是分析上面这段代码, 但 getValue 这种函数呢??? </p>
<p>可以选择安装 IDEA 的 <code>extSee</code> 插件, 然后查看 <code>扩展函数</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d7136a2ce9742a883019271648d4137~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec29135920844d33a9618ad928747138~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Lazy<span class="type">&lt;T&gt;</span>.<span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T = value</span><br></pre></td></tr></table></figure>

<p>发现它调用的是 <code>value</code> 的 <code>get</code> 函数</p>
<p>现在分析他的核心方法就行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> _v1 = _value</span><br><span class="line">        <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">            <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">            <span class="keyword">return</span> _v1 <span class="keyword">as</span> T <span class="comment">// return _v1 赋值给 email 变量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上线程锁. 这里的 lock 其实是 this 对象</span></span><br><span class="line">        <span class="keyword">return</span> synchronized(lock) &#123;</span><br><span class="line">            <span class="keyword">val</span> _v2 = _value</span><br><span class="line">            <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span> (_v2 <span class="keyword">as</span> T) <span class="comment">// return _v2 赋值给 email 变量</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// lambda 的返回值, 返回出去</span></span><br><span class="line">                <span class="keyword">val</span> typedValue = initializer!!()</span><br><span class="line">                <span class="comment">// 存放在 _value 中, 等待下次判断, 如果 !== UNINITIALIZED_VALUE 直接返回对象</span></span><br><span class="line">                _value = typedValue</span><br><span class="line">                <span class="comment">// 初始化 lambda </span></span><br><span class="line">                initializer = <span class="literal">null</span></span><br><span class="line">                <span class="comment">// 返回 lambda 返回值对象</span></span><br><span class="line">                typedValue  <span class="comment">// return typedValue 赋值给 email 变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中 <code>_value</code> 刚开始的时候初始化的 <code>UNINITIALIZED_VALUE</code>, 等到被赋值了 lambda 的返回值后, 就可以通过 <code>!== UNINITIALIZED_VALUE</code> 判断是否被赋值过</p>
<p>而 <code>_value</code> 和 <code>value</code> 的实现, 和前面的 这一章节 <strong>使用另一个属性来实现懒加载 ▲</strong> 的方式一摸一样, 实现的懒加载方式</p>
<p>所以开始委托的时候 <code>_value</code> 被初始化, 但 <code>value</code> 还是空的(不, <code>value</code> 其实根本没这个字段)</p>
<h2 id="实现委托属性"><a href="#实现委托属性" class="headerlink" title="实现委托属性"></a>实现委托属性</h2><p>前面学过, 我们可以借助另外一个对象, 实现延迟功能, 我们也可以这样实现委托功能</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableProperty</span>(<span class="keyword">val</span> propName: String, <span class="keyword">var</span> propValue: Number, <span class="keyword">val</span> supportChange: PropertyChangeSupport) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: Number &#123;</span><br><span class="line">      <span class="keyword">return</span> propValue</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(value: <span class="type">Number</span>)</span></span> &#123;</span><br><span class="line">      supportChange.firePropertyChange(propName, propValue, value)</span><br><span class="line">      propValue = value</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(_name: String, _age: <span class="built_in">Int</span>, _scope: <span class="built_in">Double</span>) &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> supportChange = PropertyChangeSupport(<span class="keyword">this</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">val</span> name: String = _name</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> __age = ObservableProperty(<span class="string">&quot;age&quot;</span>, _age, supportChange)</span><br><span class="line">   <span class="keyword">var</span> age: <span class="built_in">Int</span></span><br><span class="line">      <span class="keyword">get</span>() = __age.getValue() <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">      <span class="keyword">set</span>(value) &#123;</span><br><span class="line">         __age.setValue(value)</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> __scope = ObservableProperty(<span class="string">&quot;scope&quot;</span>, _scope, supportChange)</span><br><span class="line">   <span class="keyword">var</span> scope: <span class="built_in">Double</span></span><br><span class="line">      <span class="keyword">get</span>() = __scope.getValue() <span class="keyword">as</span> <span class="built_in">Double</span></span><br><span class="line">      <span class="keyword">set</span>(value) &#123;</span><br><span class="line">         __scope.setValue(value)</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">addPropertyChangeEvent</span><span class="params">(listener: <span class="type">PropertyChangeListener</span>)</span></span> &#123;</span><br><span class="line">      supportChange.addPropertyChangeListener(listener)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">removePropertyChangeEvent</span><span class="params">(listener: <span class="type">PropertyChangeListener</span>)</span></span> &#123;</span><br><span class="line">      supportChange.removePropertyChangeListener(listener)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> person = Person(<span class="string">&quot;zhazha&quot;</span>, <span class="number">23</span>, <span class="number">98798.0</span>)</span><br><span class="line">   person.addPropertyChangeEvent &#123;</span><br><span class="line">      PropertyChangeListener &#123;</span><br><span class="line">         println(<span class="string">&quot;field <span class="subst">$&#123;it.propertyName&#125;</span> changed from <span class="subst">$&#123;it.oldValue&#125;</span> to <span class="subst">$&#123;it.newValue&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   person.age = <span class="number">22</span></span><br><span class="line">   person.scope = <span class="number">1000000.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的例子使用的是 <code>PropertyChangeSupport</code>, 用来监控属性变化, 如果属性值修改, 则会被监控到(不过这个类好像用于 <code>UI</code> 显示用的, 反正我没效果)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableProperty</span>(_propValue: <span class="built_in">Int</span>, _supportChange: PropertyChangeSupport) : ReadWriteProperty&lt;Person, <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">var</span> propValue: <span class="built_in">Int</span> = _propValue</span><br><span class="line">   <span class="keyword">val</span> supportChange = _supportChange</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Person</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> propValue</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Person</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">      supportChange.firePropertyChange(property.name, propValue, value)</span><br><span class="line">      propValue = value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">PropertyChangeAware</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">val</span> supportChange = PropertyChangeSupport(<span class="keyword">this</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">addPropertyChangeEvent</span><span class="params">(listener: <span class="type">PropertyChangeListener</span>)</span></span> &#123;</span><br><span class="line">      supportChange.addPropertyChangeListener(listener)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">removePropertyChangeEvent</span><span class="params">(listener: <span class="type">PropertyChangeListener</span>)</span></span> &#123;</span><br><span class="line">      supportChange.removePropertyChangeListener(listener)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(_name: String, _age: <span class="built_in">Int</span>, _salary: <span class="built_in">Int</span>) : PropertyChangeAware() &#123;</span><br><span class="line">   <span class="keyword">val</span> name: String = _name</span><br><span class="line">   <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> ObservableProperty(_age, supportChange)</span><br><span class="line">   <span class="keyword">var</span> salary: <span class="built_in">Int</span> <span class="keyword">by</span> ObservableProperty(_salary, supportChange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> person = Person(<span class="string">&quot;zhazha&quot;</span>, <span class="number">22</span>, <span class="number">17000</span>)</span><br><span class="line">   person.addPropertyChangeEvent &#123;</span><br><span class="line">      PropertyChangeListener &#123;</span><br><span class="line">         println(<span class="string">&quot;field <span class="subst">$&#123;it.propertyName&#125;</span> changed <span class="subst">$&#123;it.oldValue&#125;</span> to <span class="subst">$&#123;it.newValue&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   person.age = <span class="number">23</span></span><br><span class="line">   person.salary = <span class="number">500000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>委托的本质前面已经说过了, 借鸡生蛋, 把自己的 get&#x2F;set 函数能力转移给另一个对象(委托对象), 从这段代码看, 就是这样的, 借助一个对象和对象内的 <code>getValue/setValue</code> 函数进行初始化</p>
</blockquote>
<p>我们还可以用内置的委托类完成上面的功能, 这样就不需要自己再写了(太麻烦了~~~)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">PropertyChangeAware</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">val</span> supportChange = PropertyChangeSupport(<span class="keyword">this</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">addPropertyChangeEvent</span><span class="params">(listener: <span class="type">PropertyChangeListener</span>)</span></span> &#123;</span><br><span class="line">      supportChange.addPropertyChangeListener(listener)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">removePropertyChangeEvent</span><span class="params">(listener: <span class="type">PropertyChangeListener</span>)</span></span> &#123;</span><br><span class="line">      supportChange.removePropertyChangeListener(listener)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(_name: String, _age: <span class="built_in">Int</span>, _salary: <span class="built_in">Int</span>) : PropertyChangeAware() &#123;</span><br><span class="line">   <span class="keyword">val</span> name: String = _name</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> observer = &#123; property: KProperty&lt;*&gt;, oldValue: <span class="built_in">Int</span>, newValue: <span class="built_in">Int</span> -&gt;</span><br><span class="line">      supportChange.firePropertyChange(property.name, oldValue, newValue)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.observable(_age, observer)</span><br><span class="line">   <span class="keyword">var</span> salary: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.observable(_salary, observer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> person = Person(<span class="string">&quot;zhazha&quot;</span>, <span class="number">22</span>, <span class="number">20000</span>)</span><br><span class="line">   person.addPropertyChangeEvent &#123;</span><br><span class="line">      PropertyChangeListener &#123;</span><br><span class="line">         println(<span class="string">&quot;field <span class="subst">$&#123;it.propertyName&#125;</span> changed <span class="subst">$&#123;it.oldValue&#125;</span> to <span class="subst">$&#123;it.newValue&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   person.age = <span class="number">23</span></span><br><span class="line">   person.salary = <span class="number">5000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从目前掌握的来看, <code>by</code> 关键字 右边可以是: 函数调用, 另一个属性或者其他任意表达式, 只要能满足委托功能便可</p>
</blockquote>
<h2 id="委托的观察者模式"><a href="#委托的观察者模式" class="headerlink" title="委托的观察者模式"></a>委托的观察者模式</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> observed = <span class="literal">false</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> max: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.observable(<span class="number">0</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">      <span class="comment">// property: var delegate13.observable.Person.max: kotlin.Int, oldValue: 0, newValue: 13</span></span><br><span class="line">      println(<span class="string">&quot;property: <span class="variable">$property</span>, oldValue: <span class="variable">$oldValue</span>, newValue: <span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">      observed = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> person = Person()</span><br><span class="line">   println(person.observed) <span class="comment">// false</span></span><br><span class="line">   println(person.max) <span class="comment">// 0</span></span><br><span class="line">   person.max = <span class="number">13</span></span><br><span class="line">   println(person.max) <span class="comment">// 13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性委托的变化规则"><a href="#属性委托的变化规则" class="headerlink" title="属性委托的变化规则"></a>属性委托的变化规则</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>MyDelegate</code> 将会生成一个属性<code>&lt;delegate&gt;</code> 同时使用 <code>KProperty</code>类型对象来代表该对象的类型, 它被称为<code>&lt;property&gt;</code></p>
<p>编译器生成代码: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> &lt;delegate&gt; = MyDelegate()</span><br><span class="line">    <span class="keyword">var</span> prop: Type</span><br><span class="line">        <span class="keyword">get</span>() = &lt;delegate&gt;.getValue(<span class="keyword">this</span>, &lt;property&gt;)</span><br><span class="line">        <span class="keyword">set</span>(value) = &lt;delegate&gt;.setValue(<span class="keyword">this</span>, &lt;property&gt;, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="在-map-中保存属性值"><a href="#在-map-中保存属性值" class="headerlink" title="在 map 中保存属性值"></a>在 map 中保存属性值</h2><blockquote>
<p><code>by</code> 委托给一个 <code>map</code> 对象的情况</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">setAttributes</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">      _attributes[attrName] = value</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// get() = _attributes[&quot;name&quot;]!!</span></span><br><span class="line">   <span class="keyword">val</span> name: String <span class="keyword">by</span> _attributes</span><br><span class="line">   <span class="comment">// get() = _attributes[&quot;company&quot;]!!</span></span><br><span class="line">   <span class="keyword">val</span> company: String <span class="keyword">by</span> _attributes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> person02 = MapDemo.Person()</span><br><span class="line">   <span class="keyword">val</span> <span class="keyword">data</span> = mapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;Dmitry&quot;</span>, <span class="string">&quot;company&quot;</span> to <span class="string">&quot;Jetbrain&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> ((attrName, value) <span class="keyword">in</span> <span class="keyword">data</span>) &#123;</span><br><span class="line">      person02.setAttributes(attrName, value)</span><br><span class="line">   &#125;</span><br><span class="line">   println(person02.name)</span><br><span class="line">   println(person02.company)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码在这里: </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get() = _attributes[&quot;name&quot;]!!</span></span><br><span class="line"><span class="keyword">val</span> name: String <span class="keyword">by</span> _attributes</span><br><span class="line"><span class="comment">// get() = _attributes[&quot;company&quot;]!!</span></span><br><span class="line"><span class="keyword">val</span> company: String <span class="keyword">by</span> _attributes</span><br></pre></td></tr></table></figure>

<p>说白了就是把变量的名字当作 <code>HashMap</code> 的 <code>key</code> , 然后获得 <code>value</code></p>
<blockquote>
<p>注意, 这里的 <code>by</code> 用法, 我估计在其他对象上也能使用, 只要该对象也能 <code>object[&quot;key&quot;]</code></p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bangiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bangiao.github.io/2022/12/03/07kotlin/七、kotlin的运算符重载、约定和委托/">https://bangiao.github.io/2022/12/03/07kotlin/七、kotlin的运算符重载、约定和委托/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a><a class="post-meta__tags" href="/tags/in/">in</a><a class="post-meta__tags" href="/tags/%E7%BA%A6%E5%AE%9A/">约定</a><a class="post-meta__tags" href="/tags/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/">重载运算符</a><a class="post-meta__tags" href="/tags/%E9%87%8D%E8%BD%BD%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/">重载算术运算符</a><a class="post-meta__tags" href="/tags/%E9%87%8D%E8%BD%BD%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/">重载二元运算符</a><a class="post-meta__tags" href="/tags/%E9%87%8D%E8%BD%BD%E7%AC%A6%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6/">重载符合运算符</a><a class="post-meta__tags" href="/tags/%E9%87%8D%E8%BD%BD%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/">重载比较运算符</a><a class="post-meta__tags" href="/tags/%E7%AD%89%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6/">等号运算符</a><a class="post-meta__tags" href="/tags/equals/">equals</a><a class="post-meta__tags" href="/tags/compareTo/">compareTo</a><a class="post-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F%E8%BF%90%E7%AE%97%E7%AC%A6/">排序运算符</a><a class="post-meta__tags" href="/tags/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/">比较运算符</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%AC%A6/">数组操作符</a><a class="post-meta__tags" href="/tags/get-set%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1/">get/set操作对象</a><a class="post-meta__tags" href="/tags/contains/">contains</a><a class="post-meta__tags" href="/tags/rangTo/">rangTo</a><a class="post-meta__tags" href="/tags/iterator/">iterator</a><a class="post-meta__tags" href="/tags/invoke/">invoke</a><a class="post-meta__tags" href="/tags/KFunction/">KFunction</a><a class="post-meta__tags" href="/tags/%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%BD%93%E7%88%B6%E7%B1%BB/">函数类型当父类</a><a class="post-meta__tags" href="/tags/%E8%A7%A3%E6%9E%84%E5%A3%B0%E6%98%8E/">解构声明</a><a class="post-meta__tags" href="/tags/%E7%BB%84%E4%BB%B6%E5%87%BD%E6%95%B0/">组件函数</a><a class="post-meta__tags" href="/tags/componentN/">componentN</a><a class="post-meta__tags" href="/tags/%E5%A7%94%E6%89%98/">委托</a><a class="post-meta__tags" href="/tags/%E5%A7%94%E6%89%98%E4%BA%8B%E4%BB%B6/">委托事件</a><a class="post-meta__tags" href="/tags/by/">by</a><a class="post-meta__tags" href="/tags/getValue/">getValue</a><a class="post-meta__tags" href="/tags/setValue/">setValue</a><a class="post-meta__tags" href="/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/">懒加载</a><a class="post-meta__tags" href="/tags/lazy/">lazy</a><a class="post-meta__tags" href="/tags/%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7/">委托属性</a><a class="post-meta__tags" href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/12/03/07kotlin/%E5%85%AB%E3%80%81kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"><i class="fa fa-chevron-left">  </i><span>八、kotlin的高阶函数</span></a></div><div class="next-post pull-right"><a href="/2022/12/03/07kotlin/%E5%85%AD%E3%80%81kotlin%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"><span>六、kotlin的函数式编程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2023 By Bangiao</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这是博客github仓库地址：<a target="_blank" rel="noopener" href="https://github.com/bangiao/bangiao.github.io">bangiao.github.io</a>，欢迎访问!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>